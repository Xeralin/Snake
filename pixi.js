(function () {
  "use strict";
  window.ggl = !1;
  try {
    var fd = document.createElement("canvas"),
      pd = fd.getContext("webgl") || fd.getContext("webgl2");
    pd && pd instanceof WebGLRenderingContext && (window.ggl = !0);
  } catch { }
  if (
    ((window.testing = !1),
      window.location.href.indexOf("/testing") >= 0 && (window.testing = !0),
      (window.iioc = !1),
      (window.nsr = !1),
      (window.forcing = !1),
      (window.fobso = null),
      (window.ua = navigator.userAgent.toLowerCase()),
      (window.is_mobile = window.ua.indexOf("mobile") >= 0),
      (window.is_firefox = !0),
      (window.is_chrome = !1),
      (window.is_safari = !1),
      !0)
  ) { }
  window.raf = window.requestAnimationFrame;
  window.no_raf = false;
  (window.lfsx = void 0),
    (window.lfsy = void 0),
    (window.lfcv = void 0),
    (window.lfvsx = void 0),
    (window.lfvsy = void 0),
    (window.lfesid = void 0),
    (window.sgsdr = 0),
    (window.fdsdr = 0),
    (window.vvd = []),
    (window.vch = 0),
    (window.doiosh = !1),
    (window.a = void 0),
    (window.i = void 0),
    (window.j = void 0),
    (window.k = void 0),
    (window.l = void 0),
    (window.m = void 0),
    (window.n = void 0),
    (window.o = void 0),
    (window.r = void 0),
    (window.v = void 0),
    (window.j2 = void 0),
    (window.fj = void 0),
    (window.fjm4 = void 0),
    (window.d = void 0),
    (window.d2 = void 0),
    (window.d3 = void 0),
    (window.qq = void 0),
    (window.ki = void 0),
    (window.sc = void 0),
    (window.agpu = "translateZ(0)"),
    (window.ang = void 0),
    (window.sang = void 0),
    (window.vang = void 0),
    (window.trf = function (r, e) { r.style.transform = e; }),
    (window.trfo = function (r, e) { r.style.transformOrigin = e; }),
    (window.pi2 = 2 * Math.PI),
    (window.a64k = 65536 / window.pi2),
    (window.animating = !1),
    (window.RectanglePacker = function (r, e, t) {
      (this.mWidth = 0),
        (this.mHeight = 0),
        (this.mPadding = 8),
        (this.mPackedWidth = 0),
        (this.mPackedHeight = 0),
        (this.mInsertList = []),
        (this.mInsertedRectangles = []),
        (this.mFreeAreas = []),
        (this.mNewFreeAreas = []),
        (this.mOutsideRectangle = new window.IntegerRectangle(
          r + 1,
          e + 1,
          0,
          0
        )),
        (this.mSortableSizeStack = []),
        (this.mRectangleStack = []),
        (this.rectangleCount = function () {
          return this.mInsertedRectangles.length;
        }),
        (this.reset = function (a, l, o) {
          for (; this.mInsertedRectangles.length > 0;)
            this.freeRectangle(this.mInsertedRectangles.pop());
          for (; this.mFreeAreas.length > 0;)
            this.freeRectangle(this.mFreeAreas.pop());
          for (
            this.mWidth = a,
            this.mHeight = l,
            this.mPackedWidth = 0,
            this.mPackedHeight = 0,
            this.mFreeAreas[0] = this.allocateRectangle(
              0,
              0,
              this.mWidth,
              this.mHeight
            );
            this.mInsertList.length > 0;

          )
            this.freeSize(this.mInsertList.pop());
          this.mPadding = o;
        }),
        (this.getRectangle = function (a, l) {
          var o = this.mInsertedRectangles[a];
          return l
            ? ((l.x = o.x),
              (l.y = o.y),
              (l.width = o.width),
              (l.height = o.height),
              l)
            : new window.IntegerRectangle(o.x, o.y, o.width, o.height);
        }),
        (this.getRectangleId = function (a) {
          var l = this.mInsertedRectangles[a];
          return l.id;
        }),
        (this.insertRectangle = function (a, l, o) {
          var h = this.allocateSize(a, l, o);
          this.mInsertList.push(h);
        }),
        (this.packRectangles = function (a) {
          for (
            a && this.mInsertList.sort(window.numsort_width);
            this.mInsertList.length > 0;

          ) {
            var l = this.mInsertList.pop(),
              o = l.width,
              h = l.height,
              c = this.getFreeAreaIndex(o, h);
            if (c >= 0) {
              var u = this.mFreeAreas[c],
                d = this.allocateRectangle(u.x, u.y, o, h);
              for (
                d.id = l.id,
                this.generateNewFreeAreas(
                  d,
                  this.mFreeAreas,
                  this.mNewFreeAreas
                );
                this.mNewFreeAreas.length > 0;

              )
                this.mFreeAreas[this.mFreeAreas.length] =
                  this.mNewFreeAreas.pop();
              (this.mInsertedRectangles[this.mInsertedRectangles.length] = d),
                d.right > this.mPackedWidth && (this.mPackedWidth = d.right),
                d.bottom > this.mPackedHeight &&
                (this.mPackedHeight = d.bottom);
            }
            this.freeSize(l);
          }
          return this.rectangleCount();
        }),
        (this.filterSelfSubAreas = function (a) {
          for (var l = a.length - 1; l >= 0; l--)
            for (var o = a[l], h = a.length - 1; h >= 0; h--)
              if (l != h) {
                var c = a[h];
                if (
                  o.x >= c.x &&
                  o.y >= c.y &&
                  o.right <= c.right &&
                  o.bottom <= c.bottom
                ) {
                  this.freeRectangle(o);
                  var u = a.pop();
                  l < a.length && (a[l] = u);
                  break;
                }
              }
        }),
        (this.generateNewFreeAreas = function (a, l, o) {
          var h = a.x,
            c = a.y,
            u = a.right + 1 + this.mPadding,
            d = a.bottom + 1 + this.mPadding,
            f = null;
          this.mPadding == 0 && (f = a);
          for (var p = l.length - 1; p >= 0; p--) {
            var g = l[p];
            if (!(h >= g.right || u <= g.x || c >= g.bottom || d <= g.y)) {
              f ||
                (f = this.allocateRectangle(
                  a.x,
                  a.y,
                  a.width + this.mPadding,
                  a.height + this.mPadding
                )),
                this.generateDividedAreas(f, g, o);
              var _ = l.pop();
              p < l.length && (l[p] = _);
            }
          }
          f && f != a && this.freeRectangle(f), this.filterSelfSubAreas(o);
        }),
        (this.generateDividedAreas = function (a, l, o) {
          var h = 0,
            c = l.right - a.right;
          c > 0 &&
            ((o[o.length] = this.allocateRectangle(a.right, l.y, c, l.height)),
              h++);
          var u = a.x - l.x;
          u > 0 &&
            ((o[o.length] = this.allocateRectangle(l.x, l.y, u, l.height)),
              h++);
          var d = l.bottom - a.bottom;
          d > 0 &&
            ((o[o.length] = this.allocateRectangle(l.x, a.bottom, l.width, d)),
              h++);
          var f = a.y - l.y;
          f > 0 &&
            ((o[o.length] = this.allocateRectangle(l.x, l.y, l.width, f)), h++),
            h == 0 && (a.width < l.width || a.height < l.height)
              ? (o[o.length] = l)
              : this.freeRectangle(l);
        }),
        (this.getFreeAreaIndex = function (a, l) {
          for (
            var o = this.mOutsideRectangle,
            h = -1,
            c = a + this.mPadding,
            u = l + this.mPadding,
            d = this.mFreeAreas.length,
            f = d - 1;
            f >= 0;
            f--
          ) {
            var p = this.mFreeAreas[f];
            if (p.x < this.mPackedWidth || p.y < this.mPackedHeight) {
              if (p.x < o.x && c <= p.width && u <= p.height) {
                if (
                  ((h = f),
                    (c == p.width &&
                      p.width <= p.height &&
                      p.right < this.mWidth) ||
                    (u == p.height && p.height <= p.width))
                )
                  break;
                o = p;
              }
            } else if (p.x < o.x && a <= p.width && l <= p.height) {
              if (
                ((h = f),
                  (a == p.width &&
                    p.width <= p.height &&
                    p.right < this.mWidth) ||
                  (l == p.height && p.height <= p.width))
              )
                break;
              o = p;
            }
          }
          return h;
        }),
        (this.allocateRectangle = function (a, l, o, h) {
          if (this.mRectangleStack.length > 0) {
            var c = this.mRectangleStack.pop();
            return (
              (c.x = a),
              (c.y = l),
              (c.width = o),
              (c.height = h),
              (c.right = a + o),
              (c.bottom = l + h),
              c
            );
          }
          return new window.IntegerRectangle(a, l, o, h);
        }),
        (this.freeRectangle = function (a) {
          this.mRectangleStack[this.mRectangleStack.length] = a;
        }),
        (this.allocateSize = function (a, l, o) {
          if (this.mSortableSizeStack.length > 0) {
            var h = this.mSortableSizeStack.pop();
            return (h.width = a), (h.height = l), (h.id = o), h;
          }
          return new window.SortableSize(a, l, o);
        }),
        (this.freeSize = function (a) {
          this.mSortableSizeStack[this.mSortableSizeStack.length] = a;
        }),
        this.reset(r, e, t);
    }),
    (window.IntegerRectangle = function (r, e, t, a) {
      (this.x = r),
        (this.y = e),
        (this.width = t),
        (this.height = a),
        (this.right = r + t),
        (this.bottom = e + a);
    }),
    (window.SortableSize = function (r, e, t) {
      (this.width = r), (this.height = e), (this.id = t);
    }),
    (window.numsort_width = function (r, e) {
      return r.width - e.width;
    }),
    (window.texture_sheets = []),
    (window.textures = []),
    (window.tssz = 2048),
    (window.cc = document.createElement("canvas")),
    (window.cc.width = window.cc.height = window.tssz),
    (window.o = {}),
    (window.o.width = window.tssz),
    (window.o.height = window.tssz),
    (window.o.cc = window.cc),
    window.texture_sheets.push(window.o),
    (window.sadg = void 0),
    (window.sadu = void 0),
    (window.sadd = void 0),
    (window.j = void 0),
    (window.k = void 0),
    (window.l = void 0),
    (window.p = void 0),
    (window.xx = void 0),
    (window.yy = void 0),
    (window.rad = void 0),
    (window.mos = []),
    (window.whmos = !1),
    (window.swmup = !1),
    (window.sos = []),
    (window.clus = []),
    (window.bso = void 0),
    (window.fbso = null),
    (window.lgbsc = 1),
    (window.lgcsc = 1),
    (window.lb_fr = 0),
    (window.login_fr = 0),
    (window.llgmtm = Date.now()),
    (window.login_iv = -1),
    (window.play_count = 0),
    (window.want_play = !1),
    (window.shoa = !1),
    (window.real_sid = 0),
    (window.lsfr = 0),
    (window.lcldtm = Date.now()),
    (window.nick = document.getElementById("nick")),
    (window.victory = document.getElementById("victory")),
    (window.victory_bg = document.getElementById("victory_bg")),
    (window.logo = document.getElementById("logo")),
    (window.login = document.getElementById("login")),
    (window.lastscore = document.getElementById("lastscore")),
    (window.nick_holder = document.getElementById("nick_holder")),
    (window.victory_holder = document.getElementById("victory_holder")),
    (window.mww = 850),
    (window.mhh = 700),
    (window.mwwp50 = window.mww + 50),
    (window.mhhp50 = window.mhh + 50),
    (window.mwwp150 = window.mww + 150),
    (window.mhhp150 = window.mhh + 150),
    (window.mww2 = window.mww / 2),
    (window.mhh2 = window.mhh / 2),
    (window.mc = document.createElement("canvas")),
    (window.mc.style.position = "fixed"),
    (window.mc.style.left = "0px"),
    (window.mc.style.top = "0px"),
    (window.mc.style.zIndex = 5),
    (window.mc.width = window.mww),
    (window.mc.height = window.mhh),
    (window.mc.className = "nsi"),
    document.body.appendChild(window.mc),
    (window.mc.style.display = "none"),
    (window.mc.style.pointerEvents = "none"),
    (window.loch = document.createElement("div")),
    (window.loch.className = "nsi"),
    (window.loch.style.position = "fixed"),
    (window.loch.style.right = "16px"),
    (window.loch.style.bottom = "16px"),
    (window.loch.style.width = window.loch.style.height = "124px"),
    (window.loch.style.zIndex = 10),
    (window.loch.style.display = "none"),
    document.documentElement.appendChild(window.loch),
    (window.loc = document.createElement("img")),
    window.loch.appendChild(window.loc),
    (window.asmc = document.createElement("canvas")),
    window.loch.appendChild(window.asmc),
    (window.asmc2 = document.createElement("canvas")),
    window.loch.appendChild(window.asmc2),
    (window.sid_tf = document.createElement("div")),
    (window.sid_tf.className = "nsi"),
    (window.sid_tf.style.position = "absolute"),
    (window.sid_tf.style.left = "0px"),
    (window.sid_tf.style.top = "0px"),
    (window.sid_tf.style.width = "200px"),
    (window.sid_tf.style.height = "37px"),
    (window.sid_tf.style.color = "#fff"),
    (window.sid_tf.style.fontFamily =
      'Arial, "Helvetica Neue", Helvetica, sans-serif'),
    (window.sid_tf.style.fontSize = "14px"),
    (window.sid_tf.style.overflow = "hidden"),
    (window.sid_tf.style.opacity = 0.5),
    (window.sid_tf.style.textAlign = "center"),
    (window.sid_tf.style.cursor = "default"),
    (window.sid_tf.style.textShadow = "0px 1px 8px rgba(0, 0, 0, 1)"),
    trf(window.sid_tf, window.agpu),
    window.loch.appendChild(window.sid_tf),
    (window.myloc = document.createElement("img")),
    (window.lc = document.createElement("canvas")),
    (window.lc.width = window.lc.height = 14),
    (window.ctx = window.lc.getContext("2d")),
    (window.ctx.fillStyle = "#fff"),
    (window.ctx.strokeStyle = "#000000"),
    (window.ctx.lineWidth = 2),
    window.ctx.beginPath(),
    window.ctx.arc(7, 7, 2.5, 0, window.pi2),
    window.ctx.stroke(),
    window.ctx.fill(),
    (window.myloc.src = window.lc.toDataURL()),
    (window.myloc.className = "nsi"),
    (window.myloc.style.position = "absolute"),
    (window.myloc.style.left = "0px"),
    (window.myloc.style.top = "0px"),
    (window.myloc.style.opacity = 1),
    (window.myloc.style.zIndex = 13),
    window.trf(window.myloc, window.agpu),
    window.loch.appendChild(window.myloc),
    (window.bpx1 = void 0),
    (window.bpy1 = void 0),
    (window.bpx2 = void 0),
    (window.bpy2 = void 0),
    (window.fpx1 = void 0),
    (window.fpy1 = void 0),
    (window.fpx2 = void 0),
    (window.fpy2 = void 0),
    (window.apx1 = void 0),
    (window.apy1 = void 0),
    (window.apx2 = void 0),
    (window.apy2 = void 0),
    (window.sgsc = (0.9 * 18) / 14),
    (window.gsc = window.sgsc),
    (window.targetGsc = window.sgsc),
    (window.grd = 16384),
    (window.flux_grd = void 0),
    (window.real_flux_grd = void 0),
    (window.flx_tg = 0),
    (window.flux_grds = []),
    (window.flux_grd_pos = 0),
    (window.nsep = 4.5),
    window.ggl && (window.nsep = 4.5),
    (window.tasty = 0),
    (window.shifty = !1),
    (window.rr = void 0),
    (window.gg = void 0),
    (window.bb = void 0),
    (window.render_mode = 2),
    window.is_mobile && (window.render_mode = 1),
    (window.wumsts = !1),
    (window.rank = 0),
    (window.best_rank = 999999999),
    (window.slither_count = 0),
    (window.biggest_slither_count = 0),
    (window.follow_view = !0),
    (window.cm1 = void 0),
    (window.slithers = []),
    (window.foods = []),
    (window.foods_c = 0),
    (window.preys = []),
    (window.os = {}),
    (window.lsang = 0),
    (window.want_e = !1),
    (window.last_e_mtm = 0),
    (window.last_accel_mtm = 0),
    (window.sectors = []),
    (window.nlc = 48),
    (window.vfas = []),
    (window.vfc = 62),
    (window.fvpos = 0),
    (window.fvtg = 0),
    (window.ovxx = void 0),
    (window.ovyy = void 0),
    (window.fvxs = []),
    (window.fvys = []);
  for (var xt = 0; xt < window.vfc; xt++) {
    var ar =
      0.5 *
      (1 - Math.cos((Math.PI * (window.vfc - 1 - xt)) / (window.vfc - 1)));
    (ar += (0.5 * (1 - Math.cos(Math.PI * ar)) - ar) * 0.5),
      window.vfas.push(ar),
      window.fvxs.push(0),
      window.fvys.push(0);
  }
  (window.mmrad = -1),
    (window.mmsz = -1),
    (window.mmal = 0),
    (window.mmbfr = 0),
    (window.mmgad = !1),
    (window.mmsta = 0.475),
    (window.mmdata = null),
    (window.view_xx = 0),
    (window.view_yy = 0),
    (window.view_ang = 0),
    (window.view_dist = 0),
    (window.fvx = 0),
    (window.fvy = 0),
    (window.xm = 0),
    (window.ym = 0),
    (window.lsxm = 0),
    (window.lsym = 0),
    (window.slither = null),
    (window.my_nick = ""),
    (window.gw2k16 = !1);
  try {
    localStorage.gw2k16 == "1" && (window.gw2k16 = !0);
  } catch { }
  for (
    window.dhx = void 0,
    window.dhy = void 0,
    window.hsz = void 0,
    window.fr = 0,
    window.lfr = 0,
    window.ltm = Date.now(),
    window.vfr = 0,
    window.vfrb = 0,
    window.avfr = 0,
    window.afr = 0,
    window.fr2 = 0,
    window.lfr2 = 0,
    window.vfrb2 = 0,
    window.cptm = 0,
    window.lptm = 0,
    window.lpstm = 0,
    window.last_ping_mtm = 0,
    window.want_etm_s = !1,
    window.want_seq = !1,
    window.lseq = 0,
    window.lagging = !1,
    window.lag_mult = 1,
    window.wfpr = !1,
    window.high_quality = !0,
    window.gla = 1,
    window.wdfg = 0,
    window.qsm = 1,
    window.mqsm = 1.7,
    window.playing = !1,
    window.connected = !1,
    window.want_close_socket = !1,
    window.want_victory_message = !1,
    window.want_victory_focus = !1,
    window.want_hide_victory = 0,
    window.hvfr = 0,
    window.dead_mtm = -1,
    window.at2lt = new Float32Array(65536),
    window.yy = 0;
    window.yy < 256;
    window.yy++
  )
    for (window.xx = 0; window.xx < 256; window.xx++)
      window.at2lt[(window.yy << 8) | window.xx] = Math.atan2(
        window.yy - 128,
        window.xx - 128
      );
  if (
    ((window.kd_l_frb = 0),
      (window.kd_r_frb = 0),
      (window.kd_l = !1),
      (window.kd_r = !1),
      (window.kd_u = !1),
      (window.lkstm = 0),
      (window.idba = void 0),
      (window.lgba = void 0),
      (window.random_id = ""),
      (window.alpha_chars = "abcdefghijklmnopqrstuvwxyz"),
      (window.fgfr = 0),
      (window.px = void 0),
      (window.py = void 0),
      (window.lpx = void 0),
      (window.lpy = void 0),
      (window.ax = void 0),
      (window.ay = void 0),
      (window.lax = void 0),
      (window.lay = void 0),
      (window.pax = void 0),
      (window.pay = void 0),
      (window.fx = void 0),
      (window.fy = void 0),
      (window.fs = void 0),
      (window.ww = window.innerWidth),
      (window.hh = window.innerHeight),
      (window.lww = 0),
      (window.lhh = 0),
      (window.hsu = 0),
      (window.csc = void 0),
      (window.maxp = 0),
      (window.fps = 0),
      (window.adm = !1),
      (window.etm = 0),
      (window.ws = null),
      (window.cstr = "c"),
      (window.tcsecs = 0),
      (window.trdps = 0),
      (window.tapkps = 0),
      (window.tpkps = 0),
      (window.apkps = 0),
      (window.pkps = 0),
      (window.rdps = 0),
      (window.rfps = 0),
      (window.rnps = 0),
      (window.rsps = 0),
      (window.reps = 0),
      (window.pkpspc = []),
      (window.rdpspc = []),
      (window.lrd_mtm = Date.now()),
      (window.locu_mtm = 0),
      window.testing)
  )
    for (var xt = 0; xt < 256; xt++)
      (window.rdpspc[xt] = 0), (window.pkpspc[xt] = 0);
  (window.pfs = []),
    (window.pft = 0),
    (window.pf1 = 0),
    (window.pf2 = 0),
    (window.rpf1 = void 0),
    (window.rpf2 = void 0),
    (window.pf_nap = 0),
    (window.pf_ep = 0),
    (window.rpft = 0),
    (window.pf = void 0);
  for (var xt = 0; xt < 100; xt++) window.pfs.push(0);
  (window.pf_add = 0),
    (window.pf_new_add = 0),
    (window.pf_remove = 0),
    (window.tpfa = new Float32Array(4e4));
  for (var xt = 0; xt < window.tpfa.length; xt++)
    window.tpfa[xt] = Math.random() * 32;
  (window.protocol_version = 2),
    (window.connecting = !1),
    (window.start_connect_mtm = void 0),
    (window.play_btn_click_mtm = -1),
    (window.waiting_for_sos = !1),
    (window.sos_ready_after_mtm = -1),
    (window.sos_loaded_at_mtm = -1),
    (window.smh = document.getElementById("smh")),
    (window.csk = document.getElementById("csk")),
    (window.cskh = document.getElementById("cskh")),
    (window.bskh = document.getElementById("bskh")),
    (window.scosh = document.getElementById("scosh")),
    (window.etcoh = document.getElementById("etcoh")),
    (window.csrv = document.getElementById("csrv")),
    (window.csrvh = document.getElementById("csrvh")),
    (window.plq = document.getElementById("plq")),
    (window.clq = document.getElementById("clq")),
    (window.cskh.style.display = "inline"),
    (window.csrvh.style.display = "inline"),
    (window.psk = document.getElementById("psk")),
    (window.pskh = document.getElementById("pskh")),
    (window.nsk = document.getElementById("nsk")),
    (window.nskh = document.getElementById("nskh")),
    (window.hacos = !1),
    (window.bonkz = !1),
    (window.actco = []),
    (window.choosing_skin = !1),
    (window.building_skin = !1),
    (window.ending_build_skin = !1),
    (window.bdska = 0),
    (window.bskoy = 0),
    (window.skoboym = 0),
    (window.build_segments = []),
    (window.bskbtns = []),
    (window.selecting_cosmetic = !1),
    (window.ending_select_cosmetic = !1),
    (window.secosa = 0),
    (window.secosoy = 0),
    (window.secosoym = 0),
    (window.cosbtns = []),
    (window.lmch = document.createElement("div")),
    (window.lmch.style.width = "450px"),
    (window.lmch.style.height = "115px"),
    (window.lmc2 = document.createElement("canvas")),
    (window.lmc = document.createElement("canvas")),
    (window.lgsc = 1),
    (window.lw = 450 * 2),
    (window.lh = 270),
    (window.lmc.width = window.lmc2.width = window.lw),
    (window.lmc.height = window.lmc2.height = window.lh),
    (window.lctx = window.lmc.getContext("2d")),
    (window.lctx2 = window.lmc2.getContext("2d")),
    window.trf(window.lmc2, "scale(.5, .5)"),
    window.trfo(window.lmc2, "0% 0%"),
    window.lmch.appendChild(window.lmc2),
    window.logo.appendChild(window.lmch),
    (window.bgee = void 0),
    (window.bgi3 = void 0),
    (window.grd = 16384),
    (window.ssdo = void 0),
    (window.eyeo = {}),
    (window.pupilo = {}),
    (window.tpupilo = {}),
    (window.fdlo = void 0),
    (window.fdglo = void 0),
    (window.nmlo = void 0),
    (window.prlo = void 0),
    (window.suglo = void 0),
    (window.shilo = void 0),
    (window.slilo = void 0),
    (window.sfilo = void 0),
    (window.sdilo = void 0),
    (window.g2lo = void 0),
    (window.prglo = void 0);
  const G2 = "modulepreload",
    D2 = function (r) {
      return "/" + r;
    },
    U2 = {},
    Ha = function (e, t, a) {
      let l = Promise.resolve();
      function o(h) {
        const c = new Event("vite:preloadError", { cancelable: !0 });
        if (((c.payload = h), window.dispatchEvent(c), !c.defaultPrevented))
          throw h;
      }
      return l.then((h) => {
        for (const c of h || []) c.status === "rejected" && o(c.reason);
        return e().catch(o);
      });
    };
  var P = ((r) => (
    (r.Application = "application"),
    (r.WebGLPipes = "webgl-pipes"),
    (r.WebGLPipesAdaptor = "webgl-pipes-adaptor"),
    (r.WebGLSystem = "webgl-system"),
    (r.WebGPUPipes = "webgpu-pipes"),
    (r.WebGPUPipesAdaptor = "webgpu-pipes-adaptor"),
    (r.WebGPUSystem = "webgpu-system"),
    (r.CanvasSystem = "canvas-system"),
    (r.CanvasPipesAdaptor = "canvas-pipes-adaptor"),
    (r.CanvasPipes = "canvas-pipes"),
    (r.Asset = "asset"),
    (r.LoadParser = "load-parser"),
    (r.ResolveParser = "resolve-parser"),
    (r.CacheParser = "cache-parser"),
    (r.DetectionParser = "detection-parser"),
    (r.MaskEffect = "mask-effect"),
    (r.BlendMode = "blend-mode"),
    (r.TextureSource = "texture-source"),
    (r.Environment = "environment"),
    (r.ShapeBuilder = "shape-builder"),
    (r.Batcher = "batcher"),
    r
  ))(P || {});
  const Tl = (r) => {
    if (typeof r == "function" || (typeof r == "object" && r.extension)) {
      if (!r.extension)
        throw new Error("Extension class must have an extension object");
      r = {
        ...(typeof r.extension != "object"
          ? { type: r.extension }
          : r.extension),
        ref: r,
      };
    }
    if (typeof r == "object") r = { ...r };
    else throw new Error("Invalid extension type");
    return typeof r.type == "string" && (r.type = [r.type]), r;
  },
    za = (r, e) => Tl(r).priority ?? e,
    ge = {
      _addHandlers: {},
      _removeHandlers: {},
      _queue: {},
      remove(...r) {
        return (
          r.map(Tl).forEach((e) => {
            e.type.forEach((t) => this._removeHandlers[t]?.(e));
          }),
          this
        );
      },
      add(...r) {
        return (
          r.map(Tl).forEach((e) => {
            e.type.forEach((t) => {
              const a = this._addHandlers,
                l = this._queue;
              a[t] ? a[t]?.(e) : ((l[t] = l[t] || []), l[t]?.push(e));
            });
          }),
          this
        );
      },
      handle(r, e, t) {
        const a = this._addHandlers,
          l = this._removeHandlers;
        if (a[r] || l[r])
          throw new Error(`Extension type ${r} already has a handler`);
        (a[r] = e), (l[r] = t);
        const o = this._queue;
        return o[r] && (o[r]?.forEach((h) => e(h)), delete o[r]), this;
      },
      handleByMap(r, e) {
        return this.handle(
          r,
          (t) => {
            t.name && (e[t.name] = t.ref);
          },
          (t) => {
            t.name && delete e[t.name];
          }
        );
      },
      handleByNamedList(r, e, t = -1) {
        return this.handle(
          r,
          (a) => {
            e.findIndex((o) => o.name === a.name) >= 0 ||
              (e.push({ name: a.name, value: a.ref }),
                e.sort((o, h) => za(h.value, t) - za(o.value, t)));
          },
          (a) => {
            const l = e.findIndex((o) => o.name === a.name);
            l !== -1 && e.splice(l, 1);
          }
        );
      },
      handleByList(r, e, t = -1) {
        return this.handle(
          r,
          (a) => {
            e.includes(a.ref) ||
              (e.push(a.ref), e.sort((l, o) => za(o, t) - za(l, t)));
          },
          (a) => {
            const l = e.indexOf(a.ref);
            l !== -1 && e.splice(l, 1);
          }
        );
      },
      mixin(r, ...e) {
        for (const t of e)
          Object.defineProperties(
            r.prototype,
            Object.getOwnPropertyDescriptors(t)
          );
      },
    },
    _1 = {
      extension: { type: P.Environment, name: "browser", priority: -1 },
      test: () => !0,
      load: async () => {
        await Ha(() => Promise.resolve().then(() => B2), void 0);
      },
    },
    y1 = {
      extension: { type: P.Environment, name: "webworker", priority: 0 },
      test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
      load: async () => {
        await Ha(() => Promise.resolve().then(() => F2), void 0);
      },
    };
  class Tt {
    constructor(e, t, a) {
      (this._x = t || 0), (this._y = a || 0), (this._observer = e);
    }
    clone(e) {
      return new Tt(e ?? this._observer, this._x, this._y);
    }
    set(e = 0, t = e) {
      return (
        (this._x !== e || this._y !== t) &&
        ((this._x = e), (this._y = t), this._observer._onUpdate(this)),
        this
      );
    }
    copyFrom(e) {
      return (
        (this._x !== e.x || this._y !== e.y) &&
        ((this._x = e.x), (this._y = e.y), this._observer._onUpdate(this)),
        this
      );
    }
    copyTo(e) {
      return e.set(this._x, this._y), e;
    }
    equals(e) {
      return e.x === this._x && e.y === this._y;
    }
    toString() {
      return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
    }
    get x() {
      return this._x;
    }
    set x(e) {
      this._x !== e && ((this._x = e), this._observer._onUpdate(this));
    }
    get y() {
      return this._y;
    }
    set y(e) {
      this._y !== e && ((this._y = e), this._observer._onUpdate(this));
    }
  }
  function _d(r) {
    return r &&
      r.__esModule &&
      Object.prototype.hasOwnProperty.call(r, "default")
      ? r.default
      : r;
  }
  var Cl = { exports: {} },
    yd;
  function x1() {
    return (
      yd ||
      ((yd = 1),
        (function (r) {
          var e = Object.prototype.hasOwnProperty,
            t = "~";
          function a() { }
          Object.create &&
            ((a.prototype = Object.create(null)),
              new a().__proto__ || (t = !1));
          function l(u, d, f) {
            (this.fn = u), (this.context = d), (this.once = f || !1);
          }
          function o(u, d, f, p, g) {
            if (typeof f != "function")
              throw new TypeError("The listener must be a function");
            var _ = new l(f, p || u, g),
              m = t ? t + d : d;
            return (
              u._events[m]
                ? u._events[m].fn
                  ? (u._events[m] = [u._events[m], _])
                  : u._events[m].push(_)
                : ((u._events[m] = _), u._eventsCount++),
              u
            );
          }
          function h(u, d) {
            --u._eventsCount === 0
              ? (u._events = new a())
              : delete u._events[d];
          }
          function c() {
            (this._events = new a()), (this._eventsCount = 0);
          }
          (c.prototype.eventNames = function () {
            var d = [],
              f,
              p;
            if (this._eventsCount === 0) return d;
            for (p in (f = this._events))
              e.call(f, p) && d.push(t ? p.slice(1) : p);
            return Object.getOwnPropertySymbols
              ? d.concat(Object.getOwnPropertySymbols(f))
              : d;
          }),
            (c.prototype.listeners = function (d) {
              var f = t ? t + d : d,
                p = this._events[f];
              if (!p) return [];
              if (p.fn) return [p.fn];
              for (var g = 0, _ = p.length, m = new Array(_); g < _; g++)
                m[g] = p[g].fn;
              return m;
            }),
            (c.prototype.listenerCount = function (d) {
              var f = t ? t + d : d,
                p = this._events[f];
              return p ? (p.fn ? 1 : p.length) : 0;
            }),
            (c.prototype.emit = function (d, f, p, g, _, m) {
              var w = t ? t + d : d;
              if (!this._events[w]) return !1;
              var x = this._events[w],
                M = arguments.length,
                b,
                T;
              if (x.fn) {
                switch (
                (x.once && this.removeListener(d, x.fn, void 0, !0), M)
                ) {
                  case 1:
                    return x.fn.call(x.context), !0;
                  case 2:
                    return x.fn.call(x.context, f), !0;
                  case 3:
                    return x.fn.call(x.context, f, p), !0;
                  case 4:
                    return x.fn.call(x.context, f, p, g), !0;
                  case 5:
                    return x.fn.call(x.context, f, p, g, _), !0;
                  case 6:
                    return x.fn.call(x.context, f, p, g, _, m), !0;
                }
                for (T = 1, b = new Array(M - 1); T < M; T++)
                  b[T - 1] = arguments[T];
                x.fn.apply(x.context, b);
              } else {
                var C = x.length,
                  A;
                for (T = 0; T < C; T++)
                  switch (
                  (x[T].once && this.removeListener(d, x[T].fn, void 0, !0),
                    M)
                  ) {
                    case 1:
                      x[T].fn.call(x[T].context);
                      break;
                    case 2:
                      x[T].fn.call(x[T].context, f);
                      break;
                    case 3:
                      x[T].fn.call(x[T].context, f, p);
                      break;
                    case 4:
                      x[T].fn.call(x[T].context, f, p, g);
                      break;
                    default:
                      if (!b)
                        for (A = 1, b = new Array(M - 1); A < M; A++)
                          b[A - 1] = arguments[A];
                      x[T].fn.apply(x[T].context, b);
                  }
              }
              return !0;
            }),
            (c.prototype.on = function (d, f, p) {
              return o(this, d, f, p, !1);
            }),
            (c.prototype.once = function (d, f, p) {
              return o(this, d, f, p, !0);
            }),
            (c.prototype.removeListener = function (d, f, p, g) {
              var _ = t ? t + d : d;
              if (!this._events[_]) return this;
              if (!f) return h(this, _), this;
              var m = this._events[_];
              if (m.fn)
                m.fn === f &&
                  (!g || m.once) &&
                  (!p || m.context === p) &&
                  h(this, _);
              else {
                for (var w = 0, x = [], M = m.length; w < M; w++)
                  (m[w].fn !== f ||
                    (g && !m[w].once) ||
                    (p && m[w].context !== p)) &&
                    x.push(m[w]);
                x.length
                  ? (this._events[_] = x.length === 1 ? x[0] : x)
                  : h(this, _);
              }
              return this;
            }),
            (c.prototype.removeAllListeners = function (d) {
              var f;
              return (
                d
                  ? ((f = t ? t + d : d), this._events[f] && h(this, f))
                  : ((this._events = new a()), (this._eventsCount = 0)),
                this
              );
            }),
            (c.prototype.off = c.prototype.removeListener),
            (c.prototype.addListener = c.prototype.on),
            (c.prefixed = t),
            (c.EventEmitter = c),
            (r.exports = c);
        })(Cl)),
      Cl.exports
    );
  }
  var v1 = x1();
  const Os = _d(v1),
    b1 = Math.PI * 2,
    w1 = 180 / Math.PI,
    S1 = Math.PI / 180;
  class Je {
    constructor(e = 0, t = 0) {
      (this.x = 0), (this.y = 0), (this.x = e), (this.y = t);
    }
    clone() {
      return new Je(this.x, this.y);
    }
    copyFrom(e) {
      return this.set(e.x, e.y), this;
    }
    copyTo(e) {
      return e.set(this.x, this.y), e;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    set(e = 0, t = e) {
      return (this.x = e), (this.y = t), this;
    }
    toString() {
      return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
    }
    static get shared() {
      return (Al.x = 0), (Al.y = 0), Al;
    }
  }
  const Al = new Je();
  class ae {
    constructor(e = 1, t = 0, a = 0, l = 1, o = 0, h = 0) {
      (this.array = null),
        (this.a = e),
        (this.b = t),
        (this.c = a),
        (this.d = l),
        (this.tx = o),
        (this.ty = h);
    }
    fromArray(e) {
      (this.a = e[0]),
        (this.b = e[1]),
        (this.c = e[3]),
        (this.d = e[4]),
        (this.tx = e[2]),
        (this.ty = e[5]);
    }
    set(e, t, a, l, o, h) {
      return (
        (this.a = e),
        (this.b = t),
        (this.c = a),
        (this.d = l),
        (this.tx = o),
        (this.ty = h),
        this
      );
    }
    toArray(e, t) {
      this.array || (this.array = new Float32Array(9));
      const a = t || this.array;
      return (
        e
          ? ((a[0] = this.a),
            (a[1] = this.b),
            (a[2] = 0),
            (a[3] = this.c),
            (a[4] = this.d),
            (a[5] = 0),
            (a[6] = this.tx),
            (a[7] = this.ty),
            (a[8] = 1))
          : ((a[0] = this.a),
            (a[1] = this.c),
            (a[2] = this.tx),
            (a[3] = this.b),
            (a[4] = this.d),
            (a[5] = this.ty),
            (a[6] = 0),
            (a[7] = 0),
            (a[8] = 1)),
        a
      );
    }
    apply(e, t) {
      t = t || new Je();
      const a = e.x,
        l = e.y;
      return (
        (t.x = this.a * a + this.c * l + this.tx),
        (t.y = this.b * a + this.d * l + this.ty),
        t
      );
    }
    applyInverse(e, t) {
      t = t || new Je();
      const a = this.a,
        l = this.b,
        o = this.c,
        h = this.d,
        c = this.tx,
        u = this.ty,
        d = 1 / (a * h + o * -l),
        f = e.x,
        p = e.y;
      return (
        (t.x = h * d * f + -o * d * p + (u * o - c * h) * d),
        (t.y = a * d * p + -l * d * f + (-u * a + c * l) * d),
        t
      );
    }
    translate(e, t) {
      return (this.tx += e), (this.ty += t), this;
    }
    scale(e, t) {
      return (
        (this.a *= e),
        (this.d *= t),
        (this.c *= e),
        (this.b *= t),
        (this.tx *= e),
        (this.ty *= t),
        this
      );
    }
    rotate(e) {
      const t = Math.cos(e),
        a = Math.sin(e),
        l = this.a,
        o = this.c,
        h = this.tx;
      return (
        (this.a = l * t - this.b * a),
        (this.b = l * a + this.b * t),
        (this.c = o * t - this.d * a),
        (this.d = o * a + this.d * t),
        (this.tx = h * t - this.ty * a),
        (this.ty = h * a + this.ty * t),
        this
      );
    }
    append(e) {
      const t = this.a,
        a = this.b,
        l = this.c,
        o = this.d;
      return (
        (this.a = e.a * t + e.b * l),
        (this.b = e.a * a + e.b * o),
        (this.c = e.c * t + e.d * l),
        (this.d = e.c * a + e.d * o),
        (this.tx = e.tx * t + e.ty * l + this.tx),
        (this.ty = e.tx * a + e.ty * o + this.ty),
        this
      );
    }
    appendFrom(e, t) {
      const a = e.a,
        l = e.b,
        o = e.c,
        h = e.d,
        c = e.tx,
        u = e.ty,
        d = t.a,
        f = t.b,
        p = t.c,
        g = t.d;
      return (
        (this.a = a * d + l * p),
        (this.b = a * f + l * g),
        (this.c = o * d + h * p),
        (this.d = o * f + h * g),
        (this.tx = c * d + u * p + t.tx),
        (this.ty = c * f + u * g + t.ty),
        this
      );
    }
    setTransform(e, t, a, l, o, h, c, u, d) {
      return (
        (this.a = Math.cos(c + d) * o),
        (this.b = Math.sin(c + d) * o),
        (this.c = -Math.sin(c - u) * h),
        (this.d = Math.cos(c - u) * h),
        (this.tx = e - (a * this.a + l * this.c)),
        (this.ty = t - (a * this.b + l * this.d)),
        this
      );
    }
    prepend(e) {
      const t = this.tx;
      if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
        const a = this.a,
          l = this.c;
        (this.a = a * e.a + this.b * e.c),
          (this.b = a * e.b + this.b * e.d),
          (this.c = l * e.a + this.d * e.c),
          (this.d = l * e.b + this.d * e.d);
      }
      return (
        (this.tx = t * e.a + this.ty * e.c + e.tx),
        (this.ty = t * e.b + this.ty * e.d + e.ty),
        this
      );
    }
    decompose(e) {
      const t = this.a,
        a = this.b,
        l = this.c,
        o = this.d,
        h = e.pivot,
        c = -Math.atan2(-l, o),
        u = Math.atan2(a, t),
        d = Math.abs(c + u);
      return (
        d < 1e-5 || Math.abs(b1 - d) < 1e-5
          ? ((e.rotation = u), (e.skew.x = e.skew.y = 0))
          : ((e.rotation = 0), (e.skew.x = c), (e.skew.y = u)),
        (e.scale.x = Math.sqrt(t * t + a * a)),
        (e.scale.y = Math.sqrt(l * l + o * o)),
        (e.position.x = this.tx + (h.x * t + h.y * l)),
        (e.position.y = this.ty + (h.x * a + h.y * o)),
        e
      );
    }
    invert() {
      const e = this.a,
        t = this.b,
        a = this.c,
        l = this.d,
        o = this.tx,
        h = e * l - t * a;
      return (
        (this.a = l / h),
        (this.b = -t / h),
        (this.c = -a / h),
        (this.d = e / h),
        (this.tx = (a * this.ty - l * o) / h),
        (this.ty = -(e * this.ty - t * o) / h),
        this
      );
    }
    isIdentity() {
      return (
        this.a === 1 &&
        this.b === 0 &&
        this.c === 0 &&
        this.d === 1 &&
        this.tx === 0 &&
        this.ty === 0
      );
    }
    identity() {
      return (
        (this.a = 1),
        (this.b = 0),
        (this.c = 0),
        (this.d = 1),
        (this.tx = 0),
        (this.ty = 0),
        this
      );
    }
    clone() {
      const e = new ae();
      return (
        (e.a = this.a),
        (e.b = this.b),
        (e.c = this.c),
        (e.d = this.d),
        (e.tx = this.tx),
        (e.ty = this.ty),
        e
      );
    }
    copyTo(e) {
      return (
        (e.a = this.a),
        (e.b = this.b),
        (e.c = this.c),
        (e.d = this.d),
        (e.tx = this.tx),
        (e.ty = this.ty),
        e
      );
    }
    copyFrom(e) {
      return (
        (this.a = e.a),
        (this.b = e.b),
        (this.c = e.c),
        (this.d = e.d),
        (this.tx = e.tx),
        (this.ty = e.ty),
        this
      );
    }
    equals(e) {
      return (
        e.a === this.a &&
        e.b === this.b &&
        e.c === this.c &&
        e.d === this.d &&
        e.tx === this.tx &&
        e.ty === this.ty
      );
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return T1.identity();
    }
    static get shared() {
      return M1.identity();
    }
  }
  const M1 = new ae(),
    T1 = new ae(),
    Ar = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    Pr = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    Er = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    kr = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    Pl = [],
    xd = [],
    Wa = Math.sign;
  function C1() {
    for (let r = 0; r < 16; r++) {
      const e = [];
      Pl.push(e);
      for (let t = 0; t < 16; t++) {
        const a = Wa(Ar[r] * Ar[t] + Er[r] * Pr[t]),
          l = Wa(Pr[r] * Ar[t] + kr[r] * Pr[t]),
          o = Wa(Ar[r] * Er[t] + Er[r] * kr[t]),
          h = Wa(Pr[r] * Er[t] + kr[r] * kr[t]);
        for (let c = 0; c < 16; c++)
          if (Ar[c] === a && Pr[c] === l && Er[c] === o && kr[c] === h) {
            e.push(c);
            break;
          }
      }
    }
    for (let r = 0; r < 16; r++) {
      const e = new ae();
      e.set(Ar[r], Pr[r], Er[r], kr[r], 0, 0), xd.push(e);
    }
  }
  C1();
  const $e = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: (r) => Ar[r],
    uY: (r) => Pr[r],
    vX: (r) => Er[r],
    vY: (r) => kr[r],
    inv: (r) => (r & 8 ? r & 15 : -r & 7),
    add: (r, e) => Pl[r][e],
    sub: (r, e) => Pl[r][$e.inv(e)],
    rotate180: (r) => r ^ 4,
    isVertical: (r) => (r & 3) === 2,
    byDirection: (r, e) =>
      Math.abs(r) * 2 <= Math.abs(e)
        ? e >= 0
          ? $e.S
          : $e.N
        : Math.abs(e) * 2 <= Math.abs(r)
          ? r > 0
            ? $e.E
            : $e.W
          : e > 0
            ? r > 0
              ? $e.SE
              : $e.SW
            : r > 0
              ? $e.NE
              : $e.NW,
    matrixAppendRotationInv: (r, e, t = 0, a = 0) => {
      const l = xd[$e.inv(e)];
      (l.tx = t), (l.ty = a), r.append(l);
    },
    transformRectCoords: (r, e, t, a) => {
      const { x: l, y: o, width: h, height: c } = r,
        { x: u, y: d, width: f, height: p } = e;
      return t === $e.E
        ? (a.set(l + u, o + d, h, c), a)
        : t === $e.S
          ? a.set(f - o - c + u, l + d, c, h)
          : t === $e.W
            ? a.set(f - l - h + u, p - o - c + d, h, c)
            : t === $e.N
              ? a.set(o + u, p - l - h + d, c, h)
              : a.set(l + u, o + d, h, c);
    },
  },
    Va = [new Je(), new Je(), new Je(), new Je()];
  class Le {
    constructor(e = 0, t = 0, a = 0, l = 0) {
      (this.type = "rectangle"),
        (this.x = Number(e)),
        (this.y = Number(t)),
        (this.width = Number(a)),
        (this.height = Number(l));
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new Le(0, 0, 0, 0);
    }
    clone() {
      return new Le(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(e) {
      return (
        (this.x = e.minX),
        (this.y = e.minY),
        (this.width = e.maxX - e.minX),
        (this.height = e.maxY - e.minY),
        this
      );
    }
    copyFrom(e) {
      return (
        (this.x = e.x),
        (this.y = e.y),
        (this.width = e.width),
        (this.height = e.height),
        this
      );
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, t) {
      return this.width <= 0 || this.height <= 0
        ? !1
        : e >= this.x &&
        e < this.x + this.width &&
        t >= this.y &&
        t < this.y + this.height;
    }
    strokeContains(e, t, a, l = 0.5) {
      const { width: o, height: h } = this;
      if (o <= 0 || h <= 0) return !1;
      const c = this.x,
        u = this.y,
        d = a * (1 - l),
        f = a - d,
        p = c - d,
        g = c + o + d,
        _ = u - d,
        m = u + h + d,
        w = c + f,
        x = c + o - f,
        M = u + f,
        b = u + h - f;
      return (
        e >= p &&
        e <= g &&
        t >= _ &&
        t <= m &&
        !(e > w && e < x && t > M && t < b)
      );
    }
    intersects(e, t) {
      if (!t) {
        const W = this.x < e.x ? e.x : this.x;
        if ((this.right > e.right ? e.right : this.right) <= W) return !1;
        const I = this.y < e.y ? e.y : this.y;
        return (this.bottom > e.bottom ? e.bottom : this.bottom) > I;
      }
      const a = this.left,
        l = this.right,
        o = this.top,
        h = this.bottom;
      if (l <= a || h <= o) return !1;
      const c = Va[0].set(e.left, e.top),
        u = Va[1].set(e.left, e.bottom),
        d = Va[2].set(e.right, e.top),
        f = Va[3].set(e.right, e.bottom);
      if (d.x <= c.x || u.y <= c.y) return !1;
      const p = Math.sign(t.a * t.d - t.b * t.c);
      if (
        p === 0 ||
        (t.apply(c, c),
          t.apply(u, u),
          t.apply(d, d),
          t.apply(f, f),
          Math.max(c.x, u.x, d.x, f.x) <= a ||
          Math.min(c.x, u.x, d.x, f.x) >= l ||
          Math.max(c.y, u.y, d.y, f.y) <= o ||
          Math.min(c.y, u.y, d.y, f.y) >= h)
      )
        return !1;
      const g = p * (u.y - c.y),
        _ = p * (c.x - u.x),
        m = g * a + _ * o,
        w = g * l + _ * o,
        x = g * a + _ * h,
        M = g * l + _ * h;
      if (
        Math.max(m, w, x, M) <= g * c.x + _ * c.y ||
        Math.min(m, w, x, M) >= g * f.x + _ * f.y
      )
        return !1;
      const b = p * (c.y - d.y),
        T = p * (d.x - c.x),
        C = b * a + T * o,
        A = b * l + T * o,
        R = b * a + T * h,
        k = b * l + T * h;
      return !(
        Math.max(C, A, R, k) <= b * c.x + T * c.y ||
        Math.min(C, A, R, k) >= b * f.x + T * f.y
      );
    }
    pad(e = 0, t = e) {
      return (
        (this.x -= e),
        (this.y -= t),
        (this.width += e * 2),
        (this.height += t * 2),
        this
      );
    }
    fit(e) {
      const t = Math.max(this.x, e.x),
        a = Math.min(this.x + this.width, e.x + e.width),
        l = Math.max(this.y, e.y),
        o = Math.min(this.y + this.height, e.y + e.height);
      return (
        (this.x = t),
        (this.width = Math.max(a - t, 0)),
        (this.y = l),
        (this.height = Math.max(o - l, 0)),
        this
      );
    }
    ceil(e = 1, t = 0.001) {
      const a = Math.ceil((this.x + this.width - t) * e) / e,
        l = Math.ceil((this.y + this.height - t) * e) / e;
      return (
        (this.x = Math.floor((this.x + t) * e) / e),
        (this.y = Math.floor((this.y + t) * e) / e),
        (this.width = a - this.x),
        (this.height = l - this.y),
        this
      );
    }
    scale(e, t = e) {
      return (
        (this.x *= e),
        (this.y *= t),
        (this.width *= e),
        (this.height *= t),
        this
      );
    }
    enlarge(e) {
      const t = Math.min(this.x, e.x),
        a = Math.max(this.x + this.width, e.x + e.width),
        l = Math.min(this.y, e.y),
        o = Math.max(this.y + this.height, e.y + e.height);
      return (
        (this.x = t),
        (this.width = a - t),
        (this.y = l),
        (this.height = o - l),
        this
      );
    }
    getBounds(e) {
      return e || (e = new Le()), e.copyFrom(this), e;
    }
    containsRect(e) {
      if (this.width <= 0 || this.height <= 0) return !1;
      const t = e.x,
        a = e.y,
        l = e.x + e.width,
        o = e.y + e.height;
      return (
        t >= this.x &&
        t < this.x + this.width &&
        a >= this.y &&
        a < this.y + this.height &&
        l >= this.x &&
        l < this.x + this.width &&
        o >= this.y &&
        o < this.y + this.height
      );
    }
    set(e, t, a, l) {
      return (
        (this.x = e), (this.y = t), (this.width = a), (this.height = l), this
      );
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  }
  const El = { default: -1 };
  function et(r = "default") {
    return El[r] === void 0 && (El[r] = -1), ++El[r];
  }
  const vd = new Set(),
    Ie = "8.0.0",
    A1 = "8.3.4",
    Yr = { quiet: !0, noColor: !0 },
    me = (r, e, t = 3) => {
      if (Yr.quiet || vd.has(e)) return;
      let a = new Error().stack;
      const l = `${e}
Deprecated since v${r}`,
        o = typeof console.groupCollapsed == "function" && !Yr.noColor;
      typeof a > "u"
        ? console.warn("PixiJS Deprecation Warning: ", l)
        : ((a = a
          .split(
            `
`
          )
          .splice(t).join(`
`)),
          o
            ? (console.groupCollapsed(
              "%cPixiJS Deprecation Warning: %c%s",
              "color:#614108;background:#fffbe6",
              "font-weight:normal;color:#614108;background:#fffbe6",
              l
            ),
              console.warn(a),
              console.groupEnd())
            : (console.warn("PixiJS Deprecation Warning: ", l),
              console.warn(a))),
        vd.add(e);
    };
  Object.defineProperties(me, {
    quiet: {
      get: () => Yr.quiet,
      set: (r) => {
        Yr.quiet = r;
      },
      enumerable: !0,
      configurable: !1,
    },
    noColor: {
      get: () => Yr.noColor,
      set: (r) => {
        Yr.noColor = r;
      },
      enumerable: !0,
      configurable: !1,
    },
  });
  const bd = () => { };
  function $r(r) {
    return (
      (r += r === 0 ? 1 : 0),
      --r,
      (r |= r >>> 1),
      (r |= r >>> 2),
      (r |= r >>> 4),
      (r |= r >>> 8),
      (r |= r >>> 16),
      r + 1
    );
  }
  function wd(r) {
    return !(r & (r - 1)) && !!r;
  }
  function Sd(r) {
    const e = {};
    for (const t in r) r[t] !== void 0 && (e[t] = r[t]);
    return e;
  }
  const Md = Object.create(null);
  function P1(r) {
    const e = Md[r];
    return e === void 0 && (Md[r] = et("resource")), e;
  }
  const Td = class Ym extends Os {
    constructor(e = {}) {
      super(),
        (this._resourceType = "textureSampler"),
        (this._touched = 0),
        (this._maxAnisotropy = 1),
        (this.destroyed = !1),
        (e = { ...Ym.defaultOptions, ...e }),
        (this.addressMode = e.addressMode),
        (this.addressModeU = e.addressModeU ?? this.addressModeU),
        (this.addressModeV = e.addressModeV ?? this.addressModeV),
        (this.addressModeW = e.addressModeW ?? this.addressModeW),
        (this.scaleMode = e.scaleMode),
        (this.magFilter = e.magFilter ?? this.magFilter),
        (this.minFilter = e.minFilter ?? this.minFilter),
        (this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter),
        (this.lodMinClamp = e.lodMinClamp),
        (this.lodMaxClamp = e.lodMaxClamp),
        (this.compare = e.compare),
        (this.maxAnisotropy = e.maxAnisotropy ?? 1);
    }
    set addressMode(e) {
      (this.addressModeU = e), (this.addressModeV = e), (this.addressModeW = e);
    }
    get addressMode() {
      return this.addressModeU;
    }
    set wrapMode(e) {
      me(Ie, "TextureStyle.wrapMode is now TextureStyle.addressMode"),
        (this.addressMode = e);
    }
    get wrapMode() {
      return this.addressMode;
    }
    set scaleMode(e) {
      (this.magFilter = e), (this.minFilter = e), (this.mipmapFilter = e);
    }
    get scaleMode() {
      return this.magFilter;
    }
    set maxAnisotropy(e) {
      (this._maxAnisotropy = Math.min(e, 16)),
        this._maxAnisotropy > 1 && (this.scaleMode = "linear");
    }
    get maxAnisotropy() {
      return this._maxAnisotropy;
    }
    get _resourceId() {
      return this._sharedResourceId || this._generateResourceId();
    }
    update() {
      this.emit("change", this), (this._sharedResourceId = null);
    }
    _generateResourceId() {
      const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
      return (this._sharedResourceId = P1(e)), this._resourceId;
    }
    destroy() {
      (this.destroyed = !0),
        this.emit("destroy", this),
        this.emit("change", this),
        this.removeAllListeners();
    }
  };
  Td.defaultOptions = { addressMode: "clamp-to-edge", scaleMode: "linear" };
  let Pi = Td;
  const Cd = class $m extends Os {
    constructor(e = {}) {
      super(),
        (this.options = e),
        (this.uid = et("textureSource")),
        (this._resourceType = "textureSource"),
        (this._resourceId = et("resource")),
        (this.uploadMethodId = "unknown"),
        (this._resolution = 1),
        (this.pixelWidth = 1),
        (this.pixelHeight = 1),
        (this.width = 1),
        (this.height = 1),
        (this.sampleCount = 1),
        (this.mipLevelCount = 1),
        (this.autoGenerateMipmaps = !1),
        (this.format = "rgba8unorm"),
        (this.dimension = "2d"),
        (this.antialias = !1),
        (this._touched = 0),
        (this._batchTick = -1),
        (this._textureBindLocation = -1),
        (e = { ...$m.defaultOptions, ...e }),
        (this.label = e.label ?? ""),
        (this.resource = e.resource),
        (this.autoGarbageCollect = e.autoGarbageCollect),
        (this._resolution = e.resolution),
        e.width
          ? (this.pixelWidth = e.width * this._resolution)
          : (this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1),
        e.height
          ? (this.pixelHeight = e.height * this._resolution)
          : (this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1),
        (this.width = this.pixelWidth / this._resolution),
        (this.height = this.pixelHeight / this._resolution),
        (this.format = e.format),
        (this.dimension = e.dimensions),
        (this.mipLevelCount = e.mipLevelCount),
        (this.autoGenerateMipmaps = e.autoGenerateMipmaps),
        (this.sampleCount = e.sampleCount),
        (this.antialias = e.antialias),
        (this.alphaMode = e.alphaMode),
        (this.style = new Pi(Sd(e))),
        (this.destroyed = !1),
        this._refreshPOT();
    }
    get source() {
      return this;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      this.style !== e &&
        (this._style?.off("change", this._onStyleChange, this),
          (this._style = e),
          this._style?.on("change", this._onStyleChange, this),
          this._onStyleChange());
    }
    set maxAnisotropy(e) {
      this._style.maxAnisotropy = e;
    }
    get maxAnisotropy() {
      return this._style.maxAnisotropy;
    }
    get addressMode() {
      return this._style.addressMode;
    }
    set addressMode(e) {
      this._style.addressMode = e;
    }
    get repeatMode() {
      return this._style.addressMode;
    }
    set repeatMode(e) {
      this._style.addressMode = e;
    }
    get magFilter() {
      return this._style.magFilter;
    }
    set magFilter(e) {
      this._style.magFilter = e;
    }
    get minFilter() {
      return this._style.minFilter;
    }
    set minFilter(e) {
      this._style.minFilter = e;
    }
    get mipmapFilter() {
      return this._style.mipmapFilter;
    }
    set mipmapFilter(e) {
      this._style.mipmapFilter = e;
    }
    get lodMinClamp() {
      return this._style.lodMinClamp;
    }
    set lodMinClamp(e) {
      this._style.lodMinClamp = e;
    }
    get lodMaxClamp() {
      return this._style.lodMaxClamp;
    }
    set lodMaxClamp(e) {
      this._style.lodMaxClamp = e;
    }
    _onStyleChange() {
      this.emit("styleChange", this);
    }
    update() {
      if (this.resource) {
        const e = this._resolution;
        if (this.resize(this.resourceWidth / e, this.resourceHeight / e))
          return;
      }
      this.emit("update", this);
    }
    destroy() {
      (this.destroyed = !0),
        this.emit("destroy", this),
        this.emit("change", this),
        this._style && (this._style.destroy(), (this._style = null)),
        (this.uploadMethodId = null),
        (this.resource = null),
        this.removeAllListeners();
    }
    unload() {
      (this._resourceId = et("resource")),
        this.emit("change", this),
        this.emit("unload", this);
    }
    get resourceWidth() {
      const { resource: e } = this;
      return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
    }
    get resourceHeight() {
      const { resource: e } = this;
      return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(e) {
      this._resolution !== e &&
        ((this._resolution = e),
          (this.width = this.pixelWidth / e),
          (this.height = this.pixelHeight / e));
    }
    resize(e, t, a) {
      a || (a = this._resolution),
        e || (e = this.width),
        t || (t = this.height);
      const l = Math.round(e * a),
        o = Math.round(t * a);
      return (
        (this.width = l / a),
        (this.height = o / a),
        (this._resolution = a),
        this.pixelWidth === l && this.pixelHeight === o
          ? !1
          : (this._refreshPOT(),
            (this.pixelWidth = l),
            (this.pixelHeight = o),
            this.emit("resize", this),
            (this._resourceId = et("resource")),
            this.emit("change", this),
            !0)
      );
    }
    updateMipmaps() {
      this.autoGenerateMipmaps &&
        this.mipLevelCount > 1 &&
        this.emit("updateMipmaps", this);
    }
    set wrapMode(e) {
      this._style.wrapMode = e;
    }
    get wrapMode() {
      return this._style.wrapMode;
    }
    set scaleMode(e) {
      this._style.scaleMode = e;
    }
    get scaleMode() {
      return this._style.scaleMode;
    }
    _refreshPOT() {
      this.isPowerOfTwo = wd(this.pixelWidth) && wd(this.pixelHeight);
    }
    static test(e) {
      throw new Error("Unimplemented");
    }
  };
  Cd.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: !1,
    sampleCount: 1,
    antialias: !1,
    autoGarbageCollect: !1,
  };
  let zt = Cd;
  class kl extends zt {
    constructor(e) {
      const t = e.resource || new Float32Array(e.width * e.height * 4);
      let a = e.format;
      a ||
        (t instanceof Float32Array
          ? (a = "rgba32float")
          : t instanceof Int32Array || t instanceof Uint32Array
            ? (a = "rgba32uint")
            : t instanceof Int16Array || t instanceof Uint16Array
              ? (a = "rgba16uint")
              : (t instanceof Int8Array, (a = "bgra8unorm"))),
        super({ ...e, resource: t, format: a }),
        (this.uploadMethodId = "buffer");
    }
    static test(e) {
      return (
        e instanceof Int8Array ||
        e instanceof Uint8Array ||
        e instanceof Uint8ClampedArray ||
        e instanceof Int16Array ||
        e instanceof Uint16Array ||
        e instanceof Int32Array ||
        e instanceof Uint32Array ||
        e instanceof Float32Array
      );
    }
  }
  kl.extension = P.TextureSource;
  const Ad = new ae();
  class Pd {
    constructor(e, t) {
      (this.mapCoord = new ae()),
        (this.uClampFrame = new Float32Array(4)),
        (this.uClampOffset = new Float32Array(2)),
        (this._textureID = -1),
        (this._updateID = 0),
        (this.clampOffset = 0),
        typeof t > "u"
          ? (this.clampMargin = e.width < 10 ? 0 : 0.5)
          : (this.clampMargin = t),
        (this.isSimple = !1),
        (this.texture = e);
    }
    get texture() {
      return this._texture;
    }
    set texture(e) {
      this.texture !== e &&
        (this._texture?.removeListener("update", this.update, this),
          (this._texture = e),
          this._texture.addListener("update", this.update, this),
          this.update());
    }
    multiplyUvs(e, t) {
      t === void 0 && (t = e);
      const a = this.mapCoord;
      for (let l = 0; l < e.length; l += 2) {
        const o = e[l],
          h = e[l + 1];
        (t[l] = o * a.a + h * a.c + a.tx),
          (t[l + 1] = o * a.b + h * a.d + a.ty);
      }
      return t;
    }
    update() {
      const e = this._texture;
      this._updateID++;
      const t = e.uvs;
      this.mapCoord.set(
        t.x1 - t.x0,
        t.y1 - t.y0,
        t.x3 - t.x0,
        t.y3 - t.y0,
        t.x0,
        t.y0
      );
      const a = e.orig,
        l = e.trim;
      l &&
        (Ad.set(
          a.width / l.width,
          0,
          0,
          a.height / l.height,
          -l.x / l.width,
          -l.y / l.height
        ),
          this.mapCoord.append(Ad));
      const o = e.source,
        h = this.uClampFrame,
        c = this.clampMargin / o._resolution,
        u = this.clampOffset / o._resolution;
      return (
        (h[0] = (e.frame.x + c + u) / o.width),
        (h[1] = (e.frame.y + c + u) / o.height),
        (h[2] = (e.frame.x + e.frame.width - c + u) / o.width),
        (h[3] = (e.frame.y + e.frame.height - c + u) / o.height),
        (this.uClampOffset[0] = this.clampOffset / o.pixelWidth),
        (this.uClampOffset[1] = this.clampOffset / o.pixelHeight),
        (this.isSimple =
          e.frame.width === o.width &&
          e.frame.height === o.height &&
          e.rotate === 0),
        !0
      );
    }
  }
  class te extends Os {
    constructor({
      source: e,
      label: t,
      frame: a,
      orig: l,
      trim: o,
      defaultAnchor: h,
      defaultBorders: c,
      rotate: u,
      dynamic: d,
    } = {}) {
      if (
        (super(),
          (this.uid = et("texture")),
          (this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }),
          (this.frame = new Le()),
          (this.noFrame = !1),
          (this.dynamic = !1),
          (this.isTexture = !0),
          (this.label = t),
          (this.source = e?.source ?? new zt()),
          (this.noFrame = !a),
          a)
      )
        this.frame.copyFrom(a);
      else {
        const { width: f, height: p } = this._source;
        (this.frame.width = f), (this.frame.height = p);
      }
      (this.orig = l || this.frame),
        (this.trim = o),
        (this.rotate = u ?? 0),
        (this.defaultAnchor = h),
        (this.defaultBorders = c),
        (this.destroyed = !1),
        (this.dynamic = d || !1),
        this.updateUvs();
    }
    set source(e) {
      this._source && this._source.off("resize", this.update, this),
        (this._source = e),
        e.on("resize", this.update, this),
        this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      return (
        this._textureMatrix || (this._textureMatrix = new Pd(this)),
        this._textureMatrix
      );
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const { uvs: e, frame: t } = this,
        { width: a, height: l } = this._source,
        o = t.x / a,
        h = t.y / l,
        c = t.width / a,
        u = t.height / l;
      let d = this.rotate;
      if (d) {
        const f = c / 2,
          p = u / 2,
          g = o + f,
          _ = h + p;
        (d = $e.add(d, $e.NW)),
          (e.x0 = g + f * $e.uX(d)),
          (e.y0 = _ + p * $e.uY(d)),
          (d = $e.add(d, 2)),
          (e.x1 = g + f * $e.uX(d)),
          (e.y1 = _ + p * $e.uY(d)),
          (d = $e.add(d, 2)),
          (e.x2 = g + f * $e.uX(d)),
          (e.y2 = _ + p * $e.uY(d)),
          (d = $e.add(d, 2)),
          (e.x3 = g + f * $e.uX(d)),
          (e.y3 = _ + p * $e.uY(d));
      } else
        (e.x0 = o),
          (e.y0 = h),
          (e.x1 = o + c),
          (e.y1 = h),
          (e.x2 = o + c),
          (e.y2 = h + u),
          (e.x3 = o),
          (e.y3 = h + u);
    }
    destroy(e = !1) {
      this._source && e && (this._source.destroy(), (this._source = null)),
        (this._textureMatrix = null),
        (this.destroyed = !0),
        this.emit("destroy", this),
        this.removeAllListeners();
    }
    update() {
      this.noFrame &&
        ((this.frame.width = this._source.width),
          (this.frame.height = this._source.height)),
        this.updateUvs(),
        this.emit("update", this);
    }
    get baseTexture() {
      return me(Ie, "Texture.baseTexture is now Texture.source"), this._source;
    }
  }
  (te.EMPTY = new te({ label: "EMPTY", source: new zt({ label: "EMPTY" }) })),
    (te.EMPTY.destroy = bd),
    (te.WHITE = new te({
      source: new kl({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: "premultiply-alpha-on-upload",
        label: "WHITE",
      }),
      label: "WHITE",
    })),
    (te.WHITE.destroy = bd);
  function Ed(r, e, t) {
    const { width: a, height: l } = t.orig,
      o = t.trim;
    if (o) {
      const h = o.width,
        c = o.height;
      (r.minX = o.x - e._x * a),
        (r.maxX = r.minX + h),
        (r.minY = o.y - e._y * l),
        (r.maxY = r.minY + c);
    } else
      (r.minX = -e._x * a),
        (r.maxX = r.minX + a),
        (r.minY = -e._y * l),
        (r.maxY = r.minY + l);
  }
  const kd = new ae();
  class cs {
    constructor(e = 1 / 0, t = 1 / 0, a = -1 / 0, l = -1 / 0) {
      (this.minX = 1 / 0),
        (this.minY = 1 / 0),
        (this.maxX = -1 / 0),
        (this.maxY = -1 / 0),
        (this.matrix = kd),
        (this.minX = e),
        (this.minY = t),
        (this.maxX = a),
        (this.maxY = l);
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new Le());
      const e = this._rectangle;
      return (
        this.minX > this.maxX || this.minY > this.maxY
          ? ((e.x = 0), (e.y = 0), (e.width = 0), (e.height = 0))
          : e.copyFromBounds(this),
        e
      );
    }
    clear() {
      return (
        (this.minX = 1 / 0),
        (this.minY = 1 / 0),
        (this.maxX = -1 / 0),
        (this.maxY = -1 / 0),
        (this.matrix = kd),
        this
      );
    }
    set(e, t, a, l) {
      (this.minX = e), (this.minY = t), (this.maxX = a), (this.maxY = l);
    }
    addFrame(e, t, a, l, o) {
      o || (o = this.matrix);
      const h = o.a,
        c = o.b,
        u = o.c,
        d = o.d,
        f = o.tx,
        p = o.ty;
      let g = this.minX,
        _ = this.minY,
        m = this.maxX,
        w = this.maxY,
        x = h * e + u * t + f,
        M = c * e + d * t + p;
      x < g && (g = x),
        M < _ && (_ = M),
        x > m && (m = x),
        M > w && (w = M),
        (x = h * a + u * t + f),
        (M = c * a + d * t + p),
        x < g && (g = x),
        M < _ && (_ = M),
        x > m && (m = x),
        M > w && (w = M),
        (x = h * e + u * l + f),
        (M = c * e + d * l + p),
        x < g && (g = x),
        M < _ && (_ = M),
        x > m && (m = x),
        M > w && (w = M),
        (x = h * a + u * l + f),
        (M = c * a + d * l + p),
        x < g && (g = x),
        M < _ && (_ = M),
        x > m && (m = x),
        M > w && (w = M),
        (this.minX = g),
        (this.minY = _),
        (this.maxX = m),
        (this.maxY = w);
    }
    addRect(e, t) {
      this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
    }
    addBounds(e, t) {
      this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
    }
    addBoundsMask(e) {
      (this.minX = this.minX > e.minX ? this.minX : e.minX),
        (this.minY = this.minY > e.minY ? this.minY : e.minY),
        (this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX),
        (this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY);
    }
    applyMatrix(e) {
      const t = this.minX,
        a = this.minY,
        l = this.maxX,
        o = this.maxY,
        { a: h, b: c, c: u, d, tx: f, ty: p } = e;
      let g = h * t + u * a + f,
        _ = c * t + d * a + p;
      (this.minX = g),
        (this.minY = _),
        (this.maxX = g),
        (this.maxY = _),
        (g = h * l + u * a + f),
        (_ = c * l + d * a + p),
        (this.minX = g < this.minX ? g : this.minX),
        (this.minY = _ < this.minY ? _ : this.minY),
        (this.maxX = g > this.maxX ? g : this.maxX),
        (this.maxY = _ > this.maxY ? _ : this.maxY),
        (g = h * t + u * o + f),
        (_ = c * t + d * o + p),
        (this.minX = g < this.minX ? g : this.minX),
        (this.minY = _ < this.minY ? _ : this.minY),
        (this.maxX = g > this.maxX ? g : this.maxX),
        (this.maxY = _ > this.maxY ? _ : this.maxY),
        (g = h * l + u * o + f),
        (_ = c * l + d * o + p),
        (this.minX = g < this.minX ? g : this.minX),
        (this.minY = _ < this.minY ? _ : this.minY),
        (this.maxX = g > this.maxX ? g : this.maxX),
        (this.maxY = _ > this.maxY ? _ : this.maxY);
    }
    fit(e) {
      return (
        this.minX < e.left && (this.minX = e.left),
        this.maxX > e.right && (this.maxX = e.right),
        this.minY < e.top && (this.minY = e.top),
        this.maxY > e.bottom && (this.maxY = e.bottom),
        this
      );
    }
    fitBounds(e, t, a, l) {
      return (
        this.minX < e && (this.minX = e),
        this.maxX > t && (this.maxX = t),
        this.minY < a && (this.minY = a),
        this.maxY > l && (this.maxY = l),
        this
      );
    }
    pad(e, t = e) {
      return (
        (this.minX -= e),
        (this.maxX += e),
        (this.minY -= t),
        (this.maxY += t),
        this
      );
    }
    ceil() {
      return (
        (this.minX = Math.floor(this.minX)),
        (this.minY = Math.floor(this.minY)),
        (this.maxX = Math.ceil(this.maxX)),
        (this.maxY = Math.ceil(this.maxY)),
        this
      );
    }
    clone() {
      return new cs(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(e, t = e) {
      return (
        (this.minX *= e),
        (this.minY *= t),
        (this.maxX *= e),
        (this.maxY *= t),
        this
      );
    }
    get x() {
      return this.minX;
    }
    set x(e) {
      const t = this.maxX - this.minX;
      (this.minX = e), (this.maxX = e + t);
    }
    get y() {
      return this.minY;
    }
    set y(e) {
      const t = this.maxY - this.minY;
      (this.minY = e), (this.maxY = e + t);
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(e) {
      this.maxX = this.minX + e;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(e) {
      this.maxY = this.minY + e;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
    }
    get isValid() {
      return this.minX + this.minY !== 1 / 0;
    }
    addVertexData(e, t, a, l) {
      let o = this.minX,
        h = this.minY,
        c = this.maxX,
        u = this.maxY;
      l || (l = this.matrix);
      const d = l.a,
        f = l.b,
        p = l.c,
        g = l.d,
        _ = l.tx,
        m = l.ty;
      for (let w = t; w < a; w += 2) {
        const x = e[w],
          M = e[w + 1],
          b = d * x + p * M + _,
          T = f * x + g * M + m;
        (o = b < o ? b : o),
          (h = T < h ? T : h),
          (c = b > c ? b : c),
          (u = T > u ? T : u);
      }
      (this.minX = o), (this.minY = h), (this.maxX = c), (this.maxY = u);
    }
    containsPoint(e, t) {
      return (
        this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t
      );
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(e) {
      return (
        (this.minX = e.minX),
        (this.minY = e.minY),
        (this.maxX = e.maxX),
        (this.maxY = e.maxY),
        this
      );
    }
  }
  var E1 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
    Wi = function (r) {
      return typeof r == "string" ? r.length > 0 : typeof r == "number";
    },
    $t = function (r, e, t) {
      return (
        e === void 0 && (e = 0),
        t === void 0 && (t = Math.pow(10, e)),
        Math.round(t * r) / t + 0
      );
    },
    Qs = function (r, e, t) {
      return (
        e === void 0 && (e = 0),
        t === void 0 && (t = 1),
        r > t ? t : r > e ? r : e
      );
    },
    Rd = function (r) {
      return (r = isFinite(r) ? r % 360 : 0) > 0 ? r : r + 360;
    },
    Id = function (r) {
      return {
        r: Qs(r.r, 0, 255),
        g: Qs(r.g, 0, 255),
        b: Qs(r.b, 0, 255),
        a: Qs(r.a),
      };
    },
    Rl = function (r) {
      return { r: $t(r.r), g: $t(r.g), b: $t(r.b), a: $t(r.a, 3) };
    },
    k1 = /^#([0-9a-f]{3,8})$/i,
    ja = function (r) {
      var e = r.toString(16);
      return e.length < 2 ? "0" + e : e;
    },
    Bd = function (r) {
      var e = r.r,
        t = r.g,
        a = r.b,
        l = r.a,
        o = Math.max(e, t, a),
        h = o - Math.min(e, t, a),
        c = h
          ? o === e
            ? (t - a) / h
            : o === t
              ? 2 + (a - e) / h
              : 4 + (e - t) / h
          : 0;
      return {
        h: 60 * (c < 0 ? c + 6 : c),
        s: o ? (h / o) * 100 : 0,
        v: (o / 255) * 100,
        a: l,
      };
    },
    Fd = function (r) {
      var e = r.h,
        t = r.s,
        a = r.v,
        l = r.a;
      (e = (e / 360) * 6), (t /= 100), (a /= 100);
      var o = Math.floor(e),
        h = a * (1 - t),
        c = a * (1 - (e - o) * t),
        u = a * (1 - (1 - e + o) * t),
        d = o % 6;
      return {
        r: 255 * [a, c, h, h, u, a][d],
        g: 255 * [u, a, a, c, h, h][d],
        b: 255 * [h, h, u, a, a, c][d],
        a: l,
      };
    },
    Gd = function (r) {
      return { h: Rd(r.h), s: Qs(r.s, 0, 100), l: Qs(r.l, 0, 100), a: Qs(r.a) };
    },
    Dd = function (r) {
      return { h: $t(r.h), s: $t(r.s), l: $t(r.l), a: $t(r.a, 3) };
    },
    Ud = function (r) {
      return Fd(
        ((t = (e = r).s),
        {
          h: e.h,
          s:
            (t *= ((a = e.l) < 50 ? a : 100 - a) / 100) > 0
              ? ((2 * t) / (a + t)) * 100
              : 0,
          v: a + t,
          a: e.a,
        })
      );
      var e, t, a;
    },
    kn = function (r) {
      return {
        h: (e = Bd(r)).h,
        s:
          (l = ((200 - (t = e.s)) * (a = e.v)) / 100) > 0 && l < 200
            ? ((t * a) / 100 / (l <= 100 ? l : 200 - l)) * 100
            : 0,
        l: l / 2,
        a: e.a,
      };
      var e, t, a, l;
    },
    R1 =
      /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    I1 =
      /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    B1 =
      /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    F1 =
      /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    Il = {
      string: [
        [
          function (r) {
            var e = k1.exec(r);
            return e
              ? (r = e[1]).length <= 4
                ? {
                  r: parseInt(r[0] + r[0], 16),
                  g: parseInt(r[1] + r[1], 16),
                  b: parseInt(r[2] + r[2], 16),
                  a:
                    r.length === 4
                      ? $t(parseInt(r[3] + r[3], 16) / 255, 2)
                      : 1,
                }
                : r.length === 6 || r.length === 8
                  ? {
                    r: parseInt(r.substr(0, 2), 16),
                    g: parseInt(r.substr(2, 2), 16),
                    b: parseInt(r.substr(4, 2), 16),
                    a:
                      r.length === 8
                        ? $t(parseInt(r.substr(6, 2), 16) / 255, 2)
                        : 1,
                  }
                  : null
              : null;
          },
          "hex",
        ],
        [
          function (r) {
            var e = B1.exec(r) || F1.exec(r);
            return e
              ? e[2] !== e[4] || e[4] !== e[6]
                ? null
                : Id({
                  r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                  g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                  b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                  a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1),
                })
              : null;
          },
          "rgb",
        ],
        [
          function (r) {
            var e = R1.exec(r) || I1.exec(r);
            if (!e) return null;
            var t,
              a,
              l = Gd({
                h:
                  ((t = e[1]),
                    (a = e[2]),
                    a === void 0 && (a = "deg"),
                    Number(t) * (E1[a] || 1)),
                s: Number(e[3]),
                l: Number(e[4]),
                a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1),
              });
            return Ud(l);
          },
          "hsl",
        ],
      ],
      object: [
        [
          function (r) {
            var e = r.r,
              t = r.g,
              a = r.b,
              l = r.a,
              o = l === void 0 ? 1 : l;
            return Wi(e) && Wi(t) && Wi(a)
              ? Id({ r: Number(e), g: Number(t), b: Number(a), a: Number(o) })
              : null;
          },
          "rgb",
        ],
        [
          function (r) {
            var e = r.h,
              t = r.s,
              a = r.l,
              l = r.a,
              o = l === void 0 ? 1 : l;
            if (!Wi(e) || !Wi(t) || !Wi(a)) return null;
            var h = Gd({
              h: Number(e),
              s: Number(t),
              l: Number(a),
              a: Number(o),
            });
            return Ud(h);
          },
          "hsl",
        ],
        [
          function (r) {
            var e = r.h,
              t = r.s,
              a = r.v,
              l = r.a,
              o = l === void 0 ? 1 : l;
            if (!Wi(e) || !Wi(t) || !Wi(a)) return null;
            var h = (function (c) {
              return {
                h: Rd(c.h),
                s: Qs(c.s, 0, 100),
                v: Qs(c.v, 0, 100),
                a: Qs(c.a),
              };
            })({ h: Number(e), s: Number(t), v: Number(a), a: Number(o) });
            return Fd(h);
          },
          "hsv",
        ],
      ],
    },
    Od = function (r, e) {
      for (var t = 0; t < e.length; t++) {
        var a = e[t][0](r);
        if (a) return [a, e[t][1]];
      }
      return [null, void 0];
    },
    G1 = function (r) {
      return typeof r == "string"
        ? Od(r.trim(), Il.string)
        : typeof r == "object" && r !== null
          ? Od(r, Il.object)
          : [null, void 0];
    },
    Bl = function (r, e) {
      var t = kn(r);
      return { h: t.h, s: Qs(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
    },
    Fl = function (r) {
      return (299 * r.r + 587 * r.g + 114 * r.b) / 1e3 / 255;
    },
    Ld = function (r, e) {
      var t = kn(r);
      return { h: t.h, s: t.s, l: Qs(t.l + 100 * e, 0, 100), a: t.a };
    },
    Gl = (function () {
      function r(e) {
        (this.parsed = G1(e)[0]),
          (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 });
      }
      return (
        (r.prototype.isValid = function () {
          return this.parsed !== null;
        }),
        (r.prototype.brightness = function () {
          return $t(Fl(this.rgba), 2);
        }),
        (r.prototype.isDark = function () {
          return Fl(this.rgba) < 0.5;
        }),
        (r.prototype.isLight = function () {
          return Fl(this.rgba) >= 0.5;
        }),
        (r.prototype.toHex = function () {
          return (
            (e = Rl(this.rgba)),
            (t = e.r),
            (a = e.g),
            (l = e.b),
            (h = (o = e.a) < 1 ? ja($t(255 * o)) : ""),
            "#" + ja(t) + ja(a) + ja(l) + h
          );
          var e, t, a, l, o, h;
        }),
        (r.prototype.toRgb = function () {
          return Rl(this.rgba);
        }),
        (r.prototype.toRgbString = function () {
          return (
            (e = Rl(this.rgba)),
            (t = e.r),
            (a = e.g),
            (l = e.b),
            (o = e.a) < 1
              ? "rgba(" + t + ", " + a + ", " + l + ", " + o + ")"
              : "rgb(" + t + ", " + a + ", " + l + ")"
          );
          var e, t, a, l, o;
        }),
        (r.prototype.toHsl = function () {
          return Dd(kn(this.rgba));
        }),
        (r.prototype.toHslString = function () {
          return (
            (e = Dd(kn(this.rgba))),
            (t = e.h),
            (a = e.s),
            (l = e.l),
            (o = e.a) < 1
              ? "hsla(" + t + ", " + a + "%, " + l + "%, " + o + ")"
              : "hsl(" + t + ", " + a + "%, " + l + "%)"
          );
          var e, t, a, l, o;
        }),
        (r.prototype.toHsv = function () {
          return (
            (e = Bd(this.rgba)),
            { h: $t(e.h), s: $t(e.s), v: $t(e.v), a: $t(e.a, 3) }
          );
          var e;
        }),
        (r.prototype.invert = function () {
          return Ei({
            r: 255 - (e = this.rgba).r,
            g: 255 - e.g,
            b: 255 - e.b,
            a: e.a,
          });
          var e;
        }),
        (r.prototype.saturate = function (e) {
          return e === void 0 && (e = 0.1), Ei(Bl(this.rgba, e));
        }),
        (r.prototype.desaturate = function (e) {
          return e === void 0 && (e = 0.1), Ei(Bl(this.rgba, -e));
        }),
        (r.prototype.grayscale = function () {
          return Ei(Bl(this.rgba, -1));
        }),
        (r.prototype.lighten = function (e) {
          return e === void 0 && (e = 0.1), Ei(Ld(this.rgba, e));
        }),
        (r.prototype.darken = function (e) {
          return e === void 0 && (e = 0.1), Ei(Ld(this.rgba, -e));
        }),
        (r.prototype.rotate = function (e) {
          return e === void 0 && (e = 15), this.hue(this.hue() + e);
        }),
        (r.prototype.alpha = function (e) {
          return typeof e == "number"
            ? Ei({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e })
            : $t(this.rgba.a, 3);
          var t;
        }),
        (r.prototype.hue = function (e) {
          var t = kn(this.rgba);
          return typeof e == "number"
            ? Ei({ h: e, s: t.s, l: t.l, a: t.a })
            : $t(t.h);
        }),
        (r.prototype.isEqual = function (e) {
          return this.toHex() === Ei(e).toHex();
        }),
        r
      );
    })(),
    Ei = function (r) {
      return r instanceof Gl ? r : new Gl(r);
    },
    Nd = [],
    D1 = function (r) {
      r.forEach(function (e) {
        Nd.indexOf(e) < 0 && (e(Gl, Il), Nd.push(e));
      });
    };
  function U1(r, e) {
    var t = {
      white: "#fff",
      bisque: "#ffe4c4",
      blue: "#0000ff",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      azure: "#f0ffff",
      whitesmoke: "#f5f5f5",
      papayawhip: "#ffefd5",
      plum: "#dda0dd",
      blanchedalmond: "#ffebcd",
      black: "#000000",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gainsboro: "#dcdcdc",
      cornsilk: "#fff8dc",
      cornflowerblue: "#6495ed",
      burlywood: "#deb887",
      aquamarine: "#7fffd4",
      beige: "#f5f5dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkkhaki: "#bdb76b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      peachpuff: "#ffdab9",
      darkmagenta: "#8b008b",
      darkred: "#8b0000",
      darkorchid: "#9932cc",
      darkorange: "#ff8c00",
      darkslateblue: "#483d8b",
      gray: "#808080",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      wheat: "#f5deb3",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      ghostwhite: "#f8f8ff",
      darkviolet: "#9400d3",
      magenta: "#ff00ff",
      green: "#008000",
      dodgerblue: "#1e90ff",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      blueviolet: "#8a2be2",
      forestgreen: "#228b22",
      lawngreen: "#7cfc00",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      fuchsia: "#ff00ff",
      brown: "#a52a2a",
      maroon: "#800000",
      mediumblue: "#0000cd",
      lightcoral: "#f08080",
      darkturquoise: "#00ced1",
      lightcyan: "#e0ffff",
      ivory: "#fffff0",
      lightyellow: "#ffffe0",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      linen: "#faf0e6",
      mediumaquamarine: "#66cdaa",
      lemonchiffon: "#fffacd",
      lime: "#00ff00",
      khaki: "#f0e68c",
      mediumseagreen: "#3cb371",
      limegreen: "#32cd32",
      mediumspringgreen: "#00fa9a",
      lightskyblue: "#87cefa",
      lightblue: "#add8e6",
      midnightblue: "#191970",
      lightpink: "#ffb6c1",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      mintcream: "#f5fffa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      navajowhite: "#ffdead",
      navy: "#000080",
      mediumvioletred: "#c71585",
      powderblue: "#b0e0e6",
      palegoldenrod: "#eee8aa",
      oldlace: "#fdf5e6",
      paleturquoise: "#afeeee",
      mediumturquoise: "#48d1cc",
      mediumorchid: "#ba55d3",
      rebeccapurple: "#663399",
      lightsteelblue: "#b0c4de",
      mediumslateblue: "#7b68ee",
      thistle: "#d8bfd8",
      tan: "#d2b48c",
      orchid: "#da70d6",
      mediumpurple: "#9370db",
      purple: "#800080",
      pink: "#ffc0cb",
      skyblue: "#87ceeb",
      springgreen: "#00ff7f",
      palegreen: "#98fb98",
      red: "#ff0000",
      yellow: "#ffff00",
      slateblue: "#6a5acd",
      lavenderblush: "#fff0f5",
      peru: "#cd853f",
      palevioletred: "#db7093",
      violet: "#ee82ee",
      teal: "#008080",
      slategray: "#708090",
      slategrey: "#708090",
      aliceblue: "#f0f8ff",
      darkseagreen: "#8fbc8f",
      darkolivegreen: "#556b2f",
      greenyellow: "#adff2f",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      tomato: "#ff6347",
      silver: "#c0c0c0",
      sienna: "#a0522d",
      lavender: "#e6e6fa",
      lightgreen: "#90ee90",
      orange: "#ffa500",
      orangered: "#ff4500",
      steelblue: "#4682b4",
      royalblue: "#4169e1",
      turquoise: "#40e0d0",
      yellowgreen: "#9acd32",
      salmon: "#fa8072",
      saddlebrown: "#8b4513",
      sandybrown: "#f4a460",
      rosybrown: "#bc8f8f",
      darksalmon: "#e9967a",
      lightgoldenrodyellow: "#fafad2",
      snow: "#fffafa",
      lightgrey: "#d3d3d3",
      lightgray: "#d3d3d3",
      dimgray: "#696969",
      dimgrey: "#696969",
      olivedrab: "#6b8e23",
      olive: "#808000",
    },
      a = {};
    for (var l in t) a[t[l]] = l;
    var o = {};
    (r.prototype.toName = function (h) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
        return "transparent";
      var c,
        u,
        d = a[this.toHex()];
      if (d) return d;
      if (h?.closest) {
        var f = this.toRgb(),
          p = 1 / 0,
          g = "black";
        if (!o.length) for (var _ in t) o[_] = new r(t[_]).toRgb();
        for (var m in t) {
          var w =
            ((c = f),
              (u = o[m]),
              Math.pow(c.r - u.r, 2) +
              Math.pow(c.g - u.g, 2) +
              Math.pow(c.b - u.b, 2));
          w < p && ((p = w), (g = m));
        }
        return g;
      }
    }),
      e.string.push([
        function (h) {
          var c = h.toLowerCase(),
            u = c === "transparent" ? "#0000" : t[c];
          return u ? new r(u).toRgb() : null;
        },
        "name",
      ]);
  }
  D1([U1]);
  const Kr = class Oa {
    constructor(e = 16777215) {
      (this._value = null),
        (this._components = new Float32Array(4)),
        this._components.fill(1),
        (this._int = 16777215),
        (this.value = e);
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(e) {
      return (this.value = e), this;
    }
    set value(e) {
      if (e instanceof Oa)
        (this._value = this._cloneSource(e._value)),
          (this._int = e._int),
          this._components.set(e._components);
      else {
        if (e === null) throw new Error("Cannot set Color#value to null");
        (this._value === null || !this._isSourceEqual(this._value, e)) &&
          ((this._value = this._cloneSource(e)), this._normalize(this._value));
      }
    }
    get value() {
      return this._value;
    }
    _cloneSource(e) {
      return typeof e == "string" ||
        typeof e == "number" ||
        e instanceof Number ||
        e === null
        ? e
        : Array.isArray(e) || ArrayBuffer.isView(e)
          ? e.slice(0)
          : typeof e == "object" && e !== null
            ? { ...e }
            : e;
    }
    _isSourceEqual(e, t) {
      const a = typeof e;
      if (a !== typeof t) return !1;
      if (a === "number" || a === "string" || e instanceof Number)
        return e === t;
      if (
        (Array.isArray(e) && Array.isArray(t)) ||
        (ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
      )
        return e.length !== t.length ? !1 : e.every((o, h) => o === t[h]);
      if (e !== null && t !== null) {
        const o = Object.keys(e),
          h = Object.keys(t);
        return o.length !== h.length ? !1 : o.every((c) => e[c] === t[c]);
      }
      return e === t;
    }
    toRgba() {
      const [e, t, a, l] = this._components;
      return { r: e, g: t, b: a, a: l };
    }
    toRgb() {
      const [e, t, a] = this._components;
      return { r: e, g: t, b: a };
    }
    toRgbaString() {
      const [e, t, a] = this.toUint8RgbArray();
      return `rgba(${e},${t},${a},${this.alpha})`;
    }
    toUint8RgbArray(e) {
      const [t, a, l] = this._components;
      return (
        this._arrayRgb || (this._arrayRgb = []),
        e || (e = this._arrayRgb),
        (e[0] = Math.round(t * 255)),
        (e[1] = Math.round(a * 255)),
        (e[2] = Math.round(l * 255)),
        e
      );
    }
    toArray(e) {
      this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
      const [t, a, l, o] = this._components;
      return (e[0] = t), (e[1] = a), (e[2] = l), (e[3] = o), e;
    }
    toRgbArray(e) {
      this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
      const [t, a, l] = this._components;
      return (e[0] = t), (e[1] = a), (e[2] = l), e;
    }
    toNumber() {
      return this._int;
    }
    toBgrNumber() {
      const [e, t, a] = this.toUint8RgbArray();
      return (a << 16) + (t << 8) + e;
    }
    toLittleEndianNumber() {
      const e = this._int;
      return (e >> 16) + (e & 65280) + ((e & 255) << 16);
    }
    multiply(e) {
      const [t, a, l, o] = Oa._temp.setValue(e)._components;
      return (
        (this._components[0] *= t),
        (this._components[1] *= a),
        (this._components[2] *= l),
        (this._components[3] *= o),
        this._refreshInt(),
        (this._value = null),
        this
      );
    }
    premultiply(e, t = !0) {
      return (
        t &&
        ((this._components[0] *= e),
          (this._components[1] *= e),
          (this._components[2] *= e)),
        (this._components[3] = e),
        this._refreshInt(),
        (this._value = null),
        this
      );
    }
    toPremultiplied(e, t = !0) {
      if (e === 1) return (255 << 24) + this._int;
      if (e === 0) return t ? 0 : this._int;
      let a = (this._int >> 16) & 255,
        l = (this._int >> 8) & 255,
        o = this._int & 255;
      return (
        t &&
        ((a = (a * e + 0.5) | 0),
          (l = (l * e + 0.5) | 0),
          (o = (o * e + 0.5) | 0)),
        ((e * 255) << 24) + (a << 16) + (l << 8) + o
      );
    }
    toHex() {
      const e = this._int.toString(16);
      return `#${"000000".substring(0, 6 - e.length) + e}`;
    }
    toHexa() {
      const t = Math.round(this._components[3] * 255).toString(16);
      return this.toHex() + "00".substring(0, 2 - t.length) + t;
    }
    setAlpha(e) {
      return (this._components[3] = this._clamp(e)), this;
    }
    _normalize(e) {
      let t, a, l, o;
      if (
        (typeof e == "number" || e instanceof Number) &&
        e >= 0 &&
        e <= 16777215
      ) {
        const h = e;
        (t = ((h >> 16) & 255) / 255),
          (a = ((h >> 8) & 255) / 255),
          (l = (h & 255) / 255),
          (o = 1);
      } else if (
        (Array.isArray(e) || e instanceof Float32Array) &&
        e.length >= 3 &&
        e.length <= 4
      )
        (e = this._clamp(e)), ([t, a, l, o = 1] = e);
      else if (
        (e instanceof Uint8Array || e instanceof Uint8ClampedArray) &&
        e.length >= 3 &&
        e.length <= 4
      )
        (e = this._clamp(e, 0, 255)),
          ([t, a, l, o = 255] = e),
          (t /= 255),
          (a /= 255),
          (l /= 255),
          (o /= 255);
      else if (typeof e == "string" || typeof e == "object") {
        if (typeof e == "string") {
          const c = Oa.HEX_PATTERN.exec(e);
          c && (e = `#${c[2]}`);
        }
        const h = Ei(e);
        h.isValid() &&
          (({ r: t, g: a, b: l, a: o } = h.rgba),
            (t /= 255),
            (a /= 255),
            (l /= 255));
      }
      if (t !== void 0)
        (this._components[0] = t),
          (this._components[1] = a),
          (this._components[2] = l),
          (this._components[3] = o),
          this._refreshInt();
      else throw new Error(`Unable to convert color ${e}`);
    }
    _refreshInt() {
      this._clamp(this._components);
      const [e, t, a] = this._components;
      this._int = ((e * 255) << 16) + ((t * 255) << 8) + ((a * 255) | 0);
    }
    _clamp(e, t = 0, a = 1) {
      return typeof e == "number"
        ? Math.min(Math.max(e, t), a)
        : (e.forEach((l, o) => {
          e[o] = Math.min(Math.max(l, t), a);
        }),
          e);
    }
    static isColorLike(e) {
      return (
        typeof e == "number" ||
        typeof e == "string" ||
        e instanceof Number ||
        e instanceof Oa ||
        Array.isArray(e) ||
        e instanceof Uint8Array ||
        e instanceof Uint8ClampedArray ||
        e instanceof Float32Array ||
        (e.r !== void 0 && e.g !== void 0 && e.b !== void 0) ||
        (e.r !== void 0 &&
          e.g !== void 0 &&
          e.b !== void 0 &&
          e.a !== void 0) ||
        (e.h !== void 0 && e.s !== void 0 && e.l !== void 0) ||
        (e.h !== void 0 &&
          e.s !== void 0 &&
          e.l !== void 0 &&
          e.a !== void 0) ||
        (e.h !== void 0 && e.s !== void 0 && e.v !== void 0) ||
        (e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0)
      );
    }
  };
  (Kr.shared = new Kr()),
    (Kr._temp = new Kr()),
    (Kr.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i);
  let mt = Kr;
  const O1 = { cullArea: null, cullable: !1, cullableChildren: !0 };
  let Dl = 0;
  const Hd = 500;
  function pe(...r) {}
  const Zr = {
    _registeredResources: new Set(),
    register(r) {
      this._registeredResources.add(r);
    },
    unregister(r) {
      this._registeredResources.delete(r);
    },
    release() {
      this._registeredResources.forEach((r) => r.clear());
    },
    get registeredCount() {
      return this._registeredResources.size;
    },
    isRegistered(r) {
      return this._registeredResources.has(r);
    },
    reset() {
      this._registeredResources.clear();
    },
  };
  class L1 {
    constructor(e, t) {
      (this._pool = []),
        (this._count = 0),
        (this._index = 0),
        (this._classType = e),
        t && this.prepopulate(t);
    }
    prepopulate(e) {
      for (let t = 0; t < e; t++)
        this._pool[this._index++] = new this._classType();
      this._count += e;
    }
    get(e) {
      let t;
      return (
        this._index > 0
          ? (t = this._pool[--this._index])
          : (t = new this._classType()),
        t.init?.(e),
        t
      );
    }
    return(e) {
      e.reset?.(), (this._pool[this._index++] = e);
    }
    get totalSize() {
      return this._count;
    }
    get totalFree() {
      return this._index;
    }
    get totalUsed() {
      return this._count - this._index;
    }
    clear() {
      if (this._pool.length > 0 && this._pool[0].destroy)
        for (let e = 0; e < this._index; e++) this._pool[e].destroy();
      (this._pool.length = 0), (this._count = 0), (this._index = 0);
    }
  }
  class N1 {
    constructor() {
      this._poolsByClass = new Map();
    }
    prepopulate(e, t) {
      this.getPool(e).prepopulate(t);
    }
    get(e, t) {
      return this.getPool(e).get(t);
    }
    return(e) {
      this.getPool(e.constructor).return(e);
    }
    getPool(e) {
      return (
        this._poolsByClass.has(e) || this._poolsByClass.set(e, new L1(e)),
        this._poolsByClass.get(e)
      );
    }
    stats() {
      const e = {};
      return (
        this._poolsByClass.forEach((t) => {
          const a = e[t._classType.name]
            ? t._classType.name + t._classType.ID
            : t._classType.name;
          e[a] = { free: t.totalFree, used: t.totalUsed, size: t.totalSize };
        }),
        e
      );
    }
    clear() {
      this._poolsByClass.forEach((e) => e.clear()), this._poolsByClass.clear();
    }
  }
  const Ot = new N1();
  Zr.register(Ot);
  const H1 = {
    get isCachedAsTexture() {
      return !!this.renderGroup?.isCachedAsTexture;
    },
    cacheAsTexture(r) {
      typeof r == "boolean" && r === !1
        ? this.disableRenderGroup()
        : (this.enableRenderGroup(),
          this.renderGroup.enableCacheAsTexture(r === !0 ? {} : r));
    },
    updateCacheTexture() {
      this.renderGroup?.updateCacheTexture();
    },
    get cacheAsBitmap() {
      return this.isCachedAsTexture;
    },
    set cacheAsBitmap(r) {
      me("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."),
        this.cacheAsTexture(r);
    },
  };
  function zd(r, e, t) {
    const a = r.length;
    let l;
    if (e >= a || t === 0) return;
    t = e + t > a ? a - e : t;
    const o = a - t;
    for (l = e; l < o; ++l) r[l] = r[l + t];
    r.length = o;
  }
  const z1 = {
    allowChildren: !0,
    removeChildren(r = 0, e) {
      const t = e ?? this.children.length,
        a = t - r,
        l = [];
      if (a > 0 && a <= t) {
        for (let h = t - 1; h >= r; h--) {
          const c = this.children[h];
          c && (l.push(c), (c.parent = null));
        }
        zd(this.children, r, t);
        const o = this.renderGroup || this.parentRenderGroup;
        o && o.removeChildren(l);
        for (let h = 0; h < l.length; ++h) {
          const c = l[h];
          c.parentRenderLayer?.detach(c),
            this.emit("childRemoved", c, this, h),
            l[h].emit("removed", this);
        }
        return l.length > 0 && this._didViewChangeTick++, l;
      } else if (a === 0 && this.children.length === 0) return l;
      throw new RangeError(
        "removeChildren: numeric values are outside the acceptable range."
      );
    },
    removeChildAt(r) {
      const e = this.getChildAt(r);
      return this.removeChild(e);
    },
    getChildAt(r) {
      if (r < 0 || r >= this.children.length)
        throw new Error(`getChildAt: Index (${r}) does not exist.`);
      return this.children[r];
    },
    setChildIndex(r, e) {
      if (e < 0 || e >= this.children.length)
        throw new Error(
          `The index ${e} supplied is out of bounds ${this.children.length}`
        );
      this.getChildIndex(r), this.addChildAt(r, e);
    },
    getChildIndex(r) {
      const e = this.children.indexOf(r);
      if (e === -1)
        throw new Error(
          "The supplied Container must be a child of the caller"
        );
      return e;
    },
    addChildAt(r, e) {
      this.allowChildren ||
        me(
          Ie,
          "addChildAt: Only Containers will be allowed to add children in v8.0.0"
        );
      const { children: t } = this;
      if (e < 0 || e > t.length)
        throw new Error(
          `${r}addChildAt: The index ${e} supplied is out of bounds ${t.length}`
        );
      if (r.parent) {
        const l = r.parent.children.indexOf(r);
        if (r.parent === this && l === e) return r;
        l !== -1 && r.parent.children.splice(l, 1);
      }
      e === t.length ? t.push(r) : t.splice(e, 0, r),
        (r.parent = this),
        (r.didChange = !0),
        (r._updateFlags = 15);
      const a = this.renderGroup || this.parentRenderGroup;
      return (
        a && a.addChild(r),
        this.sortableChildren && (this.sortDirty = !0),
        this.emit("childAdded", r, this, e),
        r.emit("added", this),
        r
      );
    },
    swapChildren(r, e) {
      if (r === e) return;
      const t = this.getChildIndex(r),
        a = this.getChildIndex(e);
      (this.children[t] = e), (this.children[a] = r);
      const l = this.renderGroup || this.parentRenderGroup;
      l && (l.structureDidChange = !0), this._didContainerChangeTick++;
    },
    removeFromParent() {
      this.parent?.removeChild(this);
    },
    reparentChild(...r) {
      return r.length === 1
        ? this.reparentChildAt(r[0], this.children.length)
        : (r.forEach((e) => this.reparentChildAt(e, this.children.length)),
          r[0]);
    },
    reparentChildAt(r, e) {
      if (r.parent === this) return this.setChildIndex(r, e), r;
      const t = r.worldTransform.clone();
      r.removeFromParent(), this.addChildAt(r, e);
      const a = this.worldTransform.clone();
      return a.invert(), t.prepend(a), r.setFromMatrix(t), r;
    },
    replaceChild(r, e) {
      r.updateLocalTransform(),
        this.addChildAt(e, this.getChildIndex(r)),
        e.setFromMatrix(r.localTransform),
        e.updateLocalTransform(),
        this.removeChild(r);
    },
  },
    W1 = {
      collectRenderables(r, e, t) {
        (this.parentRenderLayer && this.parentRenderLayer !== t) ||
          this.globalDisplayStatus < 7 ||
          !this.includeInBuild ||
          (this.sortableChildren && this.sortChildren(),
            this.isSimple
              ? this.collectRenderablesSimple(r, e, t)
              : this.renderGroup
                ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, r)
                : this.collectRenderablesWithEffects(r, e, t));
      },
      collectRenderablesSimple(r, e, t) {
        const a = this.children,
          l = a.length;
        for (let o = 0; o < l; o++) a[o].collectRenderables(r, e, t);
      },
      collectRenderablesWithEffects(r, e, t) {
        const { renderPipes: a } = e;
        for (let l = 0; l < this.effects.length; l++) {
          const o = this.effects[l];
          a[o.pipe].push(o, this, r);
        }
        this.collectRenderablesSimple(r, e, t);
        for (let l = this.effects.length - 1; l >= 0; l--) {
          const o = this.effects[l];
          a[o.pipe].pop(o, this, r);
        }
      },
    };
  class Xa {
    constructor() {
      (this.pipe = "filter"), (this.priority = 1);
    }
    destroy() {
      for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
      (this.filters = null), (this.filterArea = null);
    }
  }
  class V1 {
    constructor() {
      (this._effectClasses = []), (this._tests = []), (this._initialized = !1);
    }
    init() {
      this._initialized ||
        ((this._initialized = !0),
          this._effectClasses.forEach((e) => {
            this.add({ test: e.test, maskClass: e });
          }));
    }
    add(e) {
      this._tests.push(e);
    }
    getMaskEffect(e) {
      this._initialized || this.init();
      for (let t = 0; t < this._tests.length; t++) {
        const a = this._tests[t];
        if (a.test(e)) return Ot.get(a.maskClass, e);
      }
      return e;
    }
    returnMaskEffect(e) {
      Ot.return(e);
    }
  }
  const Ul = new V1();
  ge.handleByList(P.MaskEffect, Ul._effectClasses);
  const j1 = {
    _maskEffect: null,
    _maskOptions: { inverse: !1 },
    _filterEffect: null,
    effects: [],
    _markStructureAsChanged() {
      const r = this.renderGroup || this.parentRenderGroup;
      r && (r.structureDidChange = !0);
    },
    addEffect(r) {
      this.effects.indexOf(r) === -1 &&
        (this.effects.push(r),
          this.effects.sort((t, a) => t.priority - a.priority),
          this._markStructureAsChanged(),
          this._updateIsSimple());
    },
    removeEffect(r) {
      const e = this.effects.indexOf(r);
      e !== -1 &&
        (this.effects.splice(e, 1),
          this._markStructureAsChanged(),
          this._updateIsSimple());
    },
    set mask(r) {
      const e = this._maskEffect;
      e?.mask !== r &&
        (e &&
          (this.removeEffect(e),
            Ul.returnMaskEffect(e),
            (this._maskEffect = null)),
          r != null &&
          ((this._maskEffect = Ul.getMaskEffect(r)),
            this.addEffect(this._maskEffect)));
    },
    get mask() {
      return this._maskEffect?.mask;
    },
    setMask(r) {
      (this._maskOptions = { ...this._maskOptions, ...r }),
        r.mask && (this.mask = r.mask),
        this._markStructureAsChanged();
    },
    set filters(r) {
      !Array.isArray(r) && r && (r = [r]);
      const e = this._filterEffect || (this._filterEffect = new Xa());
      r = r;
      const t = r?.length > 0,
        a = e.filters?.length > 0,
        l = t !== a;
      (r = Array.isArray(r) ? r.slice(0) : r),
        (e.filters = Object.freeze(r)),
        l &&
        (t
          ? this.addEffect(e)
          : (this.removeEffect(e), (e.filters = r ?? null)));
    },
    get filters() {
      return this._filterEffect?.filters;
    },
    set filterArea(r) {
      this._filterEffect || (this._filterEffect = new Xa()),
        (this._filterEffect.filterArea = r);
    },
    get filterArea() {
      return this._filterEffect?.filterArea;
    },
  },
    X1 = {
      label: null,
      get name() {
        return (
          me(
            Ie,
            "Container.name property has been removed, use Container.label instead"
          ),
          this.label
        );
      },
      set name(r) {
        me(
          Ie,
          "Container.name property has been removed, use Container.label instead"
        ),
          (this.label = r);
      },
      getChildByName(r, e = !1) {
        return this.getChildByLabel(r, e);
      },
      getChildByLabel(r, e = !1) {
        const t = this.children;
        for (let a = 0; a < t.length; a++) {
          const l = t[a];
          if (l.label === r || (r instanceof RegExp && r.test(l.label)))
            return l;
        }
        if (e)
          for (let a = 0; a < t.length; a++) {
            const o = t[a].getChildByLabel(r, !0);
            if (o) return o;
          }
        return null;
      },
      getChildrenByLabel(r, e = !1, t = []) {
        const a = this.children;
        for (let l = 0; l < a.length; l++) {
          const o = a[l];
          (o.label === r || (r instanceof RegExp && r.test(o.label))) &&
            t.push(o);
        }
        if (e)
          for (let l = 0; l < a.length; l++) a[l].getChildrenByLabel(r, !0, t);
        return t;
      },
    },
    _s = Ot.getPool(ae),
    Vi = Ot.getPool(cs),
    q1 = new ae(),
    Y1 = {
      getFastGlobalBounds(r, e) {
        e || (e = new cs()),
          e.clear(),
          this._getGlobalBoundsRecursive(!!r, e, this.parentRenderLayer),
          e.isValid || e.set(0, 0, 0, 0);
        const t = this.renderGroup || this.parentRenderGroup;
        return e.applyMatrix(t.worldTransform), e;
      },
      _getGlobalBoundsRecursive(r, e, t) {
        let a = e;
        if (
          (r && this.parentRenderLayer && this.parentRenderLayer !== t) ||
          this.localDisplayStatus !== 7 ||
          !this.measurable
        )
          return;
        const l = !!this.effects.length;
        if (
          ((this.renderGroup || l) && (a = Vi.get().clear()), this.boundsArea)
        )
          e.addRect(this.boundsArea, this.worldTransform);
        else {
          if (this.renderPipeId) {
            const h = this.bounds;
            a.addFrame(h.minX, h.minY, h.maxX, h.maxY, this.groupTransform);
          }
          const o = this.children;
          for (let h = 0; h < o.length; h++)
            o[h]._getGlobalBoundsRecursive(r, a, t);
        }
        if (l) {
          let o = !1;
          const h = this.renderGroup || this.parentRenderGroup;
          for (let c = 0; c < this.effects.length; c++)
            this.effects[c].addBounds &&
              (o || ((o = !0), a.applyMatrix(h.worldTransform)),
                this.effects[c].addBounds(a, !0));
          o && a.applyMatrix(h.worldTransform.copyTo(q1).invert()),
            e.addBounds(a),
            Vi.return(a);
        } else
          this.renderGroup &&
            (e.addBounds(a, this.relativeGroupTransform), Vi.return(a));
      },
    };
  function Ol(r, e, t) {
    t.clear();
    let a, l;
    return (
      r.parent
        ? e
          ? (a = r.parent.worldTransform)
          : ((l = _s.get().identity()), (a = Ll(r, l)))
        : (a = ae.IDENTITY),
      Wd(r, t, a, e),
      l && _s.return(l),
      t.isValid || t.set(0, 0, 0, 0),
      t
    );
  }
  function Wd(r, e, t, a) {
    if (!r.visible || !r.measurable) return;
    let l;
    a
      ? (l = r.worldTransform)
      : (r.updateLocalTransform(),
        (l = _s.get()),
        l.appendFrom(r.localTransform, t));
    const o = e,
      h = !!r.effects.length;
    if ((h && (e = Vi.get().clear()), r.boundsArea)) e.addRect(r.boundsArea, l);
    else {
      const c = r.bounds;
      c && !c.isEmpty() && ((e.matrix = l), e.addBounds(c));
      for (let u = 0; u < r.children.length; u++) Wd(r.children[u], e, l, a);
    }
    if (h) {
      for (let c = 0; c < r.effects.length; c++) r.effects[c].addBounds?.(e);
      o.addBounds(e, ae.IDENTITY), Vi.return(e);
    }
    a || _s.return(l);
  }
  function Ll(r, e) {
    const t = r.parent;
    return (
      t && (Ll(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e
    );
  }
  function Vd(r, e) {
    if (r === 16777215 || !e) return e;
    if (e === 16777215 || !r) return r;
    const t = (r >> 16) & 255,
      a = (r >> 8) & 255,
      l = r & 255,
      o = (e >> 16) & 255,
      h = (e >> 8) & 255,
      c = e & 255,
      u = ((t * o) / 255) | 0,
      d = ((a * h) / 255) | 0,
      f = ((l * c) / 255) | 0;
    return (u << 16) + (d << 8) + f;
  }
  const jd = 16777215;
  function qa(r, e) {
    return r === jd ? e : e === jd ? r : Vd(r, e);
  }
  function Ya(r) {
    return ((r & 255) << 16) + (r & 65280) + ((r >> 16) & 255);
  }
  const $1 = {
    getGlobalAlpha(r) {
      if (r)
        return this.renderGroup
          ? this.renderGroup.worldAlpha
          : this.parentRenderGroup
            ? this.parentRenderGroup.worldAlpha * this.alpha
            : this.alpha;
      let e = this.alpha,
        t = this.parent;
      for (; t;) (e *= t.alpha), (t = t.parent);
      return e;
    },
    getGlobalTransform(r = new ae(), e) {
      if (e) return r.copyFrom(this.worldTransform);
      this.updateLocalTransform();
      const t = Ll(this, _s.get().identity());
      return r.appendFrom(this.localTransform, t), _s.return(t), r;
    },
    getGlobalTint(r) {
      if (r)
        return this.renderGroup
          ? Ya(this.renderGroup.worldColor)
          : this.parentRenderGroup
            ? Ya(qa(this.localColor, this.parentRenderGroup.worldColor))
            : this.tint;
      let e = this.localColor,
        t = this.parent;
      for (; t;) (e = qa(e, t.localColor)), (t = t.parent);
      return Ya(e);
    },
  };
  function Nl(r, e, t) {
    return (
      e.clear(),
      t || (t = ae.IDENTITY),
      Xd(r, e, t, r, !0),
      e.isValid || e.set(0, 0, 0, 0),
      e
    );
  }
  function Xd(r, e, t, a, l) {
    let o;
    if (l) (o = _s.get()), (o = t.copyTo(o));
    else {
      if (!r.visible || !r.measurable) return;
      r.updateLocalTransform();
      const u = r.localTransform;
      (o = _s.get()), o.appendFrom(u, t);
    }
    const h = e,
      c = !!r.effects.length;
    if ((c && (e = Vi.get().clear()), r.boundsArea)) e.addRect(r.boundsArea, o);
    else {
      r.renderPipeId && ((e.matrix = o), e.addBounds(r.bounds));
      const u = r.children;
      for (let d = 0; d < u.length; d++) Xd(u[d], e, o, a, !1);
    }
    if (c) {
      for (let u = 0; u < r.effects.length; u++)
        r.effects[u].addLocalBounds?.(e, a);
      h.addBounds(e, ae.IDENTITY), Vi.return(e);
    }
    _s.return(o);
  }
  function qd(r, e) {
    const t = r.children;
    for (let a = 0; a < t.length; a++) {
      const l = t[a],
        o = l.uid,
        h =
          ((l._didViewChangeTick & 65535) << 16) |
          (l._didContainerChangeTick & 65535),
        c = e.index;
      (e.data[c] !== o || e.data[c + 1] !== h) &&
        ((e.data[e.index] = o), (e.data[e.index + 1] = h), (e.didChange = !0)),
        (e.index = c + 2),
        l.children.length && qd(l, e);
    }
    return e.didChange;
  }
  const K1 = new ae(),
    Z1 = {
      _localBoundsCacheId: -1,
      _localBoundsCacheData: null,
      _setWidth(r, e) {
        const t = Math.sign(this.scale.x) || 1;
        e !== 0 ? (this.scale.x = (r / e) * t) : (this.scale.x = t);
      },
      _setHeight(r, e) {
        const t = Math.sign(this.scale.y) || 1;
        e !== 0 ? (this.scale.y = (r / e) * t) : (this.scale.y = t);
      },
      getLocalBounds() {
        this._localBoundsCacheData ||
          (this._localBoundsCacheData = {
            data: [],
            index: 1,
            didChange: !1,
            localBounds: new cs(),
          });
        const r = this._localBoundsCacheData;
        return (
          (r.index = 1),
          (r.didChange = !1),
          r.data[0] !== this._didViewChangeTick &&
          ((r.didChange = !0), (r.data[0] = this._didViewChangeTick)),
          qd(this, r),
          r.didChange && Nl(this, r.localBounds, K1),
          r.localBounds
        );
      },
      getBounds(r, e) {
        return Ol(this, r, e || new cs());
      },
    },
    Q1 = {
      _onRender: null,
      set onRender(r) {
        const e = this.renderGroup || this.parentRenderGroup;
        if (!r) {
          this._onRender && e?.removeOnRender(this), (this._onRender = null);
          return;
        }
        this._onRender || e?.addOnRender(this), (this._onRender = r);
      },
      get onRender() {
        return this._onRender;
      },
    },
    J1 = {
      _zIndex: 0,
      sortDirty: !1,
      sortableChildren: !1,
      get zIndex() {
        return this._zIndex;
      },
      set zIndex(r) {
        this._zIndex !== r && ((this._zIndex = r), this.depthOfChildModified());
      },
      depthOfChildModified() {
        this.parent &&
          ((this.parent.sortableChildren = !0), (this.parent.sortDirty = !0)),
          this.parentRenderGroup &&
          (this.parentRenderGroup.structureDidChange = !0);
      },
      sortChildren() {
        this.sortDirty && ((this.sortDirty = !1), this.children.sort(e0));
      },
    };
  function e0(r, e) {
    return r._zIndex - e._zIndex;
  }
  const t0 = {
    getGlobalPosition(r = new Je(), e = !1) {
      return (
        this.parent
          ? this.parent.toGlobal(this._position, r, e)
          : ((r.x = this._position.x), (r.y = this._position.y)),
        r
      );
    },
    toGlobal(r, e, t = !1) {
      const a = this.getGlobalTransform(_s.get(), t);
      return (e = a.apply(r, e)), _s.return(a), e;
    },
    toLocal(r, e, t, a) {
      e && (r = e.toGlobal(r, t, a));
      const l = this.getGlobalTransform(_s.get(), a);
      return (t = l.applyInverse(r, t)), _s.return(l), t;
    },
  };
  class Yd {
    constructor() {
      (this.uid = et("instructionSet")),
        (this.instructions = []),
        (this.instructionSize = 0),
        (this.renderables = []),
        (this.gcTick = 0);
    }
    reset() {
      this.instructionSize = 0;
    }
    destroy() {
      (this.instructions.length = 0),
        (this.renderables.length = 0),
        (this.renderPipes = null),
        (this.gcTick = 0);
    }
    add(e) {
      this.instructions[this.instructionSize++] = e;
    }
    log() {
      this.instructions.length = this.instructionSize;
    }
  }
  let s0 = 0;
  class i0 {
    constructor(e) {
      (this._poolKeyHash = Object.create(null)),
        (this._texturePool = {}),
        (this.textureOptions = e || {}),
        (this.enableFullScreen = !1),
        (this.textureStyle = new Pi(this.textureOptions));
    }
    createTexture(e, t, a) {
      const l = new zt({
        ...this.textureOptions,
        width: e,
        height: t,
        resolution: 1,
        antialias: a,
        autoGarbageCollect: !1,
      });
      return new te({ source: l, label: `texturePool_${s0++}` });
    }
    getOptimalTexture(e, t, a = 1, l) {
      let o = Math.ceil(e * a - 1e-6),
        h = Math.ceil(t * a - 1e-6);
      (o = $r(o)), (h = $r(h));
      const c = (o << 17) + (h << 1) + (l ? 1 : 0);
      this._texturePool[c] || (this._texturePool[c] = []);
      let u = this._texturePool[c].pop();
      return (
        u || (u = this.createTexture(o, h, l)),
        (u.source._resolution = a),
        (u.source.width = o / a),
        (u.source.height = h / a),
        (u.source.pixelWidth = o),
        (u.source.pixelHeight = h),
        (u.frame.x = 0),
        (u.frame.y = 0),
        (u.frame.width = e),
        (u.frame.height = t),
        u.updateUvs(),
        (this._poolKeyHash[u.uid] = c),
        u
      );
    }
    getSameSizeTexture(e, t = !1) {
      const a = e.source;
      return this.getOptimalTexture(e.width, e.height, a._resolution, t);
    }
    returnTexture(e, t = !1) {
      const a = this._poolKeyHash[e.uid];
      t && (e.source.style = this.textureStyle), this._texturePool[a].push(e);
    }
    clear(e) {
      if (((e = e !== !1), e))
        for (const t in this._texturePool) {
          const a = this._texturePool[t];
          if (a) for (let l = 0; l < a.length; l++) a[l].destroy(!0);
        }
      this._texturePool = {};
    }
  }
  const ss = new i0();
  Zr.register(ss);
  class Hl {
    constructor() {
      (this.renderPipeId = "renderGroup"),
        (this.root = null),
        (this.canBundle = !1),
        (this.renderGroupParent = null),
        (this.renderGroupChildren = []),
        (this.worldTransform = new ae()),
        (this.worldColorAlpha = 4294967295),
        (this.worldColor = 16777215),
        (this.worldAlpha = 1),
        (this.childrenToUpdate = Object.create(null)),
        (this.updateTick = 0),
        (this.gcTick = 0),
        (this.childrenRenderablesToUpdate = { list: [], index: 0 }),
        (this.structureDidChange = !0),
        (this.instructionSet = new Yd()),
        (this._onRenderContainers = []),
        (this.textureNeedsUpdate = !0),
        (this.isCachedAsTexture = !1),
        (this._matrixDirty = 7);
    }
    init(e) {
      (this.root = e), e._onRender && this.addOnRender(e), (e.didChange = !0);
      const t = e.children;
      for (let a = 0; a < t.length; a++) {
        const l = t[a];
        (l._updateFlags = 15), this.addChild(l);
      }
    }
    enableCacheAsTexture(e = {}) {
      (this.textureOptions = e),
        (this.isCachedAsTexture = !0),
        (this.textureNeedsUpdate = !0);
    }
    disableCacheAsTexture() {
      (this.isCachedAsTexture = !1),
        this.texture &&
        (ss.returnTexture(this.texture, !0), (this.texture = null));
    }
    updateCacheTexture() {
      this.textureNeedsUpdate = !0;
      const e = this._parentCacheAsTextureRenderGroup;
      e && !e.textureNeedsUpdate && e.updateCacheTexture();
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const e in this.childrenToUpdate) {
        const t = this.childrenToUpdate[e];
        t.list.fill(null), (t.index = 0);
      }
      (this.childrenRenderablesToUpdate.index = 0),
        this.childrenRenderablesToUpdate.list.fill(null),
        (this.root = null),
        (this.updateTick = 0),
        (this.structureDidChange = !0),
        (this._onRenderContainers.length = 0),
        (this.renderGroupParent = null),
        this.disableCacheAsTexture();
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(e) {
      e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e),
        (e.renderGroupParent = this),
        this.renderGroupChildren.push(e);
    }
    _removeRenderGroupChild(e) {
      const t = this.renderGroupChildren.indexOf(e);
      t > -1 && this.renderGroupChildren.splice(t, 1),
        (e.renderGroupParent = null);
    }
    addChild(e) {
      if (
        ((this.structureDidChange = !0),
          (e.parentRenderGroup = this),
          (e.updateTick = -1),
          e.parent === this.root
            ? (e.relativeRenderGroupDepth = 1)
            : (e.relativeRenderGroupDepth =
              e.parent.relativeRenderGroupDepth + 1),
          (e.didChange = !0),
          this.onChildUpdate(e),
          e.renderGroup)
      ) {
        this.addRenderGroupChild(e.renderGroup);
        return;
      }
      e._onRender && this.addOnRender(e);
      const t = e.children;
      for (let a = 0; a < t.length; a++) this.addChild(t[a]);
    }
    removeChild(e) {
      if (
        ((this.structureDidChange = !0),
          e._onRender && (e.renderGroup || this.removeOnRender(e)),
          (e.parentRenderGroup = null),
          e.renderGroup)
      ) {
        this._removeRenderGroupChild(e.renderGroup);
        return;
      }
      const t = e.children;
      for (let a = 0; a < t.length; a++) this.removeChild(t[a]);
    }
    removeChildren(e) {
      for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
    }
    onChildUpdate(e) {
      let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
      t ||
        (t = this.childrenToUpdate[e.relativeRenderGroupDepth] =
          { index: 0, list: [] }),
        (t.list[t.index++] = e);
    }
    updateRenderable(e) {
      e.globalDisplayStatus < 7 ||
        (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e),
          (e.didViewUpdate = !1));
    }
    onChildViewUpdate(e) {
      this.childrenRenderablesToUpdate.list[
        this.childrenRenderablesToUpdate.index++
      ] = e;
    }
    get isRenderable() {
      return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
    }
    addOnRender(e) {
      this._onRenderContainers.push(e);
    }
    removeOnRender(e) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
    }
    runOnRender(e) {
      for (let t = 0; t < this._onRenderContainers.length; t++)
        this._onRenderContainers[t]._onRender(e);
    }
    destroy() {
      this.disableCacheAsTexture(),
        (this.renderGroupParent = null),
        (this.root = null),
        (this.childrenRenderablesToUpdate = null),
        (this.childrenToUpdate = null),
        (this.renderGroupChildren = null),
        (this._onRenderContainers = null),
        (this.instructionSet = null);
    }
    getChildren(e = []) {
      const t = this.root.children;
      for (let a = 0; a < t.length; a++) this._getChildren(t[a], e);
      return e;
    }
    _getChildren(e, t = []) {
      if ((t.push(e), e.renderGroup)) return t;
      const a = e.children;
      for (let l = 0; l < a.length; l++) this._getChildren(a[l], t);
      return t;
    }
    invalidateMatrices() {
      this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
      return (this._matrixDirty & 1) === 0
        ? this._inverseWorldTransform
        : ((this._matrixDirty &= -2),
          this._inverseWorldTransform ||
          (this._inverseWorldTransform = new ae()),
          this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
    }
    get textureOffsetInverseTransform() {
      return (this._matrixDirty & 2) === 0
        ? this._textureOffsetInverseTransform
        : ((this._matrixDirty &= -3),
          this._textureOffsetInverseTransform ||
          (this._textureOffsetInverseTransform = new ae()),
          this._textureOffsetInverseTransform
            .copyFrom(this.inverseWorldTransform)
            .translate(-this._textureBounds.x, -this._textureBounds.y));
    }
    get inverseParentTextureTransform() {
      if ((this._matrixDirty & 4) === 0)
        return this._inverseParentTextureTransform;
      this._matrixDirty &= -5;
      const e = this._parentCacheAsTextureRenderGroup;
      return e
        ? (this._inverseParentTextureTransform ||
          (this._inverseParentTextureTransform = new ae()),
          this._inverseParentTextureTransform
            .copyFrom(this.worldTransform)
            .prepend(e.inverseWorldTransform)
            .translate(-e._textureBounds.x, -e._textureBounds.y))
        : this.worldTransform;
    }
    get cacheToLocalTransform() {
      return this.isCachedAsTexture
        ? this.textureOffsetInverseTransform
        : this._parentCacheAsTextureRenderGroup
          ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform
          : null;
    }
  }
  function r0(r, e, t = {}) {
    for (const a in e) !t[a] && e[a] !== void 0 && (r[a] = e[a]);
  }
  const zl = new Tt(null),
    $a = new Tt(null),
    Wl = new Tt(null, 1, 1),
    Ka = new Tt(null),
    Za = 1,
    Vl = 2,
    Rn = 4;
  class Ne extends Os {
    constructor(e = {}) {
      super(),
        (this.uid = et("renderable")),
        (this._updateFlags = 15),
        (this.renderGroup = null),
        (this.parentRenderGroup = null),
        (this.parentRenderGroupIndex = 0),
        (this.didChange = !1),
        (this.didViewUpdate = !1),
        (this.relativeRenderGroupDepth = 0),
        (this.children = []),
        (this.parent = null),
        (this.includeInBuild = !0),
        (this.measurable = !0),
        (this.isSimple = !0),
        (this.updateTick = -1),
        (this.localTransform = new ae()),
        (this.relativeGroupTransform = new ae()),
        (this.groupTransform = this.relativeGroupTransform),
        (this.destroyed = !1),
        (this._position = new Tt(this, 0, 0)),
        (this._scale = Wl),
        (this._pivot = $a),
        (this._origin = Ka),
        (this._skew = zl),
        (this._cx = 1),
        (this._sx = 0),
        (this._cy = 0),
        (this._sy = 1),
        (this._rotation = 0),
        (this.localColor = 16777215),
        (this.localAlpha = 1),
        (this.groupAlpha = 1),
        (this.groupColor = 16777215),
        (this.groupColorAlpha = 4294967295),
        (this.localBlendMode = "inherit"),
        (this.groupBlendMode = "normal"),
        (this.localDisplayStatus = 7),
        (this.globalDisplayStatus = 7),
        (this._didContainerChangeTick = 0),
        (this._didViewChangeTick = 0),
        (this._didLocalTransformChangeId = -1),
        (this.effects = []),
        r0(this, e, { children: !0, parent: !0, effects: !0 }),
        e.children?.forEach((t) => this.addChild(t)),
        e.parent?.addChild(this);
    }
    static mixin(e) {
      me(
        "8.8.0",
        "Container.mixin is deprecated, please use extensions.mixin instead."
      ),
        ge.mixin(Ne, e);
    }
    set _didChangeId(e) {
      (this._didViewChangeTick = (e >> 12) & 4095),
        (this._didContainerChangeTick = e & 4095);
    }
    get _didChangeId() {
      return (
        (this._didContainerChangeTick & 4095) |
        ((this._didViewChangeTick & 4095) << 12)
      );
    }
    addChild(...e) {
      if (
        (this.allowChildren ||
          me(
            Ie,
            "addChild: Only Containers will be allowed to add children in v8.0.0"
          ),
          e.length > 1)
      ) {
        for (let l = 0; l < e.length; l++) this.addChild(e[l]);
        return e[0];
      }
      const t = e[0],
        a = this.renderGroup || this.parentRenderGroup;
      return t.parent === this
        ? (this.children.splice(this.children.indexOf(t), 1),
          this.children.push(t),
          a && (a.structureDidChange = !0),
          t)
        : (t.parent && t.parent.removeChild(t),
          this.children.push(t),
          this.sortableChildren && (this.sortDirty = !0),
          (t.parent = this),
          (t.didChange = !0),
          (t._updateFlags = 15),
          a && a.addChild(t),
          this.emit("childAdded", t, this, this.children.length - 1),
          t.emit("added", this),
          this._didViewChangeTick++,
          t._zIndex !== 0 && t.depthOfChildModified(),
          t);
    }
    removeChild(...e) {
      if (e.length > 1) {
        for (let l = 0; l < e.length; l++) this.removeChild(e[l]);
        return e[0];
      }
      const t = e[0],
        a = this.children.indexOf(t);
      return (
        a > -1 &&
        (this._didViewChangeTick++,
          this.children.splice(a, 1),
          this.renderGroup
            ? this.renderGroup.removeChild(t)
            : this.parentRenderGroup && this.parentRenderGroup.removeChild(t),
          t.parentRenderLayer && t.parentRenderLayer.detach(t),
          (t.parent = null),
          this.emit("childRemoved", t, this, a),
          t.emit("removed", this)),
        t
      );
    }
    _onUpdate(e) {
      e && e === this._skew && this._updateSkew(),
        this._didContainerChangeTick++,
        !this.didChange &&
        ((this.didChange = !0),
          this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
    }
    set isRenderGroup(e) {
      !!this.renderGroup !== e &&
        (e ? this.enableRenderGroup() : this.disableRenderGroup());
    }
    get isRenderGroup() {
      return !!this.renderGroup;
    }
    enableRenderGroup() {
      if (this.renderGroup) return;
      const e = this.parentRenderGroup;
      e?.removeChild(this),
        (this.renderGroup = Ot.get(Hl, this)),
        (this.groupTransform = ae.IDENTITY),
        e?.addChild(this),
        this._updateIsSimple();
    }
    disableRenderGroup() {
      if (!this.renderGroup) return;
      const e = this.parentRenderGroup;
      e?.removeChild(this),
        Ot.return(this.renderGroup),
        (this.renderGroup = null),
        (this.groupTransform = this.relativeGroupTransform),
        e?.addChild(this),
        this._updateIsSimple();
    }
    _updateIsSimple() {
      this.isSimple = !this.renderGroup && this.effects.length === 0;
    }
    get worldTransform() {
      return (
        this._worldTransform || (this._worldTransform = new ae()),
        this.renderGroup
          ? this._worldTransform.copyFrom(this.renderGroup.worldTransform)
          : this.parentRenderGroup &&
          this._worldTransform.appendFrom(
            this.relativeGroupTransform,
            this.parentRenderGroup.worldTransform
          ),
        this._worldTransform
      );
    }
    get x() {
      return this._position.x;
    }
    set x(e) {
      this._position.x = e;
    }
    get y() {
      return this._position.y;
    }
    set y(e) {
      this._position.y = e;
    }
    get position() {
      return this._position;
    }
    set position(e) {
      this._position.copyFrom(e);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(e) {
      this._rotation !== e &&
        ((this._rotation = e), this._onUpdate(this._skew));
    }
    get angle() {
      return this.rotation * w1;
    }
    set angle(e) {
      this.rotation = e * S1;
    }
    get pivot() {
      return (
        this._pivot === $a && (this._pivot = new Tt(this, 0, 0)), this._pivot
      );
    }
    set pivot(e) {
      this._pivot === $a &&
        ((this._pivot = new Tt(this, 0, 0)),
          this._origin !== Ka &&
          pe(
            "Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully."
          )),
        typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
    }
    get skew() {
      return this._skew === zl && (this._skew = new Tt(this, 0, 0)), this._skew;
    }
    set skew(e) {
      this._skew === zl && (this._skew = new Tt(this, 0, 0)),
        this._skew.copyFrom(e);
    }
    get scale() {
      return (
        this._scale === Wl && (this._scale = new Tt(this, 1, 1)), this._scale
      );
    }
    set scale(e) {
      this._scale === Wl && (this._scale = new Tt(this, 0, 0)),
        typeof e == "string" && (e = parseFloat(e)),
        typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
    }
    get origin() {
      return (
        this._origin === Ka && (this._origin = new Tt(this, 0, 0)), this._origin
      );
    }
    set origin(e) {
      this._origin === Ka &&
        ((this._origin = new Tt(this, 0, 0)),
          this._pivot !== $a &&
          pe(
            "Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully."
          )),
        typeof e == "number" ? this._origin.set(e) : this._origin.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x * this.getLocalBounds().width);
    }
    set width(e) {
      const t = this.getLocalBounds().width;
      this._setWidth(e, t);
    }
    get height() {
      return Math.abs(this.scale.y * this.getLocalBounds().height);
    }
    set height(e) {
      const t = this.getLocalBounds().height;
      this._setHeight(e, t);
    }
    getSize(e) {
      e || (e = {});
      const t = this.getLocalBounds();
      return (
        (e.width = Math.abs(this.scale.x * t.width)),
        (e.height = Math.abs(this.scale.y * t.height)),
        e
      );
    }
    setSize(e, t) {
      const a = this.getLocalBounds();
      typeof e == "object"
        ? ((t = e.height ?? e.width), (e = e.width))
        : t ?? (t = e),
        e !== void 0 && this._setWidth(e, a.width),
        t !== void 0 && this._setHeight(t, a.height);
    }
    _updateSkew() {
      const e = this._rotation,
        t = this._skew;
      (this._cx = Math.cos(e + t._y)),
        (this._sx = Math.sin(e + t._y)),
        (this._cy = -Math.sin(e - t._x)),
        (this._sy = Math.cos(e - t._x));
    }
    updateTransform(e) {
      return (
        this.position.set(
          typeof e.x == "number" ? e.x : this.position.x,
          typeof e.y == "number" ? e.y : this.position.y
        ),
        this.scale.set(
          typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x,
          typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y
        ),
        (this.rotation =
          typeof e.rotation == "number" ? e.rotation : this.rotation),
        this.skew.set(
          typeof e.skewX == "number" ? e.skewX : this.skew.x,
          typeof e.skewY == "number" ? e.skewY : this.skew.y
        ),
        this.pivot.set(
          typeof e.pivotX == "number" ? e.pivotX : this.pivot.x,
          typeof e.pivotY == "number" ? e.pivotY : this.pivot.y
        ),
        this.origin.set(
          typeof e.originX == "number" ? e.originX : this.origin.x,
          typeof e.originY == "number" ? e.originY : this.origin.y
        ),
        this
      );
    }
    setFromMatrix(e) {
      e.decompose(this);
    }
    updateLocalTransform() {
      const e = this._didContainerChangeTick;
      if (this._didLocalTransformChangeId === e) return;
      this._didLocalTransformChangeId = e;
      const t = this.localTransform,
        a = this._scale,
        l = this._pivot,
        o = this._origin,
        h = this._position,
        c = a._x,
        u = a._y,
        d = l._x,
        f = l._y,
        p = -o._x,
        g = -o._y;
      (t.a = this._cx * c),
        (t.b = this._sx * c),
        (t.c = this._cy * u),
        (t.d = this._sy * u),
        (t.tx = h._x - (d * t.a + f * t.c) + (p * t.a + g * t.c) - p),
        (t.ty = h._y - (d * t.b + f * t.d) + (p * t.b + g * t.d) - g);
    }
    set alpha(e) {
      e !== this.localAlpha &&
        ((this.localAlpha = e), (this._updateFlags |= Za), this._onUpdate());
    }
    get alpha() {
      return this.localAlpha;
    }
    set tint(e) {
      const a = mt.shared.setValue(e ?? 16777215).toBgrNumber();
      a !== this.localColor &&
        ((this.localColor = a), (this._updateFlags |= Za), this._onUpdate());
    }
    get tint() {
      return Ya(this.localColor);
    }
    set blendMode(e) {
      this.localBlendMode !== e &&
        (this.parentRenderGroup &&
          (this.parentRenderGroup.structureDidChange = !0),
          (this._updateFlags |= Vl),
          (this.localBlendMode = e),
          this._onUpdate());
    }
    get blendMode() {
      return this.localBlendMode;
    }
    get visible() {
      return !!(this.localDisplayStatus & 2);
    }
    set visible(e) {
      const t = e ? 2 : 0;
      (this.localDisplayStatus & 2) !== t &&
        (this.parentRenderGroup &&
          (this.parentRenderGroup.structureDidChange = !0),
          (this._updateFlags |= Rn),
          (this.localDisplayStatus ^= 2),
          this._onUpdate());
    }
    get culled() {
      return !(this.localDisplayStatus & 4);
    }
    set culled(e) {
      const t = e ? 0 : 4;
      (this.localDisplayStatus & 4) !== t &&
        (this.parentRenderGroup &&
          (this.parentRenderGroup.structureDidChange = !0),
          (this._updateFlags |= Rn),
          (this.localDisplayStatus ^= 4),
          this._onUpdate());
    }
    get renderable() {
      return !!(this.localDisplayStatus & 1);
    }
    set renderable(e) {
      const t = e ? 1 : 0;
      (this.localDisplayStatus & 1) !== t &&
        ((this._updateFlags |= Rn),
          (this.localDisplayStatus ^= 1),
          this.parentRenderGroup &&
          (this.parentRenderGroup.structureDidChange = !0),
          this._onUpdate());
    }
    get isRenderable() {
      return this.localDisplayStatus === 7 && this.groupAlpha > 0;
    }
    destroy(e = !1) {
      if (this.destroyed) return;
      this.destroyed = !0;
      let t;
      if (
        (this.children.length &&
          (t = this.removeChildren(0, this.children.length)),
          this.removeFromParent(),
          (this.parent = null),
          (this._maskEffect = null),
          (this._filterEffect = null),
          (this.effects = null),
          (this._position = null),
          (this._scale = null),
          (this._pivot = null),
          (this._origin = null),
          (this._skew = null),
          this.emit("destroyed", this),
          this.removeAllListeners(),
          (typeof e == "boolean" ? e : e?.children) && t)
      )
        for (let l = 0; l < t.length; ++l) t[l].destroy(e);
      this.renderGroup?.destroy(), (this.renderGroup = null);
    }
  }
  ge.mixin(Ne, z1, Y1, t0, Q1, Z1, j1, X1, J1, O1, H1, $1, W1);
  class Qa extends Ne {
    constructor(e) {
      super(e),
        (this.canBundle = !0),
        (this.allowChildren = !1),
        (this._roundPixels = 0),
        (this._lastUsed = -1),
        (this._gpuData = Object.create(null)),
        (this._bounds = new cs(0, 1, 0, 0)),
        (this._boundsDirty = !0);
    }
    get bounds() {
      return this._boundsDirty
        ? (this.updateBounds(), (this._boundsDirty = !1), this._bounds)
        : this._bounds;
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    set roundPixels(e) {
      this._roundPixels = e ? 1 : 0;
    }
    containsPoint(e) {
      const t = this.bounds,
        { x: a, y: l } = e;
      return a >= t.minX && a <= t.maxX && l >= t.minY && l <= t.maxY;
    }
    onViewUpdate() {
      if (
        (this._didViewChangeTick++,
          (this._boundsDirty = !0),
          this.didViewUpdate)
      )
        return;
      this.didViewUpdate = !0;
      const e = this.renderGroup || this.parentRenderGroup;
      e && e.onChildViewUpdate(this);
    }
    destroy(e) {
      super.destroy(e), (this._bounds = null);
      for (const t in this._gpuData) this._gpuData[t].destroy?.();
      this._gpuData = null;
    }
    collectRenderablesSimple(e, t, a) {
      const { renderPipes: l } = t;
      l.blendMode.pushBlendMode(this, this.groupBlendMode, e),
        l[this.renderPipeId].addRenderable(this, e),
        (this.didViewUpdate = !1);
      const h = this.children,
        c = h.length;
      for (let u = 0; u < c; u++) h[u].collectRenderables(e, t, a);
      l.blendMode.popBlendMode(e);
    }
  }
  class Ke extends Qa {
    constructor(e = te.EMPTY) {
      e instanceof te && (e = { texture: e });
      const {
        texture: t = te.EMPTY,
        anchor: a,
        roundPixels: l,
        width: o,
        height: h,
        ...c
      } = e;
      super({ label: "Sprite", ...c }),
        (this.renderPipeId = "sprite"),
        (this.batched = !0),
        (this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
        (this._anchor = new Tt({
          _onUpdate: () => {
            this.onViewUpdate();
          },
        })),
        a
          ? (this.anchor = a)
          : t.defaultAnchor && (this.anchor = t.defaultAnchor),
        (this.texture = t),
        (this.allowChildren = !1),
        (this.roundPixels = l ?? !1),
        o !== void 0 && (this.width = o),
        h !== void 0 && (this.height = h);
    }
    static from(e, t = !1) {
      return e instanceof te ? new Ke(e) : new Ke(te.from(e, t));
    }
    set texture(e) {
      e || (e = te.EMPTY);
      const t = this._texture;
      t !== e &&
        (t && t.dynamic && t.off("update", this.onViewUpdate, this),
          e.dynamic && e.on("update", this.onViewUpdate, this),
          (this._texture = e),
          this._width && this._setWidth(this._width, this._texture.orig.width),
          this._height &&
          this._setHeight(this._height, this._texture.orig.height),
          this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    get visualBounds() {
      return (
        Ed(this._visualBounds, this._anchor, this._texture), this._visualBounds
      );
    }
    get sourceBounds() {
      return (
        me(
          "8.6.1",
          "Sprite.sourceBounds is deprecated, use visualBounds instead."
        ),
        this.visualBounds
      );
    }
    updateBounds() {
      const e = this._anchor,
        t = this._texture,
        a = this._bounds,
        { width: l, height: o } = t.orig;
      (a.minX = -e._x * l),
        (a.maxX = a.minX + l),
        (a.minY = -e._y * o),
        (a.maxY = a.minY + o);
    }
    destroy(e = !1) {
      if ((super.destroy(e), typeof e == "boolean" ? e : e?.texture)) {
        const a = typeof e == "boolean" ? e : e?.textureSource;
        this._texture.destroy(a);
      }
      (this._texture = null),
        (this._visualBounds = null),
        (this._bounds = null),
        (this._anchor = null),
        (this._gpuData = null);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(e) {
      this._setWidth(e, this._texture.orig.width), (this._width = e);
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(e) {
      this._setHeight(e, this._texture.orig.height), (this._height = e);
    }
    getSize(e) {
      return (
        e || (e = {}),
        (e.width = Math.abs(this.scale.x) * this._texture.orig.width),
        (e.height = Math.abs(this.scale.y) * this._texture.orig.height),
        e
      );
    }
    setSize(e, t) {
      typeof e == "object"
        ? ((t = e.height ?? e.width), (e = e.width))
        : t ?? (t = e),
        e !== void 0 && this._setWidth(e, this._texture.orig.width),
        t !== void 0 && this._setHeight(t, this._texture.orig.height);
    }
  }
  const n0 = new cs();
  function $d(r, e, t) {
    const a = n0;
    (r.measurable = !0), Ol(r, t, a), e.addBoundsMask(a), (r.measurable = !1);
  }
  function Kd(r, e, t) {
    const a = Vi.get();
    r.measurable = !0;
    const l = _s.get().identity(),
      o = Zd(r, t, l);
    Nl(r, a, o),
      (r.measurable = !1),
      e.addBoundsMask(a),
      _s.return(l),
      Vi.return(a);
  }
  function Zd(r, e, t) {
    return r
      ? (r !== e &&
        (Zd(r.parent, e, t),
          r.updateLocalTransform(),
          t.append(r.localTransform)),
        t)
      : (pe("Mask bounds, renderable is not inside the root container"), t);
  }
  class Qd {
    constructor(e) {
      (this.priority = 0),
        (this.inverse = !1),
        (this.pipe = "alphaMask"),
        e?.mask && this.init(e.mask);
    }
    init(e) {
      (this.mask = e),
        (this.renderMaskToTexture = !(e instanceof Ke)),
        (this.mask.renderable = this.renderMaskToTexture),
        (this.mask.includeInBuild = !this.renderMaskToTexture),
        (this.mask.measurable = !1);
    }
    reset() {
      (this.mask.measurable = !0), (this.mask = null);
    }
    addBounds(e, t) {
      this.inverse || $d(this.mask, e, t);
    }
    addLocalBounds(e, t) {
      Kd(this.mask, e, t);
    }
    containsPoint(e, t) {
      const a = this.mask;
      return t(a, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof Ke;
    }
  }
  Qd.extension = P.MaskEffect;
  class Jd {
    constructor(e) {
      (this.priority = 0),
        (this.pipe = "colorMask"),
        e?.mask && this.init(e.mask);
    }
    init(e) {
      this.mask = e;
    }
    destroy() { }
    static test(e) {
      return typeof e == "number";
    }
  }
  Jd.extension = P.MaskEffect;
  class eu {
    constructor(e) {
      (this.priority = 0),
        (this.pipe = "stencilMask"),
        e?.mask && this.init(e.mask);
    }
    init(e) {
      (this.mask = e),
        (this.mask.includeInBuild = !1),
        (this.mask.measurable = !1);
    }
    reset() {
      (this.mask.measurable = !0),
        (this.mask.includeInBuild = !0),
        (this.mask = null);
    }
    addBounds(e, t) {
      $d(this.mask, e, t);
    }
    addLocalBounds(e, t) {
      Kd(this.mask, e, t);
    }
    containsPoint(e, t) {
      const a = this.mask;
      return t(a, e);
    }
    destroy() {
      this.reset();
    }
    static test(e) {
      return e instanceof Ne;
    }
  }
  eu.extension = P.MaskEffect;
  let tu = {
    createCanvas: (r, e) => {
      const t = document.createElement("canvas");
      return (t.width = r), (t.height = e), t;
    },
    createImage: () => new Image(),
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ?? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (r, e) => fetch(r, e),
    parseXML: (r) => new DOMParser().parseFromString(r, "text/xml"),
  };
  const xe = {
    get() {
      return tu;
    },
    set(r) {
      tu = r;
    },
  };
  class ji extends zt {
    constructor(e) {
      e.resource || (e.resource = xe.get().createCanvas()),
        e.width ||
        ((e.width = e.resource.width),
          e.autoDensity || (e.width /= e.resolution)),
        e.height ||
        ((e.height = e.resource.height),
          e.autoDensity || (e.height /= e.resolution)),
        super(e),
        (this.uploadMethodId = "image"),
        (this.autoDensity = e.autoDensity),
        this.resizeCanvas(),
        (this.transparent = !!e.transparent);
    }
    resizeCanvas() {
      this.autoDensity &&
        "style" in this.resource &&
        ((this.resource.style.width = `${this.width}px`),
          (this.resource.style.height = `${this.height}px`)),
        (this.resource.width !== this.pixelWidth ||
          this.resource.height !== this.pixelHeight) &&
        ((this.resource.width = this.pixelWidth),
          (this.resource.height = this.pixelHeight));
    }
    resize(e = this.width, t = this.height, a = this._resolution) {
      const l = super.resize(e, t, a);
      return l && this.resizeCanvas(), l;
    }
    static test(e) {
      return (
        (globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement) ||
        (globalThis.OffscreenCanvas && e instanceof OffscreenCanvas)
      );
    }
    get context2D() {
      return (
        this._context2D || (this._context2D = this.resource.getContext("2d"))
      );
    }
  }
  ji.extension = P.TextureSource;
  class Rr extends zt {
    constructor(e) {
      super(e), (this.uploadMethodId = "image"), (this.autoGarbageCollect = !0);
    }
    static test(e) {
      return (
        (globalThis.HTMLImageElement && e instanceof HTMLImageElement) ||
        (typeof ImageBitmap < "u" && e instanceof ImageBitmap) ||
        (globalThis.VideoFrame && e instanceof VideoFrame)
      );
    }
  }
  Rr.extension = P.TextureSource;
  var Qr = ((r) => (
    (r[(r.INTERACTION = 50)] = "INTERACTION"),
    (r[(r.HIGH = 25)] = "HIGH"),
    (r[(r.NORMAL = 0)] = "NORMAL"),
    (r[(r.LOW = -25)] = "LOW"),
    (r[(r.UTILITY = -50)] = "UTILITY"),
    r
  ))(Qr || {});
  class jl {
    constructor(e, t = null, a = 0, l = !1) {
      (this.next = null),
        (this.previous = null),
        (this._destroyed = !1),
        (this._fn = e),
        (this._context = t),
        (this.priority = a),
        (this._once = l);
    }
    match(e, t = null) {
      return this._fn === e && this._context === t;
    }
    emit(e) {
      this._fn &&
        (this._context ? this._fn.call(this._context, e) : this._fn(e));
      const t = this.next;
      return (
        this._once && this.destroy(!0), this._destroyed && (this.next = null), t
      );
    }
    connect(e) {
      (this.previous = e),
        e.next && (e.next.previous = this),
        (this.next = e.next),
        (e.next = this);
    }
    destroy(e = !1) {
      (this._destroyed = !0),
        (this._fn = null),
        (this._context = null),
        this.previous && (this.previous.next = this.next),
        this.next && (this.next.previous = this.previous);
      const t = this.next;
      return (this.next = e ? null : t), (this.previous = null), t;
    }
  }
  const su = class Zs {
    constructor() {
      (this.autoStart = !1),
        (this.deltaTime = 1),
        (this.lastTime = -1),
        (this.speed = 1),
        (this.started = !1),
        (this._requestId = null),
        (this._maxElapsedMS = 100),
        (this._minElapsedMS = 0),
        (this._protected = !1),
        (this._lastFrame = -1),
        (this._head = new jl(null, null, 1 / 0)),
        (this.deltaMS = 1 / Zs.targetFPMS),
        (this.elapsedMS = 1 / Zs.targetFPMS),
        (this._tick = (e) => {
          (this._requestId = null),
            this.started &&
            (this.update(e),
              this.started &&
              this._requestId === null &&
              this._head.next &&
              (this._requestId = requestAnimationFrame(this._tick)));
        });
    }
    _requestIfNeeded() {
      this._requestId === null &&
        this._head.next &&
        ((this.lastTime = performance.now()),
          (this._lastFrame = this.lastTime),
          (this._requestId = requestAnimationFrame(this._tick)));
    }
    _cancelIfNeeded() {
      this._requestId !== null &&
        (cancelAnimationFrame(this._requestId), (this._requestId = null));
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(e, t, a = Qr.NORMAL) {
      return this._addListener(new jl(e, t, a));
    }
    addOnce(e, t, a = Qr.NORMAL) {
      return this._addListener(new jl(e, t, a, !0));
    }
    _addListener(e) {
      let t = this._head.next,
        a = this._head;
      if (!t) e.connect(a);
      else {
        for (; t;) {
          if (e.priority > t.priority) {
            e.connect(a);
            break;
          }
          (a = t), (t = t.next);
        }
        e.previous || e.connect(a);
      }
      return this._startIfPossible(), this;
    }
    remove(e, t) {
      let a = this._head.next;
      for (; a;) a.match(e, t) ? (a = a.destroy()) : (a = a.next);
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) return 0;
      let e = 0,
        t = this._head;
      for (; (t = t.next);) e++;
      return e;
    }
    start() {
      this.started || ((this.started = !0), this._requestIfNeeded());
    }
    stop() {
      this.started && ((this.started = !1), this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let e = this._head.next;
        for (; e;) e = e.destroy(!0);
        this._head.destroy(), (this._head = null);
      }
    }
    update(e = performance.now()) {
      let t;
      if (e > this.lastTime) {
        if (
          ((t = this.elapsedMS = e - this.lastTime),
            t > this._maxElapsedMS && (t = this._maxElapsedMS),
            (t *= this.speed),
            this._minElapsedMS)
        ) {
          const o = (e - this._lastFrame) | 0;
          if (o < this._minElapsedMS) return;
          this._lastFrame = e - (o % this._minElapsedMS);
        }
        (this.deltaMS = t), (this.deltaTime = this.deltaMS * Zs.targetFPMS);
        const a = this._head;
        let l = a.next;
        for (; l;) l = l.emit(this);
        a.next || this._cancelIfNeeded();
      } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = e;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(e) {
      const t = Math.min(this.maxFPS, e),
        a = Math.min(Math.max(0, t) / 1e3, Zs.targetFPMS);
      this._maxElapsedMS = 1 / a;
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(e) {
      if (e === 0) this._minElapsedMS = 0;
      else {
        const t = Math.max(this.minFPS, e);
        this._minElapsedMS = 1 / (t / 1e3);
      }
    }
    static get shared() {
      if (!Zs._shared) {
        const e = (Zs._shared = new Zs());
        (e.autoStart = !0), (e._protected = !0);
      }
      return Zs._shared;
    }
    static get system() {
      if (!Zs._system) {
        const e = (Zs._system = new Zs());
        (e.autoStart = !0), (e._protected = !0);
      }
      return Zs._system;
    }
  };
  su.targetFPMS = 0.06;
  let Js = su,
    Xl;
  async function iu() {
    return (
      Xl ??
      (Xl = (async () => {
        const e = xe.get().createCanvas(1, 1).getContext("webgl");
        if (!e) return "premultiply-alpha-on-upload";
        const t = await new Promise((h) => {
          const c = document.createElement("video");
          (c.onloadeddata = () => h(c)),
            (c.onerror = () => h(null)),
            (c.autoplay = !1),
            (c.crossOrigin = "anonymous"),
            (c.preload = "auto"),
            (c.src =
              "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM="),
            c.load();
        });
        if (!t) return "premultiply-alpha-on-upload";
        const a = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, a);
        const l = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, l),
          e.framebufferTexture2D(
            e.FRAMEBUFFER,
            e.COLOR_ATTACHMENT0,
            e.TEXTURE_2D,
            a,
            0
          ),
          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
          e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE),
          e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
        const o = new Uint8Array(4);
        return (
          e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, o),
          e.deleteFramebuffer(l),
          e.deleteTexture(a),
          e.getExtension("WEBGL_lose_context")?.loseContext(),
          o[0] <= o[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
        );
      })()),
      Xl
    );
  }
  const Ja = class Km extends zt {
    constructor(e) {
      super(e),
        (this.isReady = !1),
        (this.uploadMethodId = "video"),
        (e = { ...Km.defaultOptions, ...e }),
        (this._autoUpdate = !0),
        (this._isConnectedToTicker = !1),
        (this._updateFPS = e.updateFPS || 0),
        (this._msToNextUpdate = 0),
        (this.autoPlay = e.autoPlay !== !1),
        (this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload"),
        (this._videoFrameRequestCallback =
          this._videoFrameRequestCallback.bind(this)),
        (this._videoFrameRequestCallbackHandle = null),
        (this._load = null),
        (this._resolve = null),
        (this._reject = null),
        (this._onCanPlay = this._onCanPlay.bind(this)),
        (this._onCanPlayThrough = this._onCanPlayThrough.bind(this)),
        (this._onError = this._onError.bind(this)),
        (this._onPlayStart = this._onPlayStart.bind(this)),
        (this._onPlayStop = this._onPlayStop.bind(this)),
        (this._onSeeked = this._onSeeked.bind(this)),
        e.autoLoad !== !1 && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        if (this._updateFPS) {
          const e = Js.shared.elapsedMS * this.resource.playbackRate;
          this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
        }
        (!this._updateFPS || this._msToNextUpdate <= 0) &&
          (this._msToNextUpdate = this._updateFPS
            ? Math.floor(1e3 / this._updateFPS)
            : 0),
          this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame(),
        this.destroyed
          ? (this._videoFrameRequestCallbackHandle = null)
          : (this._videoFrameRequestCallbackHandle =
            this.resource.requestVideoFrameCallback(
              this._videoFrameRequestCallback
            ));
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) return this._load;
      const e = this.resource,
        t = this.options;
      return (
        (e.readyState === e.HAVE_ENOUGH_DATA ||
          e.readyState === e.HAVE_FUTURE_DATA) &&
        e.width &&
        e.height &&
        (e.complete = !0),
        e.addEventListener("play", this._onPlayStart),
        e.addEventListener("pause", this._onPlayStop),
        e.addEventListener("seeked", this._onSeeked),
        this._isSourceReady()
          ? this._mediaReady()
          : (t.preload || e.addEventListener("canplay", this._onCanPlay),
            e.addEventListener("canplaythrough", this._onCanPlayThrough),
            e.addEventListener("error", this._onError, !0)),
        (this.alphaMode = await iu()),
        (this._load = new Promise((a, l) => {
          this.isValid
            ? a(this)
            : ((this._resolve = a),
              (this._reject = l),
              t.preloadTimeoutMs !== void 0 &&
              (this._preloadTimeout = setTimeout(() => {
                this._onError(
                  new ErrorEvent(
                    `Preload exceeded timeout of ${t.preloadTimeoutMs}ms`
                  )
                );
              })),
              e.load());
        })),
        this._load
      );
    }
    _onError(e) {
      this.resource.removeEventListener("error", this._onError, !0),
        this.emit("error", e),
        this._reject &&
        (this._reject(e), (this._reject = null), (this._resolve = null));
    }
    _isSourcePlaying() {
      const e = this.resource;
      return !e.paused && !e.ended;
    }
    _isSourceReady() {
      return this.resource.readyState > 2;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady(), this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate &&
        !this._isSourcePlaying() &&
        ((this._msToNextUpdate = 0),
          this.updateFrame(),
          (this._msToNextUpdate = 0));
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay),
        this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay),
        this._preloadTimeout &&
        (clearTimeout(this._preloadTimeout), (this._preloadTimeout = void 0)),
        this._mediaReady();
    }
    _mediaReady() {
      const e = this.resource;
      this.isValid &&
        ((this.isReady = !0), this.resize(e.videoWidth, e.videoHeight)),
        (this._msToNextUpdate = 0),
        this.updateFrame(),
        (this._msToNextUpdate = 0),
        this._resolve &&
        (this._resolve(this), (this._resolve = null), (this._reject = null)),
        this._isSourcePlaying()
          ? this._onPlayStart()
          : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const e = this.resource;
      e &&
        (e.removeEventListener("play", this._onPlayStart),
          e.removeEventListener("pause", this._onPlayStop),
          e.removeEventListener("seeked", this._onSeeked),
          e.removeEventListener("canplay", this._onCanPlay),
          e.removeEventListener("canplaythrough", this._onCanPlayThrough),
          e.removeEventListener("error", this._onError, !0),
          e.pause(),
          (e.src = ""),
          e.load()),
        super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(e) {
      e !== this._autoUpdate &&
        ((this._autoUpdate = e), this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(e) {
      e !== this._updateFPS &&
        ((this._updateFPS = e), this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying()
        ? !this._updateFPS && this.resource.requestVideoFrameCallback
          ? (this._isConnectedToTicker &&
            (Js.shared.remove(this.updateFrame, this),
              (this._isConnectedToTicker = !1),
              (this._msToNextUpdate = 0)),
            this._videoFrameRequestCallbackHandle === null &&
            (this._videoFrameRequestCallbackHandle =
              this.resource.requestVideoFrameCallback(
                this._videoFrameRequestCallback
              )))
          : (this._videoFrameRequestCallbackHandle !== null &&
            (this.resource.cancelVideoFrameCallback(
              this._videoFrameRequestCallbackHandle
            ),
              (this._videoFrameRequestCallbackHandle = null)),
            this._isConnectedToTicker ||
            (Js.shared.add(this.updateFrame, this),
              (this._isConnectedToTicker = !0),
              (this._msToNextUpdate = 0)))
        : (this._videoFrameRequestCallbackHandle !== null &&
          (this.resource.cancelVideoFrameCallback(
            this._videoFrameRequestCallbackHandle
          ),
            (this._videoFrameRequestCallbackHandle = null)),
          this._isConnectedToTicker &&
          (Js.shared.remove(this.updateFrame, this),
            (this._isConnectedToTicker = !1),
            (this._msToNextUpdate = 0)));
    }
    static test(e) {
      return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
    }
  };
  (Ja.extension = P.TextureSource),
    (Ja.defaultOptions = {
      ...zt.defaultOptions,
      autoLoad: !0,
      autoPlay: !0,
      updateFPS: 0,
      crossorigin: !0,
      loop: !1,
      muted: !0,
      playsinline: !0,
      preload: !1,
    }),
    (Ja.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4",
    });
  let In = Ja;
  const ui = (r, e, t = !1) => (
    Array.isArray(r) || (r = [r]),
    e ? r.map((a) => (typeof a == "string" || t ? e(a) : a)) : r
  );
  class a0 {
    constructor() {
      (this._parsers = []),
        (this._cache = new Map()),
        (this._cacheMap = new Map());
    }
    reset() {
      this._cacheMap.clear(), this._cache.clear();
    }
    has(e) {
      return this._cache.has(e);
    }
    get(e) {
      const t = this._cache.get(e);
      return t || pe(`[Assets] Asset id ${e} was not found in the Cache`), t;
    }
    set(e, t) {
      const a = ui(e);
      let l;
      for (let u = 0; u < this.parsers.length; u++) {
        const d = this.parsers[u];
        if (d.test(t)) {
          l = d.getCacheableAssets(a, t);
          break;
        }
      }
      const o = new Map(Object.entries(l || {}));
      l ||
        a.forEach((u) => {
          o.set(u, t);
        });
      const h = [...o.keys()],
        c = { cacheKeys: h, keys: a };
      a.forEach((u) => {
        this._cacheMap.set(u, c);
      }),
        h.forEach((u) => {
          const d = l ? l[u] : t;
          this._cache.has(u) &&
            this._cache.get(u) !== d &&
            pe("[Cache] already has key:", u),
            this._cache.set(u, o.get(u));
        });
    }
    remove(e) {
      if (!this._cacheMap.has(e)) {
        pe(`[Assets] Asset id ${e} was not found in the Cache`);
        return;
      }
      const t = this._cacheMap.get(e);
      t.cacheKeys.forEach((l) => {
        this._cache.delete(l);
      }),
        t.keys.forEach((l) => {
          this._cacheMap.delete(l);
        });
    }
    get parsers() {
      return this._parsers;
    }
  }
  const We = new a0(),
    ql = [];
  ge.handleByList(P.TextureSource, ql);
  function ru(r = {}) {
    const e = r && r.resource,
      t = e ? r.resource : r,
      a = e ? r : { resource: r };
    for (let l = 0; l < ql.length; l++) {
      const o = ql[l];
      if (o.test(t)) return new o(a);
    }
    throw new Error(`Could not find a source type for resource: ${a.resource}`);
  }
  function o0(r = {}, e = !1) {
    const t = r && r.resource,
      a = t ? r.resource : r,
      l = t ? r : { resource: r };
    if (!e && We.has(a)) return We.get(a);
    const o = new te({ source: ru(l) });
    return (
      o.on("destroy", () => {
        We.has(a) && We.remove(a);
      }),
      e || We.set(a, o),
      o
    );
  }
  function l0(r, e = !1) {
    return typeof r == "string"
      ? We.get(r)
      : r instanceof zt
        ? new te({ source: r })
        : o0(r, e);
  }
  (te.from = l0), (zt.from = ru), ge.add(Qd, Jd, eu, In, Rr, ji, kl);
  var or = ((r) => (
    (r[(r.Low = 0)] = "Low"),
    (r[(r.Normal = 1)] = "Normal"),
    (r[(r.High = 2)] = "High"),
    r
  ))(or || {});
  function fi(r) {
    if (typeof r != "string")
      throw new TypeError(
        `Path must be a string. Received ${JSON.stringify(r)}`
      );
  }
  function Bn(r) {
    return r.split("?")[0].split("#")[0];
  }
  function h0(r) {
    return r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function c0(r, e, t) {
    return r.replace(new RegExp(h0(e), "g"), t);
  }
  function d0(r, e) {
    let t = "",
      a = 0,
      l = -1,
      o = 0,
      h = -1;
    for (let c = 0; c <= r.length; ++c) {
      if (c < r.length) h = r.charCodeAt(c);
      else {
        if (h === 47) break;
        h = 47;
      }
      if (h === 47) {
        if (!(l === c - 1 || o === 1))
          if (l !== c - 1 && o === 2) {
            if (
              t.length < 2 ||
              a !== 2 ||
              t.charCodeAt(t.length - 1) !== 46 ||
              t.charCodeAt(t.length - 2) !== 46
            ) {
              if (t.length > 2) {
                const u = t.lastIndexOf("/");
                if (u !== t.length - 1) {
                  u === -1
                    ? ((t = ""), (a = 0))
                    : ((t = t.slice(0, u)),
                      (a = t.length - 1 - t.lastIndexOf("/"))),
                    (l = c),
                    (o = 0);
                  continue;
                }
              } else if (t.length === 2 || t.length === 1) {
                (t = ""), (a = 0), (l = c), (o = 0);
                continue;
              }
            }
          } else
            t.length > 0
              ? (t += `/${r.slice(l + 1, c)}`)
              : (t = r.slice(l + 1, c)),
              (a = c - l - 1);
        (l = c), (o = 0);
      } else h === 46 && o !== -1 ? ++o : (o = -1);
    }
    return t;
  }
  const Ls = {
    toPosix(r) {
      return c0(r, "\\", "/");
    },
    isUrl(r) {
      return /^https?:/.test(this.toPosix(r));
    },
    isDataUrl(r) {
      return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
        r
      );
    },
    isBlobUrl(r) {
      return r.startsWith("blob:");
    },
    hasProtocol(r) {
      return /^[^/:]+:/.test(this.toPosix(r));
    },
    getProtocol(r) {
      fi(r), (r = this.toPosix(r));
      const e = /^file:\/\/\//.exec(r);
      if (e) return e[0];
      const t = /^[^/:]+:\/{0,2}/.exec(r);
      return t ? t[0] : "";
    },
    toAbsolute(r, e, t) {
      if ((fi(r), this.isDataUrl(r) || this.isBlobUrl(r))) return r;
      const a = Bn(this.toPosix(e ?? xe.get().getBaseUrl())),
        l = Bn(this.toPosix(t ?? this.rootname(a)));
      return (
        (r = this.toPosix(r)),
        r.startsWith("/")
          ? Ls.join(l, r.slice(1))
          : this.isAbsolute(r)
            ? r
            : this.join(a, r)
      );
    },
    normalize(r) {
      if ((fi(r), r.length === 0)) return ".";
      if (this.isDataUrl(r) || this.isBlobUrl(r)) return r;
      r = this.toPosix(r);
      let e = "";
      const t = r.startsWith("/");
      this.hasProtocol(r) && ((e = this.rootname(r)), (r = r.slice(e.length)));
      const a = r.endsWith("/");
      return (r = d0(r)), r.length > 0 && a && (r += "/"), t ? `/${r}` : e + r;
    },
    isAbsolute(r) {
      return (
        fi(r),
        (r = this.toPosix(r)),
        this.hasProtocol(r) ? !0 : r.startsWith("/")
      );
    },
    join(...r) {
      if (r.length === 0) return ".";
      let e;
      for (let t = 0; t < r.length; ++t) {
        const a = r[t];
        if ((fi(a), a.length > 0))
          if (e === void 0) e = a;
          else {
            const l = r[t - 1] ?? "";
            this.joinExtensions.includes(this.extname(l).toLowerCase())
              ? (e += `/../${a}`)
              : (e += `/${a}`);
          }
      }
      return e === void 0 ? "." : this.normalize(e);
    },
    dirname(r) {
      if ((fi(r), r.length === 0)) return ".";
      r = this.toPosix(r);
      let e = r.charCodeAt(0);
      const t = e === 47;
      let a = -1,
        l = !0;
      const o = this.getProtocol(r),
        h = r;
      r = r.slice(o.length);
      for (let c = r.length - 1; c >= 1; --c)
        if (((e = r.charCodeAt(c)), e === 47)) {
          if (!l) {
            a = c;
            break;
          }
        } else l = !1;
      return a === -1
        ? t
          ? "/"
          : this.isUrl(h)
            ? o + r
            : o
        : t && a === 1
          ? "//"
          : o + r.slice(0, a);
    },
    rootname(r) {
      fi(r), (r = this.toPosix(r));
      let e = "";
      if (
        (r.startsWith("/") ? (e = "/") : (e = this.getProtocol(r)),
          this.isUrl(r))
      ) {
        const t = r.indexOf("/", e.length);
        t !== -1 ? (e = r.slice(0, t)) : (e = r), e.endsWith("/") || (e += "/");
      }
      return e;
    },
    basename(r, e) {
      fi(r), e && fi(e), (r = Bn(this.toPosix(r)));
      let t = 0,
        a = -1,
        l = !0,
        o;
      if (e !== void 0 && e.length > 0 && e.length <= r.length) {
        if (e.length === r.length && e === r) return "";
        let h = e.length - 1,
          c = -1;
        for (o = r.length - 1; o >= 0; --o) {
          const u = r.charCodeAt(o);
          if (u === 47) {
            if (!l) {
              t = o + 1;
              break;
            }
          } else
            c === -1 && ((l = !1), (c = o + 1)),
              h >= 0 &&
              (u === e.charCodeAt(h)
                ? --h === -1 && (a = o)
                : ((h = -1), (a = c)));
        }
        return t === a ? (a = c) : a === -1 && (a = r.length), r.slice(t, a);
      }
      for (o = r.length - 1; o >= 0; --o)
        if (r.charCodeAt(o) === 47) {
          if (!l) {
            t = o + 1;
            break;
          }
        } else a === -1 && ((l = !1), (a = o + 1));
      return a === -1 ? "" : r.slice(t, a);
    },
    extname(r) {
      fi(r), (r = Bn(this.toPosix(r)));
      let e = -1,
        t = 0,
        a = -1,
        l = !0,
        o = 0;
      for (let h = r.length - 1; h >= 0; --h) {
        const c = r.charCodeAt(h);
        if (c === 47) {
          if (!l) {
            t = h + 1;
            break;
          }
          continue;
        }
        a === -1 && ((l = !1), (a = h + 1)),
          c === 46
            ? e === -1
              ? (e = h)
              : o !== 1 && (o = 1)
            : e !== -1 && (o = -1);
      }
      return e === -1 ||
        a === -1 ||
        o === 0 ||
        (o === 1 && e === a - 1 && e === t + 1)
        ? ""
        : r.slice(e, a);
    },
    parse(r) {
      fi(r);
      const e = { root: "", dir: "", base: "", ext: "", name: "" };
      if (r.length === 0) return e;
      r = Bn(this.toPosix(r));
      let t = r.charCodeAt(0);
      const a = this.isAbsolute(r);
      let l;
      (e.root = this.rootname(r)), a || this.hasProtocol(r) ? (l = 1) : (l = 0);
      let o = -1,
        h = 0,
        c = -1,
        u = !0,
        d = r.length - 1,
        f = 0;
      for (; d >= l; --d) {
        if (((t = r.charCodeAt(d)), t === 47)) {
          if (!u) {
            h = d + 1;
            break;
          }
          continue;
        }
        c === -1 && ((u = !1), (c = d + 1)),
          t === 46
            ? o === -1
              ? (o = d)
              : f !== 1 && (f = 1)
            : o !== -1 && (f = -1);
      }
      return (
        o === -1 ||
          c === -1 ||
          f === 0 ||
          (f === 1 && o === c - 1 && o === h + 1)
          ? c !== -1 &&
          (h === 0 && a
            ? (e.base = e.name = r.slice(1, c))
            : (e.base = e.name = r.slice(h, c)))
          : (h === 0 && a
            ? ((e.name = r.slice(1, o)), (e.base = r.slice(1, c)))
            : ((e.name = r.slice(h, o)), (e.base = r.slice(h, c))),
            (e.ext = r.slice(o, c))),
        (e.dir = this.dirname(r)),
        e
      );
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"],
  };
  function nu(r, e, t, a, l) {
    const o = e[t];
    for (let h = 0; h < o.length; h++) {
      const c = o[h];
      t < e.length - 1
        ? nu(r.replace(a[t], c), e, t + 1, a, l)
        : l.push(r.replace(a[t], c));
    }
  }
  function u0(r) {
    const e = /\{(.*?)\}/g,
      t = r.match(e),
      a = [];
    if (t) {
      const l = [];
      t.forEach((o) => {
        const h = o.substring(1, o.length - 1).split(",");
        l.push(h);
      }),
        nu(r, l, 0, t, a);
    } else a.push(r);
    return a;
  }
  const eo = (r) => !Array.isArray(r);
  class Jr {
    constructor() {
      (this._defaultBundleIdentifierOptions = {
        connector: "-",
        createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
        extractAssetIdFromBundle: (e, t) =>
          t.replace(`${e}${this._bundleIdConnector}`, ""),
      }),
        (this._bundleIdConnector =
          this._defaultBundleIdentifierOptions.connector),
        (this._createBundleAssetId =
          this._defaultBundleIdentifierOptions.createBundleAssetId),
        (this._extractAssetIdFromBundle =
          this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
        (this._assetMap = {}),
        (this._preferredOrder = []),
        (this._parsers = []),
        (this._resolverHash = {}),
        (this._bundles = {});
    }
    setBundleIdentifier(e) {
      if (
        ((this._bundleIdConnector = e.connector ?? this._bundleIdConnector),
          (this._createBundleAssetId =
            e.createBundleAssetId ?? this._createBundleAssetId),
          (this._extractAssetIdFromBundle =
            e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
          this._extractAssetIdFromBundle(
            "foo",
            this._createBundleAssetId("foo", "bar")
          ) !== "bar")
      )
        throw new Error(
          "[Resolver] GenerateBundleAssetId are not working correctly"
        );
    }
    prefer(...e) {
      e.forEach((t) => {
        this._preferredOrder.push(t),
          t.priority || (t.priority = Object.keys(t.params));
      }),
        (this._resolverHash = {});
    }
    set basePath(e) {
      this._basePath = e;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(e) {
      this._rootPath = e;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
        (this._assetMap = {}),
        (this._preferredOrder = []),
        (this._resolverHash = {}),
        (this._rootPath = null),
        (this._basePath = null),
        (this._manifest = null),
        (this._bundles = {}),
        (this._defaultSearchParams = null);
    }
    setDefaultSearchParams(e) {
      if (typeof e == "string") this._defaultSearchParams = e;
      else {
        const t = e;
        this._defaultSearchParams = Object.keys(t)
          .map((a) => `${encodeURIComponent(a)}=${encodeURIComponent(t[a])}`)
          .join("&");
      }
    }
    getAlias(e) {
      const { alias: t, src: a } = e;
      return ui(
        t || a,
        (o) =>
          typeof o == "string"
            ? o
            : Array.isArray(o)
              ? o.map((h) => h?.src ?? h)
              : o?.src
                ? o.src
                : o,
        !0
      );
    }
    addManifest(e) {
      this._manifest &&
        pe("[Resolver] Manifest already exists, this will be overwritten"),
        (this._manifest = e),
        e.bundles.forEach((t) => {
          this.addBundle(t.name, t.assets);
        });
    }
    addBundle(e, t) {
      const a = [];
      let l = t;
      Array.isArray(t) ||
        (l = Object.entries(t).map(([o, h]) =>
          typeof h == "string" || Array.isArray(h)
            ? { alias: o, src: h }
            : { alias: o, ...h }
        )),
        l.forEach((o) => {
          const h = o.src,
            c = o.alias;
          let u;
          if (typeof c == "string") {
            const d = this._createBundleAssetId(e, c);
            a.push(d), (u = [c, d]);
          } else {
            const d = c.map((f) => this._createBundleAssetId(e, f));
            a.push(...d), (u = [...c, ...d]);
          }
          this.add({ ...o, alias: u, src: h });
        }),
        (this._bundles[e] = a);
    }
    add(e) {
      const t = [];
      Array.isArray(e) ? t.push(...e) : t.push(e);
      let a;
      (a = (o) => {
        this.hasKey(o) && pe(`[Resolver] already has key: ${o} overwriting`);
      }),
        ui(t).forEach((o) => {
          const { src: h } = o;
          let { data: c, format: u, loadParser: d, parser: f } = o;
          const p = ui(h).map((m) =>
            typeof m == "string" ? u0(m) : Array.isArray(m) ? m : [m]
          ),
            g = this.getAlias(o);
          Array.isArray(g) ? g.forEach(a) : a(g);
          const _ = [];
          p.forEach((m) => {
            m.forEach((w) => {
              let x = {};
              if (typeof w != "object") {
                x.src = w;
                for (let M = 0; M < this._parsers.length; M++) {
                  const b = this._parsers[M];
                  if (b.test(w)) {
                    x = b.parse(w);
                    break;
                  }
                }
              } else
                (c = w.data ?? c),
                  (u = w.format ?? u),
                  (w.loadParser || w.parser) &&
                  ((d = w.loadParser ?? d), (f = w.parser ?? f)),
                  (x = { ...x, ...w });
              if (!g)
                throw new Error(
                  `[Resolver] alias is undefined for this asset: ${x.src}`
                );
              (x = this._buildResolvedAsset(x, {
                aliases: g,
                data: c,
                format: u,
                loadParser: d,
                parser: f,
              })),
                _.push(x);
            });
          }),
            g.forEach((m) => {
              this._assetMap[m] = _;
            });
        });
    }
    resolveBundle(e) {
      const t = eo(e);
      e = ui(e);
      const a = {};
      return (
        e.forEach((l) => {
          const o = this._bundles[l];
          if (o) {
            const h = this.resolve(o),
              c = {};
            for (const u in h) {
              const d = h[u];
              c[this._extractAssetIdFromBundle(l, u)] = d;
            }
            a[l] = c;
          }
        }),
        t ? a[e[0]] : a
      );
    }
    resolveUrl(e) {
      const t = this.resolve(e);
      if (typeof e != "string") {
        const a = {};
        for (const l in t) a[l] = t[l].src;
        return a;
      }
      return t.src;
    }
    resolve(e) {
      const t = eo(e);
      e = ui(e);
      const a = {};
      return (
        e.forEach((l) => {
          if (!this._resolverHash[l])
            if (this._assetMap[l]) {
              let o = this._assetMap[l];
              const h = this._getPreferredOrder(o);
              h?.priority.forEach((c) => {
                h.params[c].forEach((u) => {
                  const d = o.filter((f) => (f[c] ? f[c] === u : !1));
                  d.length && (o = d);
                });
              }),
                (this._resolverHash[l] = o[0]);
            } else
              this._resolverHash[l] = this._buildResolvedAsset(
                { alias: [l], src: l },
                {}
              );
          a[l] = this._resolverHash[l];
        }),
        t ? a[e[0]] : a
      );
    }
    hasKey(e) {
      return !!this._assetMap[e];
    }
    hasBundle(e) {
      return !!this._bundles[e];
    }
    _getPreferredOrder(e) {
      for (let t = 0; t < e.length; t++) {
        const a = e[t],
          l = this._preferredOrder.find((o) =>
            o.params.format.includes(a.format)
          );
        if (l) return l;
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(e) {
      if (!this._defaultSearchParams) return e;
      const t = /\?/.test(e) ? "&" : "?";
      return `${e}${t}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(e, t) {
      const { aliases: a, data: l, loadParser: o, parser: h, format: c } = t;
      return (
        (this._basePath || this._rootPath) &&
        (e.src = Ls.toAbsolute(e.src, this._basePath, this._rootPath)),
        (e.alias = a ?? e.alias ?? [e.src]),
        (e.src = this._appendDefaultSearchParams(e.src)),
        (e.data = { ...(l || {}), ...e.data }),
        (e.loadParser = o ?? e.loadParser),
        (e.parser = h ?? e.parser),
        (e.format = c ?? e.format ?? f0(e.src)),
        e
      );
    }
  }
  Jr.RETINA_PREFIX = /@([0-9\.]+)x/;
  function f0(r) {
    return r.split(".").pop().split("?").shift().split("#").shift();
  }
  const Yl = (r, e) => {
    const t = e.split("?")[1];
    return t && (r += `?${t}`), r;
  },
    au = class La {
      constructor(e, t) {
        this.linkedSheets = [];
        let a = e;
        e?.source instanceof zt && (a = { texture: e, data: t });
        const { texture: l, data: o, cachePrefix: h = "" } = a;
        (this.cachePrefix = h),
          (this._texture = l instanceof te ? l : null),
          (this.textureSource = l.source),
          (this.textures = {}),
          (this.animations = {}),
          (this.data = o);
        const c = parseFloat(o.meta.scale);
        c
          ? ((this.resolution = c), (l.source.resolution = this.resolution))
          : (this.resolution = l.source._resolution),
          (this._frames = this.data.frames),
          (this._frameKeys = Object.keys(this._frames)),
          (this._batchIndex = 0),
          (this._callback = null);
      }
      parse() {
        return new Promise((e) => {
          (this._callback = e),
            (this._batchIndex = 0),
            this._frameKeys.length <= La.BATCH_SIZE
              ? (this._processFrames(0),
                this._processAnimations(),
                this._parseComplete())
              : this._nextBatch();
        });
      }
      _processFrames(e) {
        let t = e;
        const a = La.BATCH_SIZE;
        for (; t - e < a && t < this._frameKeys.length;) {
          const l = this._frameKeys[t],
            o = this._frames[l],
            h = o.frame;
          if (h) {
            let c = null,
              u = null;
            const d = o.trimmed !== !1 && o.sourceSize ? o.sourceSize : o.frame,
              f = new Le(
                0,
                0,
                Math.floor(d.w) / this.resolution,
                Math.floor(d.h) / this.resolution
              );
            o.rotated
              ? (c = new Le(
                Math.floor(h.x) / this.resolution,
                Math.floor(h.y) / this.resolution,
                Math.floor(h.h) / this.resolution,
                Math.floor(h.w) / this.resolution
              ))
              : (c = new Le(
                Math.floor(h.x) / this.resolution,
                Math.floor(h.y) / this.resolution,
                Math.floor(h.w) / this.resolution,
                Math.floor(h.h) / this.resolution
              )),
              o.trimmed !== !1 &&
              o.spriteSourceSize &&
              (u = new Le(
                Math.floor(o.spriteSourceSize.x) / this.resolution,
                Math.floor(o.spriteSourceSize.y) / this.resolution,
                Math.floor(h.w) / this.resolution,
                Math.floor(h.h) / this.resolution
              )),
              (this.textures[l] = new te({
                source: this.textureSource,
                frame: c,
                orig: f,
                trim: u,
                rotate: o.rotated ? 2 : 0,
                defaultAnchor: o.anchor,
                defaultBorders: o.borders,
                label: l.toString(),
              }));
          }
          t++;
        }
      }
      _processAnimations() {
        const e = this.data.animations || {};
        for (const t in e) {
          this.animations[t] = [];
          for (let a = 0; a < e[t].length; a++) {
            const l = e[t][a];
            this.animations[t].push(this.textures[l]);
          }
        }
      }
      _parseComplete() {
        const e = this._callback;
        (this._callback = null),
          (this._batchIndex = 0),
          e.call(this, this.textures);
      }
      _nextBatch() {
        this._processFrames(this._batchIndex * La.BATCH_SIZE),
          this._batchIndex++,
          setTimeout(() => {
            this._batchIndex * La.BATCH_SIZE < this._frameKeys.length
              ? this._nextBatch()
              : (this._processAnimations(), this._parseComplete());
          }, 0);
      }
      destroy(e = !1) {
        for (const t in this.textures) this.textures[t].destroy();
        (this._frames = null),
          (this._frameKeys = null),
          (this.data = null),
          (this.textures = null),
          e && (this._texture?.destroy(), this.textureSource.destroy()),
          (this._texture = null),
          (this.textureSource = null),
          (this.linkedSheets = []);
      }
    };
  au.BATCH_SIZE = 1e3;
  let ou = au;
  const p0 = [
    "jpg",
    "png",
    "jpeg",
    "avif",
    "webp",
    "basis",
    "etc2",
    "bc7",
    "bc6h",
    "bc5",
    "bc4",
    "bc3",
    "bc2",
    "bc1",
    "eac",
    "astc",
  ];
  function lu(r, e, t) {
    const a = {};
    if (
      (r.forEach((l) => {
        a[l] = e;
      }),
        Object.keys(e.textures).forEach((l) => {
          a[`${e.cachePrefix}${l}`] = e.textures[l];
        }),
        !t)
    ) {
      const l = Ls.dirname(r[0]);
      e.linkedSheets.forEach((o, h) => {
        const c = lu([`${l}/${e.data.meta.related_multi_packs[h]}`], o, !0);
        Object.assign(a, c);
      });
    }
    return a;
  }
  const g0 = {
    extension: P.Asset,
    cache: {
      test: (r) => r instanceof ou,
      getCacheableAssets: (r, e) => lu(r, e, !1),
    },
    resolver: {
      extension: { type: P.ResolveParser, name: "resolveSpritesheet" },
      test: (r) => {
        const t = r.split("?")[0].split("."),
          a = t.pop(),
          l = t.pop();
        return a === "json" && p0.includes(l);
      },
      parse: (r) => {
        const e = r.split(".");
        return {
          resolution: parseFloat(Jr.RETINA_PREFIX.exec(r)?.[1] ?? "1"),
          format: e[e.length - 2],
          src: r,
        };
      },
    },
    loader: {
      name: "spritesheetLoader",
      id: "spritesheet",
      extension: {
        type: P.LoadParser,
        priority: or.Normal,
        name: "spritesheetLoader",
      },
      async testParse(r, e) {
        return Ls.extname(e.src).toLowerCase() === ".json" && !!r.frames;
      },
      async parse(r, e, t) {
        const {
          texture: a,
          imageFilename: l,
          textureOptions: o,
          cachePrefix: h,
        } = e?.data ?? {};
        let c = Ls.dirname(e.src);
        c && c.lastIndexOf("/") !== c.length - 1 && (c += "/");
        let u;
        if (a instanceof te) u = a;
        else {
          const p = Yl(c + (l ?? r.meta.image), e.src);
          u = (await t.load([{ src: p, data: o }]))[p];
        }
        const d = new ou({ texture: u.source, data: r, cachePrefix: h });
        await d.parse();
        const f = r?.meta?.related_multi_packs;
        if (Array.isArray(f)) {
          const p = [];
          for (const _ of f) {
            if (typeof _ != "string") continue;
            let m = c + _;
            e.data?.ignoreMultiPack ||
              ((m = Yl(m, e.src)),
                p.push(
                  t.load({
                    src: m,
                    data: { textureOptions: o, ignoreMultiPack: !0 },
                  })
                ));
          }
          const g = await Promise.all(p);
          (d.linkedSheets = g),
            g.forEach((_) => {
              _.linkedSheets = [d].concat(
                d.linkedSheets.filter((m) => m !== _)
              );
            });
        }
        return d;
      },
      async unload(r, e, t) {
        await t.unload(r.textureSource._sourceOrigin), r.destroy(!1);
      },
    },
  };
  ge.add(g0);
  class hu {
    constructor(e) {
      (this._lastTransform = ""),
        (this._observer = null),
        (this._tickerAttached = !1),
        (this.updateTranslation = () => {
          if (!this._canvas) return;
          const t = this._canvas.getBoundingClientRect(),
            a = this._canvas.width,
            l = this._canvas.height,
            o = (t.width / a) * this._renderer.resolution,
            h = (t.height / l) * this._renderer.resolution,
            c = t.left,
            u = t.top,
            d = `translate(${c}px, ${u}px) scale(${o}, ${h})`;
          d !== this._lastTransform &&
            ((this._domElement.style.transform = d), (this._lastTransform = d));
        }),
        (this._domElement = e.domElement),
        (this._renderer = e.renderer),
        !(
          globalThis.OffscreenCanvas &&
          this._renderer.canvas instanceof OffscreenCanvas
        ) && ((this._canvas = this._renderer.canvas), this._attachObserver());
    }
    get canvas() {
      return this._canvas;
    }
    ensureAttached() {
      !this._domElement.parentNode &&
        this._canvas.parentNode &&
        (this._canvas.parentNode.appendChild(this._domElement),
          this.updateTranslation());
    }
    _attachObserver() {
      "ResizeObserver" in globalThis
        ? (this._observer &&
          (this._observer.disconnect(), (this._observer = null)),
          (this._observer = new ResizeObserver((e) => {
            for (const t of e) {
              if (t.target !== this._canvas) continue;
              const a = this.canvas.width,
                l = this.canvas.height,
                o = (t.contentRect.width / a) * this._renderer.resolution,
                h = (t.contentRect.height / l) * this._renderer.resolution;
              (this._lastScaleX !== o || this._lastScaleY !== h) &&
                (this.updateTranslation(),
                  (this._lastScaleX = o),
                  (this._lastScaleY = h));
            }
          })),
          this._observer.observe(this._canvas))
        : this._tickerAttached ||
        Js.shared.add(this.updateTranslation, this, Qr.HIGH);
    }
    destroy() {
      this._observer
        ? (this._observer.disconnect(), (this._observer = null))
        : this._tickerAttached && Js.shared.remove(this.updateTranslation),
        (this._domElement = null),
        (this._renderer = null),
        (this._canvas = null),
        (this._tickerAttached = !1),
        (this._lastTransform = ""),
        (this._lastScaleX = null),
        (this._lastScaleY = null);
    }
  }
  class Fn {
    constructor(e) {
      (this.bubbles = !0),
        (this.cancelBubble = !0),
        (this.cancelable = !1),
        (this.composed = !1),
        (this.defaultPrevented = !1),
        (this.eventPhase = Fn.prototype.NONE),
        (this.propagationStopped = !1),
        (this.propagationImmediatelyStopped = !1),
        (this.layer = new Je()),
        (this.page = new Je()),
        (this.NONE = 0),
        (this.CAPTURING_PHASE = 1),
        (this.AT_TARGET = 2),
        (this.BUBBLING_PHASE = 3),
        (this.manager = e);
    }
    get layerX() {
      return this.layer.x;
    }
    get layerY() {
      return this.layer.y;
    }
    get pageX() {
      return this.page.x;
    }
    get pageY() {
      return this.page.y;
    }
    get data() {
      return this;
    }
    composedPath() {
      return (
        this.manager &&
        (!this.path || this.path[this.path.length - 1] !== this.target) &&
        (this.path = this.target
          ? this.manager.propagationPath(this.target)
          : []),
        this.path
      );
    }
    initEvent(e, t, a) {
      throw new Error(
        "initEvent() is a legacy DOM API. It is not implemented in the Federated Events API."
      );
    }
    initUIEvent(e, t, a, l, o) {
      throw new Error(
        "initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API."
      );
    }
    preventDefault() {
      this.nativeEvent instanceof Event &&
        this.nativeEvent.cancelable &&
        this.nativeEvent.preventDefault(),
        (this.defaultPrevented = !0);
    }
    stopImmediatePropagation() {
      this.propagationImmediatelyStopped = !0;
    }
    stopPropagation() {
      this.propagationStopped = !0;
    }
  }
  var $l = /iPhone/i,
    cu = /iPod/i,
    du = /iPad/i,
    uu = /\biOS-universal(?:.+)Mac\b/i,
    Kl = /\bAndroid(?:.+)Mobile\b/i,
    fu = /Android/i,
    en = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    to = /Silk/i,
    Xi = /Windows Phone/i,
    pu = /\bWindows(?:.+)ARM\b/i,
    gu = /BlackBerry/i,
    mu = /BB10/i,
    _u = /Opera Mini/i,
    yu = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    xu = /Mobile(?:.+)Firefox\b/i,
    vu = function (r) {
      return (
        typeof r < "u" &&
        r.platform === "MacIntel" &&
        typeof r.maxTouchPoints == "number" &&
        r.maxTouchPoints > 1 &&
        typeof MSStream > "u"
      );
    };
  function m0(r) {
    return function (e) {
      return e.test(r);
    };
  }
  function bu(r) {
    var e = { userAgent: "", platform: "", maxTouchPoints: 0 };
    !r && typeof navigator < "u"
      ? (e = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0,
      })
      : typeof r == "string"
        ? (e.userAgent = r)
        : r &&
        r.userAgent &&
        (e = {
          userAgent: r.userAgent,
          platform: r.platform,
          maxTouchPoints: r.maxTouchPoints || 0,
        });
    var t = e.userAgent,
      a = t.split("[FBAN");
    typeof a[1] < "u" && (t = a[0]),
      (a = t.split("Twitter")),
      typeof a[1] < "u" && (t = a[0]);
    var l = m0(t),
      o = {
        apple: {
          phone: l($l) && !l(Xi),
          ipod: l(cu),
          tablet: !l($l) && (l(du) || vu(e)) && !l(Xi),
          universal: l(uu),
          device: (l($l) || l(cu) || l(du) || l(uu) || vu(e)) && !l(Xi),
        },
        amazon: {
          phone: l(en),
          tablet: !l(en) && l(to),
          device: l(en) || l(to),
        },
        android: {
          phone: (!l(Xi) && l(en)) || (!l(Xi) && l(Kl)),
          tablet: !l(Xi) && !l(en) && !l(Kl) && (l(to) || l(fu)),
          device:
            (!l(Xi) && (l(en) || l(to) || l(Kl) || l(fu))) || l(/\bokhttp\b/i),
        },
        windows: { phone: l(Xi), tablet: l(pu), device: l(Xi) || l(pu) },
        other: {
          blackberry: l(gu),
          blackberry10: l(mu),
          opera: l(_u),
          firefox: l(xu),
          chrome: l(yu),
          device: l(gu) || l(mu) || l(_u) || l(xu) || l(yu),
        },
        any: !1,
        phone: !1,
        tablet: !1,
      };
    return (
      (o.any =
        o.apple.device ||
        o.android.device ||
        o.windows.device ||
        o.other.device),
      (o.phone = o.apple.phone || o.android.phone || o.windows.phone),
      (o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet),
      o
    );
  }
  const _0 = (bu.default ?? bu)(globalThis.navigator),
    y0 = 9,
    wu = 100,
    x0 = 0,
    v0 = 0,
    Su = 2,
    Mu = 1,
    b0 = -1e3,
    w0 = -1e3,
    S0 = 2,
    Zl = class Zm {
      constructor(e, t = _0) {
        (this._mobileInfo = t),
          (this.debug = !1),
          (this._activateOnTab = !0),
          (this._deactivateOnMouseMove = !0),
          (this._isActive = !1),
          (this._isMobileAccessibility = !1),
          (this._div = null),
          (this._pool = []),
          (this._renderId = 0),
          (this._children = []),
          (this._androidUpdateCount = 0),
          (this._androidUpdateFrequency = 500),
          (this._hookDiv = null),
          (t.tablet || t.phone) && this._createTouchHook(),
          (this._renderer = e);
      }
      get isActive() {
        return this._isActive;
      }
      get isMobileAccessibility() {
        return this._isMobileAccessibility;
      }
      get hookDiv() {
        return this._hookDiv;
      }
      _createTouchHook() {
        const e = document.createElement("button");
        (e.style.width = `${Mu}px`),
          (e.style.height = `${Mu}px`),
          (e.style.position = "absolute"),
          (e.style.top = `${b0}px`),
          (e.style.left = `${w0}px`),
          (e.style.zIndex = S0.toString()),
          (e.style.backgroundColor = "#FF0000"),
          (e.title = "select to enable accessibility for this content"),
          e.addEventListener("focus", () => {
            (this._isMobileAccessibility = !0),
              this._activate(),
              this._destroyTouchHook();
          }),
          document.body.appendChild(e),
          (this._hookDiv = e);
      }
      _destroyTouchHook() {
        this._hookDiv &&
          (document.body.removeChild(this._hookDiv), (this._hookDiv = null));
      }
      _activate() {
        if (this._isActive) return;
        (this._isActive = !0),
          this._div ||
          ((this._div = document.createElement("div")),
            (this._div.style.position = "absolute"),
            (this._div.style.top = `${x0}px`),
            (this._div.style.left = `${v0}px`),
            (this._div.style.pointerEvents = "none"),
            (this._div.style.zIndex = Su.toString()),
            (this._canvasObserver = new hu({
              domElement: this._div,
              renderer: this._renderer,
            }))),
          this._activateOnTab &&
          ((this._onKeyDown = this._onKeyDown.bind(this)),
            globalThis.addEventListener("keydown", this._onKeyDown, !1)),
          this._deactivateOnMouseMove &&
          ((this._onMouseMove = this._onMouseMove.bind(this)),
            globalThis.document.addEventListener(
              "mousemove",
              this._onMouseMove,
              !0
            ));
        const e = this._renderer.view.canvas;
        if (e.parentNode)
          this._canvasObserver.ensureAttached(), this._initAccessibilitySetup();
        else {
          const t = new MutationObserver(() => {
            e.parentNode &&
              (t.disconnect(),
                this._canvasObserver.ensureAttached(),
                this._initAccessibilitySetup());
          });
          t.observe(document.body, { childList: !0, subtree: !0 });
        }
      }
      _initAccessibilitySetup() {
        this._renderer.runners.postrender.add(this),
          this._renderer.lastObjectRendered &&
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
      }
      _deactivate() {
        if (!(!this._isActive || this._isMobileAccessibility)) {
          (this._isActive = !1),
            globalThis.document.removeEventListener(
              "mousemove",
              this._onMouseMove,
              !0
            ),
            this._activateOnTab &&
            globalThis.addEventListener("keydown", this._onKeyDown, !1),
            this._renderer.runners.postrender.remove(this);
          for (const e of this._children)
            e._accessibleDiv &&
              e._accessibleDiv.parentNode &&
              (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv),
                (e._accessibleDiv = null)),
              (e._accessibleActive = !1);
          this._pool.forEach((e) => {
            e.parentNode && e.parentNode.removeChild(e);
          }),
            this._div &&
            this._div.parentNode &&
            this._div.parentNode.removeChild(this._div),
            (this._pool = []),
            (this._children = []);
        }
      }
      _updateAccessibleObjects(e) {
        if (!e.visible || !e.accessibleChildren) return;
        e.accessible &&
          (e._accessibleActive || this._addChild(e),
            (e._renderId = this._renderId));
        const t = e.children;
        if (t)
          for (let a = 0; a < t.length; a++)
            this._updateAccessibleObjects(t[a]);
      }
      init(e) {
        const a = {
          accessibilityOptions: {
            ...Zm.defaultOptions,
            ...(e?.accessibilityOptions || {}),
          },
        };
        (this.debug = a.accessibilityOptions.debug),
          (this._activateOnTab = a.accessibilityOptions.activateOnTab),
          (this._deactivateOnMouseMove =
            a.accessibilityOptions.deactivateOnMouseMove),
          a.accessibilityOptions.enabledByDefault
            ? this._activate()
            : this._activateOnTab &&
            ((this._onKeyDown = this._onKeyDown.bind(this)),
              globalThis.addEventListener("keydown", this._onKeyDown, !1)),
          this._renderer.runners.postrender.remove(this);
      }
      postrender() {
        const e = performance.now();
        if (
          (this._mobileInfo.android.device && e < this._androidUpdateCount) ||
          ((this._androidUpdateCount = e + this._androidUpdateFrequency),
            !this._renderer.renderingToScreen || !this._renderer.view.canvas)
        )
          return;
        const t = new Set();
        if (this._renderer.lastObjectRendered) {
          this._updateAccessibleObjects(this._renderer.lastObjectRendered);
          for (const a of this._children)
            a._renderId === this._renderId && t.add(this._children.indexOf(a));
        }
        for (let a = this._children.length - 1; a >= 0; a--) {
          const l = this._children[a];
          t.has(a) ||
            (l._accessibleDiv &&
              l._accessibleDiv.parentNode &&
              (l._accessibleDiv.parentNode.removeChild(l._accessibleDiv),
                this._pool.push(l._accessibleDiv),
                (l._accessibleDiv = null)),
              (l._accessibleActive = !1),
              zd(this._children, a, 1));
        }
        this._renderer.renderingToScreen &&
          this._canvasObserver.ensureAttached();
        for (let a = 0; a < this._children.length; a++) {
          const l = this._children[a];
          if (!l._accessibleActive || !l._accessibleDiv) continue;
          const o = l._accessibleDiv,
            h = l.hitArea || l.getBounds().rectangle;
          if (l.hitArea) {
            const c = l.worldTransform;
            (o.style.left = `${c.tx + h.x * c.a}px`),
              (o.style.top = `${c.ty + h.y * c.d}px`),
              (o.style.width = `${h.width * c.a}px`),
              (o.style.height = `${h.height * c.d}px`);
          } else
            this._capHitArea(h),
              (o.style.left = `${h.x}px`),
              (o.style.top = `${h.y}px`),
              (o.style.width = `${h.width}px`),
              (o.style.height = `${h.height}px`);
        }
        this._renderId++;
      }
      _updateDebugHTML(e) {
        e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`;
      }
      _capHitArea(e) {
        e.x < 0 && ((e.width += e.x), (e.x = 0)),
          e.y < 0 && ((e.height += e.y), (e.y = 0));
        const { width: t, height: a } = this._renderer;
        e.x + e.width > t && (e.width = t - e.x),
          e.y + e.height > a && (e.height = a - e.y);
      }
      _addChild(e) {
        let t = this._pool.pop();
        t ||
          (e.accessibleType === "button"
            ? (t = document.createElement("button"))
            : ((t = document.createElement(e.accessibleType)),
              (t.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `),
              e.accessibleText && (t.innerText = e.accessibleText)),
            (t.style.width = `${wu}px`),
            (t.style.height = `${wu}px`),
            (t.style.backgroundColor = this.debug
              ? "rgba(255,255,255,0.5)"
              : "transparent"),
            (t.style.position = "absolute"),
            (t.style.zIndex = Su.toString()),
            (t.style.borderStyle = "none"),
            navigator.userAgent.toLowerCase().includes("chrome")
              ? t.setAttribute("aria-live", "off")
              : t.setAttribute("aria-live", "polite"),
            navigator.userAgent.match(/rv:.*Gecko\//)
              ? t.setAttribute("aria-relevant", "additions")
              : t.setAttribute("aria-relevant", "text"),
            t.addEventListener("click", this._onClick.bind(this)),
            t.addEventListener("focus", this._onFocus.bind(this)),
            t.addEventListener("focusout", this._onFocusOut.bind(this))),
          (t.style.pointerEvents = e.accessiblePointerEvents),
          (t.type = e.accessibleType),
          e.accessibleTitle && e.accessibleTitle !== null
            ? (t.title = e.accessibleTitle)
            : (!e.accessibleHint || e.accessibleHint === null) &&
            (t.title = `container ${e.tabIndex}`),
          e.accessibleHint &&
          e.accessibleHint !== null &&
          t.setAttribute("aria-label", e.accessibleHint),
          e.interactive ? (t.tabIndex = e.tabIndex) : (t.tabIndex = 0),
          this.debug && this._updateDebugHTML(t),
          (e._accessibleActive = !0),
          (e._accessibleDiv = t),
          (t.container = e),
          this._children.push(e),
          this._div.appendChild(e._accessibleDiv);
      }
      _dispatchEvent(e, t) {
        const { container: a } = e.target,
          l = this._renderer.events.rootBoundary,
          o = Object.assign(new Fn(l), { target: a });
        (l.rootTarget = this._renderer.lastObjectRendered),
          t.forEach((h) => l.dispatchEvent(o, h));
      }
      _onClick(e) {
        this._dispatchEvent(e, ["click", "pointertap", "tap"]);
      }
      _onFocus(e) {
        e.target.getAttribute("aria-live") ||
          e.target.setAttribute("aria-live", "assertive"),
          this._dispatchEvent(e, ["mouseover"]);
      }
      _onFocusOut(e) {
        e.target.getAttribute("aria-live") ||
          e.target.setAttribute("aria-live", "polite"),
          this._dispatchEvent(e, ["mouseout"]);
      }
      _onKeyDown(e) {
        e.keyCode !== y0 || !this._activateOnTab || this._activate();
      }
      _onMouseMove(e) {
        (e.movementX === 0 && e.movementY === 0) || this._deactivate();
      }
      destroy() {
        this._deactivate(),
          this._destroyTouchHook(),
          this._canvasObserver?.destroy(),
          (this._canvasObserver = null),
          (this._div = null),
          (this._pool = null),
          (this._children = null),
          (this._renderer = null),
          this._activateOnTab &&
          globalThis.removeEventListener("keydown", this._onKeyDown);
      }
      setAccessibilityEnabled(e) {
        e ? this._activate() : this._deactivate();
      }
    };
  (Zl.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem],
    name: "accessibility",
  }),
    (Zl.defaultOptions = {
      enabledByDefault: !1,
      debug: !1,
      activateOnTab: !0,
      deactivateOnMouseMove: !0,
    });
  let M0 = Zl;
  const T0 = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    accessibleType: "button",
    accessibleText: null,
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    _renderId: -1,
  },
    Ql = Object.create(null),
    Tu = Object.create(null);
  function Gn(r, e) {
    let t = Tu[r];
    return (
      t === void 0 && (Ql[e] === void 0 && (Ql[e] = 1), (Tu[r] = t = Ql[e]++)),
      t
    );
  }
  let so;
  function Cu() {
    return (
      (!so || so?.isContextLost()) &&
      (so = xe.get().createCanvas().getContext("webgl", {})),
      so
    );
  }
  let io;
  function C0() {
    if (!io) {
      io = "mediump";
      const r = Cu();
      r &&
        r.getShaderPrecisionFormat &&
        (io = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT)
          .precision
          ? "highp"
          : "mediump");
    }
    return io;
  }
  function A0(r, e, t) {
    return e
      ? r
      : t
        ? ((r = r.replace("out vec4 finalColor;", "")),
          `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${r}
        `)
        : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${r}
        `;
  }
  function P0(r, e, t) {
    const a = t
      ? e.maxSupportedFragmentPrecision
      : e.maxSupportedVertexPrecision;
    if (r.substring(0, 9) !== "precision") {
      let l = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
      return (
        l === "highp" && a !== "highp" && (l = "mediump"),
        `precision ${l} float;
${r}`
      );
    } else if (a !== "highp" && r.substring(0, 15) === "precision highp")
      return r.replace("precision highp", "precision mediump");
    return r;
  }
  function E0(r, e) {
    return e
      ? `#version 300 es
${r}`
      : r;
  }
  const k0 = {},
    R0 = {};
  function I0(r, { name: e = "pixi-program" }, t = !0) {
    (e = e.replace(/\s+/g, "-")), (e += t ? "-fragment" : "-vertex");
    const a = t ? k0 : R0;
    return (
      a[e] ? (a[e]++, (e += `-${a[e]}`)) : (a[e] = 1),
      r.indexOf("#define SHADER_NAME") !== -1
        ? r
        : `${`#define SHADER_NAME ${e}`}
${r}`
    );
  }
  function B0(r, e) {
    return e ? r.replace("#version 300 es", "") : r;
  }
  const Jl = {
    stripVersion: B0,
    ensurePrecision: P0,
    addProgramDefines: A0,
    setProgramName: I0,
    insertVersion: E0,
  },
    Dn = Object.create(null),
    Au = class ad {
      constructor(e) {
        e = { ...ad.defaultOptions, ...e };
        const t = e.fragment.indexOf("#version 300 es") !== -1,
          a = {
            stripVersion: t,
            ensurePrecision: {
              requestedFragmentPrecision: e.preferredFragmentPrecision,
              requestedVertexPrecision: e.preferredVertexPrecision,
              maxSupportedVertexPrecision: "highp",
              maxSupportedFragmentPrecision: C0(),
            },
            setProgramName: { name: e.name },
            addProgramDefines: t,
            insertVersion: t,
          };
        let l = e.fragment,
          o = e.vertex;
        Object.keys(Jl).forEach((h) => {
          const c = a[h];
          (l = Jl[h](l, c, !0)), (o = Jl[h](o, c, !1));
        }),
          (this.fragment = l),
          (this.vertex = o),
          (this.transformFeedbackVaryings = e.transformFeedbackVaryings),
          (this._key = Gn(`${this.vertex}:${this.fragment}`, "gl-program"));
      }
      destroy() {
        (this.fragment = null),
          (this.vertex = null),
          (this._attributeData = null),
          (this._uniformData = null),
          (this._uniformBlockData = null),
          (this.transformFeedbackVaryings = null),
          (Dn[this._cacheKey] = null);
      }
      static from(e) {
        const t = `${e.vertex}:${e.fragment}`;
        return Dn[t] || ((Dn[t] = new ad(e)), (Dn[t]._cacheKey = t)), Dn[t];
      }
    };
  Au.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump",
  };
  let tn = Au;
  const Pu = {
    uint8x2: { size: 2, stride: 2, normalised: !1 },
    uint8x4: { size: 4, stride: 4, normalised: !1 },
    sint8x2: { size: 2, stride: 2, normalised: !1 },
    sint8x4: { size: 4, stride: 4, normalised: !1 },
    unorm8x2: { size: 2, stride: 2, normalised: !0 },
    unorm8x4: { size: 4, stride: 4, normalised: !0 },
    snorm8x2: { size: 2, stride: 2, normalised: !0 },
    snorm8x4: { size: 4, stride: 4, normalised: !0 },
    uint16x2: { size: 2, stride: 4, normalised: !1 },
    uint16x4: { size: 4, stride: 8, normalised: !1 },
    sint16x2: { size: 2, stride: 4, normalised: !1 },
    sint16x4: { size: 4, stride: 8, normalised: !1 },
    unorm16x2: { size: 2, stride: 4, normalised: !0 },
    unorm16x4: { size: 4, stride: 8, normalised: !0 },
    snorm16x2: { size: 2, stride: 4, normalised: !0 },
    snorm16x4: { size: 4, stride: 8, normalised: !0 },
    float16x2: { size: 2, stride: 4, normalised: !1 },
    float16x4: { size: 4, stride: 8, normalised: !1 },
    float32: { size: 1, stride: 4, normalised: !1 },
    float32x2: { size: 2, stride: 8, normalised: !1 },
    float32x3: { size: 3, stride: 12, normalised: !1 },
    float32x4: { size: 4, stride: 16, normalised: !1 },
    uint32: { size: 1, stride: 4, normalised: !1 },
    uint32x2: { size: 2, stride: 8, normalised: !1 },
    uint32x3: { size: 3, stride: 12, normalised: !1 },
    uint32x4: { size: 4, stride: 16, normalised: !1 },
    sint32: { size: 1, stride: 4, normalised: !1 },
    sint32x2: { size: 2, stride: 8, normalised: !1 },
    sint32x3: { size: 3, stride: 12, normalised: !1 },
    sint32x4: { size: 4, stride: 16, normalised: !1 },
  };
  function lr(r) {
    return Pu[r] ?? Pu.float32;
  }
  const F0 = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4",
  };
  function G0({ source: r, entryPoint: e }) {
    const t = {},
      a = r.indexOf(`fn ${e}`);
    if (a !== -1) {
      const l = r.indexOf("->", a);
      if (l !== -1) {
        const o = r.substring(a, l),
          h =
            /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
        let c;
        for (; (c = h.exec(o)) !== null;) {
          const u = F0[c[3]] ?? "float32";
          t[c[2]] = {
            location: parseInt(c[1], 10),
            format: u,
            stride: lr(u).stride,
            offset: 0,
            instance: !1,
            start: 0,
          };
        }
      }
    }
    return t;
  }
  function eh(r) {
    const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
      t = /@group\((\d+)\)/,
      a = /@binding\((\d+)\)/,
      l = /var(<[^>]+>)? (\w+)/,
      o = /:\s*(\w+)/,
      h = /struct\s+(\w+)\s*{([^}]+)}/g,
      c = /(\w+)\s*:\s*([\w\<\>]+)/g,
      u = /struct\s+(\w+)/,
      d = r
        .match(e)
        ?.map((p) => ({
          group: parseInt(p.match(t)[1], 10),
          binding: parseInt(p.match(a)[1], 10),
          name: p.match(l)[2],
          isUniform: p.match(l)[1] === "<uniform>",
          type: p.match(o)[1],
        }));
    if (!d) return { groups: [], structs: [] };
    const f =
      r
        .match(h)
        ?.map((p) => {
          const g = p.match(u)[1],
            _ = p.match(c).reduce((m, w) => {
              const [x, M] = w.split(":");
              return (m[x.trim()] = M.trim()), m;
            }, {});
          return _ ? { name: g, members: _ } : null;
        })
        .filter(({ name: p }) => d.some((g) => g.type === p)) ?? [];
    return { groups: d, structs: f };
  }
  var Un = ((r) => (
    (r[(r.VERTEX = 1)] = "VERTEX"),
    (r[(r.FRAGMENT = 2)] = "FRAGMENT"),
    (r[(r.COMPUTE = 4)] = "COMPUTE"),
    r
  ))(Un || {});
  function D0({ groups: r }) {
    const e = [];
    for (let t = 0; t < r.length; t++) {
      const a = r[t];
      e[a.group] || (e[a.group] = []),
        a.isUniform
          ? e[a.group].push({
            binding: a.binding,
            visibility: Un.VERTEX | Un.FRAGMENT,
            buffer: { type: "uniform" },
          })
          : a.type === "sampler"
            ? e[a.group].push({
              binding: a.binding,
              visibility: Un.FRAGMENT,
              sampler: { type: "filtering" },
            })
            : a.type === "texture_2d" &&
            e[a.group].push({
              binding: a.binding,
              visibility: Un.FRAGMENT,
              texture: {
                sampleType: "float",
                viewDimension: "2d",
                multisampled: !1,
              },
            });
    }
    return e;
  }
  function U0({ groups: r }) {
    const e = [];
    for (let t = 0; t < r.length; t++) {
      const a = r[t];
      e[a.group] || (e[a.group] = {}), (e[a.group][a.name] = a.binding);
    }
    return e;
  }
  function O0(r, e) {
    const t = new Set(),
      a = new Set(),
      l = [...r.structs, ...e.structs].filter((h) =>
        t.has(h.name) ? !1 : (t.add(h.name), !0)
      ),
      o = [...r.groups, ...e.groups].filter((h) => {
        const c = `${h.name}-${h.binding}`;
        return a.has(c) ? !1 : (a.add(c), !0);
      });
    return { structs: l, groups: o };
  }
  const On = Object.create(null);
  class Ir {
    constructor(e) {
      (this._layoutKey = 0), (this._attributeLocationsKey = 0);
      const { fragment: t, vertex: a, layout: l, gpuLayout: o, name: h } = e;
      if (
        ((this.name = h),
          (this.fragment = t),
          (this.vertex = a),
          t.source === a.source)
      ) {
        const c = eh(t.source);
        this.structsAndGroups = c;
      } else {
        const c = eh(a.source),
          u = eh(t.source);
        this.structsAndGroups = O0(c, u);
      }
      (this.layout = l ?? U0(this.structsAndGroups)),
        (this.gpuLayout = o ?? D0(this.structsAndGroups)),
        (this.autoAssignGlobalUniforms =
          this.layout[0]?.globalUniforms !== void 0),
        (this.autoAssignLocalUniforms =
          this.layout[1]?.localUniforms !== void 0),
        this._generateProgramKey();
    }
    _generateProgramKey() {
      const { vertex: e, fragment: t } = this,
        a = e.source + t.source + e.entryPoint + t.entryPoint;
      this._layoutKey = Gn(a, "program");
    }
    get attributeData() {
      return (
        this._attributeData ?? (this._attributeData = G0(this.vertex)),
        this._attributeData
      );
    }
    destroy() {
      (this.gpuLayout = null),
        (this.layout = null),
        (this.structsAndGroups = null),
        (this.fragment = null),
        (this.vertex = null),
        (On[this._cacheKey] = null);
    }
    static from(e) {
      const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
      return On[t] || ((On[t] = new Ir(e)), (On[t]._cacheKey = t)), On[t];
    }
  }
  const Eu = [
    "f32",
    "i32",
    "vec2<f32>",
    "vec3<f32>",
    "vec4<f32>",
    "mat2x2<f32>",
    "mat3x3<f32>",
    "mat4x4<f32>",
    "mat3x2<f32>",
    "mat4x2<f32>",
    "mat2x3<f32>",
    "mat4x3<f32>",
    "mat2x4<f32>",
    "mat3x4<f32>",
    "vec2<i32>",
    "vec3<i32>",
    "vec4<i32>",
  ],
    L0 = Eu.reduce((r, e) => ((r[e] = !0), r), {});
  function N0(r, e) {
    switch (r) {
      case "f32":
        return 0;
      case "vec2<f32>":
        return new Float32Array(2 * e);
      case "vec3<f32>":
        return new Float32Array(3 * e);
      case "vec4<f32>":
        return new Float32Array(4 * e);
      case "mat2x2<f32>":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3x3<f32>":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4x4<f32>":
        return new Float32Array([
          1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]);
    }
    return null;
  }
  const ku = class Qm {
    constructor(e, t) {
      (this._touched = 0),
        (this.uid = et("uniform")),
        (this._resourceType = "uniformGroup"),
        (this._resourceId = et("resource")),
        (this.isUniformGroup = !0),
        (this._dirtyId = 0),
        (this.destroyed = !1),
        (t = { ...Qm.defaultOptions, ...t }),
        (this.uniformStructures = e);
      const a = {};
      for (const l in e) {
        const o = e[l];
        if (((o.name = l), (o.size = o.size ?? 1), !L0[o.type])) {
          const h = o.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
          if (h) {
            const [, c, u] = h;
            throw new Error(
              `Uniform type ${o.type} is not supported. Use type: '${c}', size: ${u} instead.`
            );
          }
          throw new Error(
            `Uniform type ${o.type
            } is not supported. Supported uniform types are: ${Eu.join(", ")}`
          );
        }
        o.value ?? (o.value = N0(o.type, o.size)), (a[l] = o.value);
      }
      (this.uniforms = a),
        (this._dirtyId = 1),
        (this.ubo = t.ubo),
        (this.isStatic = t.isStatic),
        (this._signature = Gn(
          Object.keys(a)
            .map((l) => `${l}-${e[l].type}`)
            .join("-"),
          "uniform-group"
        ));
    }
    update() {
      this._dirtyId++;
    }
  };
  ku.defaultOptions = { ubo: !1, isStatic: !1 };
  let ys = ku;
  class qi {
    constructor(e) {
      (this.resources = Object.create(null)), (this._dirty = !0);
      let t = 0;
      for (const a in e) {
        const l = e[a];
        this.setResource(l, t++);
      }
      this._updateKey();
    }
    _updateKey() {
      if (!this._dirty) return;
      this._dirty = !1;
      const e = [];
      let t = 0;
      for (const a in this.resources) e[t++] = this.resources[a]._resourceId;
      this._key = e.join("|");
    }
    setResource(e, t) {
      const a = this.resources[t];
      e !== a &&
        (a && e.off?.("change", this.onResourceChange, this),
          e.on?.("change", this.onResourceChange, this),
          (this.resources[t] = e),
          (this._dirty = !0));
    }
    getResource(e) {
      return this.resources[e];
    }
    _touch(e) {
      const t = this.resources;
      for (const a in t) t[a]._touched = e;
    }
    destroy() {
      const e = this.resources;
      for (const t in e) e[t]?.off?.("change", this.onResourceChange, this);
      this.resources = null;
    }
    onResourceChange(e) {
      if (((this._dirty = !0), e.destroyed)) {
        const t = this.resources;
        for (const a in t) t[a] === e && (t[a] = null);
      } else this._updateKey();
    }
  }
  var pi = ((r) => (
    (r[(r.WEBGL = 1)] = "WEBGL"),
    (r[(r.WEBGPU = 2)] = "WEBGPU"),
    (r[(r.BOTH = 3)] = "BOTH"),
    r
  ))(pi || {});
  class ei extends Os {
    constructor(e) {
      super(),
        (this.uid = et("shader")),
        (this._uniformBindMap = Object.create(null)),
        (this._ownedBindGroups = []);
      let {
        gpuProgram: t,
        glProgram: a,
        groups: l,
        resources: o,
        compatibleRenderers: h,
        groupMap: c,
      } = e;
      (this.gpuProgram = t),
        (this.glProgram = a),
        h === void 0 && ((h = 0), t && (h |= pi.WEBGPU), a && (h |= pi.WEBGL)),
        (this.compatibleRenderers = h);
      const u = {};
      if ((!o && !l && (o = {}), o && l))
        throw new Error("[Shader] Cannot have both resources and groups");
      if (!t && l && !c)
        throw new Error(
          "[Shader] No group map or WebGPU shader provided - consider using resources instead."
        );
      if (!t && l && c)
        for (const d in c)
          for (const f in c[d]) {
            const p = c[d][f];
            u[p] = { group: d, binding: f, name: p };
          }
      else if (t && l && !c) {
        const d = t.structsAndGroups.groups;
        (c = {}),
          d.forEach((f) => {
            (c[f.group] = c[f.group] || {}),
              (c[f.group][f.binding] = f.name),
              (u[f.name] = f);
          });
      } else if (o) {
        (l = {}),
          (c = {}),
          t &&
          t.structsAndGroups.groups.forEach((p) => {
            (c[p.group] = c[p.group] || {}),
              (c[p.group][p.binding] = p.name),
              (u[p.name] = p);
          });
        let d = 0;
        for (const f in o)
          u[f] ||
            (l[99] || ((l[99] = new qi()), this._ownedBindGroups.push(l[99])),
              (u[f] = { group: 99, binding: d, name: f }),
              (c[99] = c[99] || {}),
              (c[99][d] = f),
              d++);
        for (const f in o) {
          const p = f;
          let g = o[f];
          !g.source && !g._resourceType && (g = new ys(g));
          const _ = u[p];
          _ &&
            (l[_.group] ||
              ((l[_.group] = new qi()), this._ownedBindGroups.push(l[_.group])),
              l[_.group].setResource(g, _.binding));
        }
      }
      (this.groups = l),
        (this._uniformBindMap = c),
        (this.resources = this._buildResourceAccessor(l, u));
    }
    addResource(e, t, a) {
      var l, o;
      (l = this._uniformBindMap)[t] || (l[t] = {}),
        (o = this._uniformBindMap[t])[a] || (o[a] = e),
        this.groups[t] ||
        ((this.groups[t] = new qi()),
          this._ownedBindGroups.push(this.groups[t]));
    }
    _buildResourceAccessor(e, t) {
      const a = {};
      for (const l in t) {
        const o = t[l];
        Object.defineProperty(a, o.name, {
          get() {
            return e[o.group].getResource(o.binding);
          },
          set(h) {
            e[o.group].setResource(h, o.binding);
          },
        });
      }
      return a;
    }
    destroy(e = !1) {
      this.emit("destroy", this),
        e && (this.gpuProgram?.destroy(), this.glProgram?.destroy()),
        (this.gpuProgram = null),
        (this.glProgram = null),
        this.removeAllListeners(),
        (this._uniformBindMap = null),
        this._ownedBindGroups.forEach((t) => {
          t.destroy();
        }),
        (this._ownedBindGroups = null),
        (this.resources = null),
        (this.groups = null);
    }
    static from(e) {
      const { gpu: t, gl: a, ...l } = e;
      let o, h;
      return (
        t && (o = Ir.from(t)),
        a && (h = tn.from(a)),
        new ei({ gpuProgram: o, glProgram: h, ...l })
      );
    }
  }
  const H0 = {
    normal: 0,
    add: 1,
    multiply: 2,
    screen: 3,
    overlay: 4,
    erase: 5,
    "normal-npm": 6,
    "add-npm": 7,
    "screen-npm": 8,
    min: 9,
    max: 10,
  },
    th = 0,
    sh = 1,
    ih = 2,
    rh = 3,
    nh = 4,
    ah = 5,
    oh = class Jm {
      constructor() {
        (this.data = 0),
          (this.blendMode = "normal"),
          (this.polygonOffset = 0),
          (this.blend = !0),
          (this.depthMask = !0);
      }
      get blend() {
        return !!(this.data & (1 << th));
      }
      set blend(e) {
        !!(this.data & (1 << th)) !== e && (this.data ^= 1 << th);
      }
      get offsets() {
        return !!(this.data & (1 << sh));
      }
      set offsets(e) {
        !!(this.data & (1 << sh)) !== e && (this.data ^= 1 << sh);
      }
      set cullMode(e) {
        if (e === "none") {
          this.culling = !1;
          return;
        }
        (this.culling = !0), (this.clockwiseFrontFace = e === "front");
      }
      get cullMode() {
        return this.culling
          ? this.clockwiseFrontFace
            ? "front"
            : "back"
          : "none";
      }
      get culling() {
        return !!(this.data & (1 << ih));
      }
      set culling(e) {
        !!(this.data & (1 << ih)) !== e && (this.data ^= 1 << ih);
      }
      get depthTest() {
        return !!(this.data & (1 << rh));
      }
      set depthTest(e) {
        !!(this.data & (1 << rh)) !== e && (this.data ^= 1 << rh);
      }
      get depthMask() {
        return !!(this.data & (1 << ah));
      }
      set depthMask(e) {
        !!(this.data & (1 << ah)) !== e && (this.data ^= 1 << ah);
      }
      get clockwiseFrontFace() {
        return !!(this.data & (1 << nh));
      }
      set clockwiseFrontFace(e) {
        !!(this.data & (1 << nh)) !== e && (this.data ^= 1 << nh);
      }
      get blendMode() {
        return this._blendMode;
      }
      set blendMode(e) {
        (this.blend = e !== "none"),
          (this._blendMode = e),
          (this._blendModeId = H0[e] || 0);
      }
      get polygonOffset() {
        return this._polygonOffset;
      }
      set polygonOffset(e) {
        (this.offsets = !!e), (this._polygonOffset = e);
      }
      toString() {
        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
      }
      static for2d() {
        const e = new Jm();
        return (e.depthTest = !1), (e.blend = !0), e;
      }
    };
  oh.default2d = oh.for2d();
  let gi = oh;
  const Ru = class od extends ei {
    constructor(e) {
      (e = { ...od.defaultOptions, ...e }),
        super(e),
        (this.enabled = !0),
        (this._state = gi.for2d()),
        (this.blendMode = e.blendMode),
        (this.padding = e.padding),
        typeof e.antialias == "boolean"
          ? (this.antialias = e.antialias ? "on" : "off")
          : (this.antialias = e.antialias),
        (this.resolution = e.resolution),
        (this.blendRequired = e.blendRequired),
        (this.clipToViewport = e.clipToViewport),
        this.addResource("uTexture", 0, 1);
    }
    apply(e, t, a, l) {
      e.applyFilter(this, t, a, l);
    }
    get blendMode() {
      return this._state.blendMode;
    }
    set blendMode(e) {
      this._state.blendMode = e;
    }
    static from(e) {
      const { gpu: t, gl: a, ...l } = e;
      let o, h;
      return (
        t && (o = Ir.from(t)),
        a && (h = tn.from(a)),
        new od({ gpuProgram: o, glProgram: h, ...l })
      );
    }
  };
  Ru.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: !1,
    clipToViewport: !0,
  };
  let z0 = Ru;
  const ch = [];
  ge.handleByNamedList(P.Environment, ch);
  async function W0(r) {
    if (!r)
      for (let e = 0; e < ch.length; e++) {
        const t = ch[e];
        if (t.value.test()) {
          await t.value.load();
          return;
        }
      }
  }
  let Ln;
  function Iu() {
    if (typeof Ln == "boolean") return Ln;
    try {
      Ln =
        new Function(
          "param1",
          "param2",
          "param3",
          "return param1[param2] === param3;"
        )({ a: "b" }, "a", "b") === !0;
    } catch {
      Ln = !1;
    }
    return Ln;
  }
  function Bu(r, e, t = 2) {
    const a = e && e.length,
      l = a ? e[0] * t : r.length;
    let o = Fu(r, 0, l, t, !0);
    const h = [];
    if (!o || o.next === o.prev) return h;
    let c, u, d;
    if ((a && (o = Y0(r, e, o, t)), r.length > 80 * t)) {
      (c = r[0]), (u = r[1]);
      let f = c,
        p = u;
      for (let g = t; g < l; g += t) {
        const _ = r[g],
          m = r[g + 1];
        _ < c && (c = _), m < u && (u = m), _ > f && (f = _), m > p && (p = m);
      }
      (d = Math.max(f - c, p - u)), (d = d !== 0 ? 32767 / d : 0);
    }
    return Nn(o, h, t, c, u, d, 0), h;
  }
  function Fu(r, e, t, a, l) {
    let o;
    if (l === n_(r, e, t, a) > 0)
      for (let h = e; h < t; h += a) o = Ou((h / a) | 0, r[h], r[h + 1], o);
    else
      for (let h = t - a; h >= e; h -= a)
        o = Ou((h / a) | 0, r[h], r[h + 1], o);
    return o && sn(o, o.next) && (Wn(o), (o = o.next)), o;
  }
  function Br(r, e) {
    if (!r) return r;
    e || (e = r);
    let t = r,
      a;
    do
      if (
        ((a = !1), !t.steiner && (sn(t, t.next) || vt(t.prev, t, t.next) === 0))
      ) {
        if ((Wn(t), (t = e = t.prev), t === t.next)) break;
        a = !0;
      } else t = t.next;
    while (a || t !== e);
    return e;
  }
  function Nn(r, e, t, a, l, o, h) {
    if (!r) return;
    !h && o && J0(r, a, l, o);
    let c = r;
    for (; r.prev !== r.next;) {
      const u = r.prev,
        d = r.next;
      if (o ? j0(r, a, l, o) : V0(r)) {
        e.push(u.i, r.i, d.i), Wn(r), (r = d.next), (c = d.next);
        continue;
      }
      if (((r = d), r === c)) {
        h
          ? h === 1
            ? ((r = X0(Br(r), e)), Nn(r, e, t, a, l, o, 2))
            : h === 2 && q0(r, e, t, a, l, o)
          : Nn(Br(r), e, t, a, l, o, 1);
        break;
      }
    }
  }
  function V0(r) {
    const e = r.prev,
      t = r,
      a = r.next;
    if (vt(e, t, a) >= 0) return !1;
    const l = e.x,
      o = t.x,
      h = a.x,
      c = e.y,
      u = t.y,
      d = a.y,
      f = Math.min(l, o, h),
      p = Math.min(c, u, d),
      g = Math.max(l, o, h),
      _ = Math.max(c, u, d);
    let m = a.next;
    for (; m !== e;) {
      if (
        m.x >= f &&
        m.x <= g &&
        m.y >= p &&
        m.y <= _ &&
        Hn(l, c, o, u, h, d, m.x, m.y) &&
        vt(m.prev, m, m.next) >= 0
      )
        return !1;
      m = m.next;
    }
    return !0;
  }
  function j0(r, e, t, a) {
    const l = r.prev,
      o = r,
      h = r.next;
    if (vt(l, o, h) >= 0) return !1;
    const c = l.x,
      u = o.x,
      d = h.x,
      f = l.y,
      p = o.y,
      g = h.y,
      _ = Math.min(c, u, d),
      m = Math.min(f, p, g),
      w = Math.max(c, u, d),
      x = Math.max(f, p, g),
      M = dh(_, m, e, t, a),
      b = dh(w, x, e, t, a);
    let T = r.prevZ,
      C = r.nextZ;
    for (; T && T.z >= M && C && C.z <= b;) {
      if (
        (T.x >= _ &&
          T.x <= w &&
          T.y >= m &&
          T.y <= x &&
          T !== l &&
          T !== h &&
          Hn(c, f, u, p, d, g, T.x, T.y) &&
          vt(T.prev, T, T.next) >= 0) ||
        ((T = T.prevZ),
          C.x >= _ &&
          C.x <= w &&
          C.y >= m &&
          C.y <= x &&
          C !== l &&
          C !== h &&
          Hn(c, f, u, p, d, g, C.x, C.y) &&
          vt(C.prev, C, C.next) >= 0)
      )
        return !1;
      C = C.nextZ;
    }
    for (; T && T.z >= M;) {
      if (
        T.x >= _ &&
        T.x <= w &&
        T.y >= m &&
        T.y <= x &&
        T !== l &&
        T !== h &&
        Hn(c, f, u, p, d, g, T.x, T.y) &&
        vt(T.prev, T, T.next) >= 0
      )
        return !1;
      T = T.prevZ;
    }
    for (; C && C.z <= b;) {
      if (
        C.x >= _ &&
        C.x <= w &&
        C.y >= m &&
        C.y <= x &&
        C !== l &&
        C !== h &&
        Hn(c, f, u, p, d, g, C.x, C.y) &&
        vt(C.prev, C, C.next) >= 0
      )
        return !1;
      C = C.nextZ;
    }
    return !0;
  }
  function X0(r, e) {
    let t = r;
    do {
      const a = t.prev,
        l = t.next.next;
      !sn(a, l) &&
        Du(a, t, t.next, l) &&
        zn(a, l) &&
        zn(l, a) &&
        (e.push(a.i, t.i, l.i), Wn(t), Wn(t.next), (t = r = l)),
        (t = t.next);
    } while (t !== r);
    return Br(t);
  }
  function q0(r, e, t, a, l, o) {
    let h = r;
    do {
      let c = h.next.next;
      for (; c !== h.prev;) {
        if (h.i !== c.i && s_(h, c)) {
          let u = Uu(h, c);
          (h = Br(h, h.next)),
            (u = Br(u, u.next)),
            Nn(h, e, t, a, l, o, 0),
            Nn(u, e, t, a, l, o, 0);
          return;
        }
        c = c.next;
      }
      h = h.next;
    } while (h !== r);
  }
  function Y0(r, e, t, a) {
    const l = [];
    for (let o = 0, h = e.length; o < h; o++) {
      const c = e[o] * a,
        u = o < h - 1 ? e[o + 1] * a : r.length,
        d = Fu(r, c, u, a, !1);
      d === d.next && (d.steiner = !0), l.push(t_(d));
    }
    l.sort($0);
    for (let o = 0; o < l.length; o++) t = K0(l[o], t);
    return t;
  }
  function $0(r, e) {
    let t = r.x - e.x;
    if (t === 0 && ((t = r.y - e.y), t === 0)) {
      const a = (r.next.y - r.y) / (r.next.x - r.x),
        l = (e.next.y - e.y) / (e.next.x - e.x);
      t = a - l;
    }
    return t;
  }
  function K0(r, e) {
    const t = Z0(r, e);
    if (!t) return e;
    const a = Uu(t, r);
    return Br(a, a.next), Br(t, t.next);
  }
  function Z0(r, e) {
    let t = e;
    const a = r.x,
      l = r.y;
    let o = -1 / 0,
      h;
    if (sn(r, t)) return t;
    do {
      if (sn(r, t.next)) return t.next;
      if (l <= t.y && l >= t.next.y && t.next.y !== t.y) {
        const p = t.x + ((l - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
        if (
          p <= a &&
          p > o &&
          ((o = p), (h = t.x < t.next.x ? t : t.next), p === a)
        )
          return h;
      }
      t = t.next;
    } while (t !== e);
    if (!h) return null;
    const c = h,
      u = h.x,
      d = h.y;
    let f = 1 / 0;
    t = h;
    do {
      if (
        a >= t.x &&
        t.x >= u &&
        a !== t.x &&
        Gu(l < d ? a : o, l, u, d, l < d ? o : a, l, t.x, t.y)
      ) {
        const p = Math.abs(l - t.y) / (a - t.x);
        zn(t, r) &&
          (p < f || (p === f && (t.x > h.x || (t.x === h.x && Q0(h, t))))) &&
          ((h = t), (f = p));
      }
      t = t.next;
    } while (t !== c);
    return h;
  }
  function Q0(r, e) {
    return vt(r.prev, r, e.prev) < 0 && vt(e.next, r, r.next) < 0;
  }
  function J0(r, e, t, a) {
    let l = r;
    do
      l.z === 0 && (l.z = dh(l.x, l.y, e, t, a)),
        (l.prevZ = l.prev),
        (l.nextZ = l.next),
        (l = l.next);
    while (l !== r);
    (l.prevZ.nextZ = null), (l.prevZ = null), e_(l);
  }
  function e_(r) {
    let e,
      t = 1;
    do {
      let a = r,
        l;
      r = null;
      let o = null;
      for (e = 0; a;) {
        e++;
        let h = a,
          c = 0;
        for (let d = 0; d < t && (c++, (h = h.nextZ), !!h); d++);
        let u = t;
        for (; c > 0 || (u > 0 && h);)
          c !== 0 && (u === 0 || !h || a.z <= h.z)
            ? ((l = a), (a = a.nextZ), c--)
            : ((l = h), (h = h.nextZ), u--),
            o ? (o.nextZ = l) : (r = l),
            (l.prevZ = o),
            (o = l);
        a = h;
      }
      (o.nextZ = null), (t *= 2);
    } while (e > 1);
    return r;
  }
  function dh(r, e, t, a, l) {
    return (
      (r = ((r - t) * l) | 0),
      (e = ((e - a) * l) | 0),
      (r = (r | (r << 8)) & 16711935),
      (r = (r | (r << 4)) & 252645135),
      (r = (r | (r << 2)) & 858993459),
      (r = (r | (r << 1)) & 1431655765),
      (e = (e | (e << 8)) & 16711935),
      (e = (e | (e << 4)) & 252645135),
      (e = (e | (e << 2)) & 858993459),
      (e = (e | (e << 1)) & 1431655765),
      r | (e << 1)
    );
  }
  function t_(r) {
    let e = r,
      t = r;
    do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
    while (e !== r);
    return t;
  }
  function Gu(r, e, t, a, l, o, h, c) {
    return (
      (l - h) * (e - c) >= (r - h) * (o - c) &&
      (r - h) * (a - c) >= (t - h) * (e - c) &&
      (t - h) * (o - c) >= (l - h) * (a - c)
    );
  }
  function Hn(r, e, t, a, l, o, h, c) {
    return !(r === h && e === c) && Gu(r, e, t, a, l, o, h, c);
  }
  function s_(r, e) {
    return (
      r.next.i !== e.i &&
      r.prev.i !== e.i &&
      !i_(r, e) &&
      ((zn(r, e) &&
        zn(e, r) &&
        r_(r, e) &&
        (vt(r.prev, r, e.prev) || vt(r, e.prev, e))) ||
        (sn(r, e) && vt(r.prev, r, r.next) > 0 && vt(e.prev, e, e.next) > 0))
    );
  }
  function vt(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
  }
  function sn(r, e) {
    return r.x === e.x && r.y === e.y;
  }
  function Du(r, e, t, a) {
    const l = no(vt(r, e, t)),
      o = no(vt(r, e, a)),
      h = no(vt(t, a, r)),
      c = no(vt(t, a, e));
    return !!(
      (l !== o && h !== c) ||
      (l === 0 && ro(r, t, e)) ||
      (o === 0 && ro(r, a, e)) ||
      (h === 0 && ro(t, r, a)) ||
      (c === 0 && ro(t, e, a))
    );
  }
  function ro(r, e, t) {
    return (
      e.x <= Math.max(r.x, t.x) &&
      e.x >= Math.min(r.x, t.x) &&
      e.y <= Math.max(r.y, t.y) &&
      e.y >= Math.min(r.y, t.y)
    );
  }
  function no(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0;
  }
  function i_(r, e) {
    let t = r;
    do {
      if (
        t.i !== r.i &&
        t.next.i !== r.i &&
        t.i !== e.i &&
        t.next.i !== e.i &&
        Du(t, t.next, r, e)
      )
        return !0;
      t = t.next;
    } while (t !== r);
    return !1;
  }
  function zn(r, e) {
    return vt(r.prev, r, r.next) < 0
      ? vt(r, e, r.next) >= 0 && vt(r, r.prev, e) >= 0
      : vt(r, e, r.prev) < 0 || vt(r, r.next, e) < 0;
  }
  function r_(r, e) {
    let t = r,
      a = !1;
    const l = (r.x + e.x) / 2,
      o = (r.y + e.y) / 2;
    do
      t.y > o != t.next.y > o &&
        t.next.y !== t.y &&
        l < ((t.next.x - t.x) * (o - t.y)) / (t.next.y - t.y) + t.x &&
        (a = !a),
        (t = t.next);
    while (t !== r);
    return a;
  }
  function Uu(r, e) {
    const t = uh(r.i, r.x, r.y),
      a = uh(e.i, e.x, e.y),
      l = r.next,
      o = e.prev;
    return (
      (r.next = e),
      (e.prev = r),
      (t.next = l),
      (l.prev = t),
      (a.next = t),
      (t.prev = a),
      (o.next = a),
      (a.prev = o),
      a
    );
  }
  function Ou(r, e, t, a) {
    const l = uh(r, e, t);
    return (
      a
        ? ((l.next = a.next), (l.prev = a), (a.next.prev = l), (a.next = l))
        : ((l.prev = l), (l.next = l)),
      l
    );
  }
  function Wn(r) {
    (r.next.prev = r.prev),
      (r.prev.next = r.next),
      r.prevZ && (r.prevZ.nextZ = r.nextZ),
      r.nextZ && (r.nextZ.prevZ = r.prevZ);
  }
  function uh(r, e, t) {
    return {
      i: r,
      x: e,
      y: t,
      prev: null,
      next: null,
      z: 0,
      prevZ: null,
      nextZ: null,
      steiner: !1,
    };
  }
  function n_(r, e, t, a) {
    let l = 0;
    for (let o = e, h = t - a; o < t; o += a)
      (l += (r[h] - r[o]) * (r[o + 1] + r[h + 1])), (h = o);
    return l;
  }
  const a_ = Bu.default || Bu;
  var Ns = ((r) => (
    (r[(r.NONE = 0)] = "NONE"),
    (r[(r.COLOR = 16384)] = "COLOR"),
    (r[(r.STENCIL = 1024)] = "STENCIL"),
    (r[(r.DEPTH = 256)] = "DEPTH"),
    (r[(r.COLOR_DEPTH = 16640)] = "COLOR_DEPTH"),
    (r[(r.COLOR_STENCIL = 17408)] = "COLOR_STENCIL"),
    (r[(r.DEPTH_STENCIL = 1280)] = "DEPTH_STENCIL"),
    (r[(r.ALL = 17664)] = "ALL"),
    r
  ))(Ns || {});
  class Lu {
    constructor(e) {
      (this.items = []), (this._name = e);
    }
    emit(e, t, a, l, o, h, c, u) {
      const { name: d, items: f } = this;
      for (let p = 0, g = f.length; p < g; p++) f[p][d](e, t, a, l, o, h, c, u);
      return this;
    }
    add(e) {
      return e[this._name] && (this.remove(e), this.items.push(e)), this;
    }
    remove(e) {
      const t = this.items.indexOf(e);
      return t !== -1 && this.items.splice(t, 1), this;
    }
    contains(e) {
      return this.items.indexOf(e) !== -1;
    }
    removeAll() {
      return (this.items.length = 0), this;
    }
    destroy() {
      this.removeAll(), (this.items = null), (this._name = null);
    }
    get empty() {
      return this.items.length === 0;
    }
    get name() {
      return this._name;
    }
  }
  const o_ = [
    "init",
    "destroy",
    "contextChange",
    "resolutionChange",
    "resetState",
    "renderEnd",
    "renderStart",
    "render",
    "update",
    "postrender",
    "prerender",
  ],
    Nu = class e1 extends Os {
      constructor(e) {
        super(),
          (this.uid = et("renderer")),
          (this.runners = Object.create(null)),
          (this.renderPipes = Object.create(null)),
          (this._initOptions = {}),
          (this._systemsHash = Object.create(null)),
          (this.type = e.type),
          (this.name = e.name),
          (this.config = e);
        const t = [...o_, ...(this.config.runners ?? [])];
        this._addRunners(...t), this._unsafeEvalCheck();
      }
      async init(e = {}) {
        const t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
        await W0(t),
          this._addSystems(this.config.systems),
          this._addPipes(
            this.config.renderPipes,
            this.config.renderPipeAdaptors
          );
        for (const a in this._systemsHash)
          e = { ...this._systemsHash[a].constructor.defaultOptions, ...e };
        (e = { ...e1.defaultOptions, ...e }),
          (this._roundPixels = e.roundPixels ? 1 : 0);
        for (let a = 0; a < this.runners.init.items.length; a++)
          await this.runners.init.items[a].init(e);
        this._initOptions = e;
      }
      render(e, t) {
        let a = e;
        if (
          (a instanceof Ne &&
            ((a = { container: a }),
              t &&
              (me(
                Ie,
                "passing a second argument is deprecated, please use render options instead"
              ),
                (a.target = t.renderTexture))),
            a.target || (a.target = this.view.renderTarget),
            a.target === this.view.renderTarget &&
            ((this._lastObjectRendered = a.container),
              a.clearColor ?? (a.clearColor = this.background.colorRgba),
              a.clear ?? (a.clear = this.background.clearBeforeRender)),
            a.clearColor)
        ) {
          const l = Array.isArray(a.clearColor) && a.clearColor.length === 4;
          a.clearColor = l
            ? a.clearColor
            : mt.shared.setValue(a.clearColor).toArray();
        }
        a.transform ||
          (a.container.updateLocalTransform(),
            (a.transform = a.container.localTransform)),
          a.container.visible &&
          (a.container.enableRenderGroup(),
            this.runners.prerender.emit(a),
            this.runners.renderStart.emit(a),
            this.runners.render.emit(a),
            this.runners.renderEnd.emit(a),
            this.runners.postrender.emit(a));
      }
      resize(e, t, a) {
        const l = this.view.resolution;
        this.view.resize(e, t, a),
          this.emit(
            "resize",
            this.view.screen.width,
            this.view.screen.height,
            this.view.resolution
          ),
          a !== void 0 && a !== l && this.runners.resolutionChange.emit(a);
      }
      clear(e = {}) {
        const t = this;
        e.target || (e.target = t.renderTarget.renderTarget),
          e.clearColor || (e.clearColor = this.background.colorRgba),
          e.clear ?? (e.clear = Ns.ALL);
        const { clear: a, clearColor: l, target: o } = e;
        mt.shared.setValue(l ?? this.background.colorRgba),
          t.renderTarget.clear(o, a, mt.shared.toArray());
      }
      get resolution() {
        return this.view.resolution;
      }
      set resolution(e) {
        (this.view.resolution = e), this.runners.resolutionChange.emit(e);
      }
      get width() {
        return this.view.texture.frame.width;
      }
      get height() {
        return this.view.texture.frame.height;
      }
      get canvas() {
        return this.view.canvas;
      }
      get lastObjectRendered() {
        return this._lastObjectRendered;
      }
      get renderingToScreen() {
        return this.renderTarget.renderingToScreen;
      }
      get screen() {
        return this.view.screen;
      }
      _addRunners(...e) {
        e.forEach((t) => {
          this.runners[t] = new Lu(t);
        });
      }
      _addSystems(e) {
        let t;
        for (t in e) {
          const a = e[t];
          this._addSystem(a.value, a.name);
        }
      }
      _addSystem(e, t) {
        const a = new e(this);
        if (this[t])
          throw new Error(`Whoops! The name "${t}" is already in use`);
        (this[t] = a), (this._systemsHash[t] = a);
        for (const l in this.runners) this.runners[l].add(a);
        return this;
      }
      _addPipes(e, t) {
        const a = t.reduce((l, o) => ((l[o.name] = o.value), l), {});
        e.forEach((l) => {
          const o = l.value,
            h = l.name,
            c = a[h];
          (this.renderPipes[h] = new o(this, c ? new c() : null)),
            this.runners.destroy.add(this.renderPipes[h]);
        });
      }
      destroy(e = !1) {
        this.runners.destroy.items.reverse(),
          this.runners.destroy.emit(e),
          Object.values(this.runners).forEach((t) => {
            t.destroy();
          }),
          (e === !0 || (typeof e == "object" && e.releaseGlobalResources)) &&
          Zr.release(),
          (this._systemsHash = null),
          (this.renderPipes = null);
      }
      generateTexture(e) {
        return this.textureGenerator.generateTexture(e);
      }
      get roundPixels() {
        return !!this._roundPixels;
      }
      _unsafeEvalCheck() {
        if (!Iu())
          throw new Error(
            "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support."
          );
      }
      resetState() {
        this.runners.resetState.emit();
      }
    };
  Nu.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: !1,
    roundPixels: !1,
  };
  let ao = Nu,
    oo;
  function l_(r) {
    return (
      oo !== void 0 ||
      (oo = (() => {
        const e = {
          stencil: !0,
          failIfMajorPerformanceCaveat:
            r ?? ao.defaultOptions.failIfMajorPerformanceCaveat,
        };
        try {
          if (!xe.get().getWebGLRenderingContext()) return !1;
          let a = xe.get().createCanvas().getContext("webgl", e);
          const l = !!a?.getContextAttributes()?.stencil;
          if (a) {
            const o = a.getExtension("WEBGL_lose_context");
            o && o.loseContext();
          }
          return (a = null), l;
        } catch {
          return !1;
        }
      })()),
      oo
    );
  }
  let lo;
  async function h_(r = {}) {
    return (
      lo !== void 0 ||
      (lo = await (async () => {
        const e = xe.get().getNavigator().gpu;
        if (!e) return !1;
        try {
          return await (await e.requestAdapter(r)).requestDevice(), !0;
        } catch {
          return !1;
        }
      })()),
      lo
    );
  }
  const Hu = ["webgl", "webgpu", "canvas"];
  async function c_(r) {
    let e = [];
    r.preference
      ? (e.push(r.preference),
        Hu.forEach((o) => {
          o !== r.preference && e.push(o);
        }))
      : (e = Hu.slice());
    let t,
      a = {};
    for (let o = 0; o < e.length; o++) {
      const h = e[o];
      if (h === "webgpu" && (await h_())) {
        const { WebGPURenderer: c } = await Ha(async () => {
          const { WebGPURenderer: u } = await Promise.resolve().then(() => sw);
          return { WebGPURenderer: u };
        }, void 0);
        (t = c), (a = { ...r, ...r.webgpu });
        break;
      } else if (
        h === "webgl" &&
        l_(
          r.failIfMajorPerformanceCaveat ??
          ao.defaultOptions.failIfMajorPerformanceCaveat
        )
      ) {
        const { WebGLRenderer: c } = await Ha(async () => {
          const { WebGLRenderer: u } = await Promise.resolve().then(() => Ub);
          return { WebGLRenderer: u };
        }, void 0);
        (t = c), (a = { ...r, ...r.webgl });
        break;
      } else if (h === "canvas")
        throw (
          ((a = { ...r }), new Error("CanvasRenderer is not yet implemented"))
        );
    }
    if ((delete a.webgpu, delete a.webgl, !t))
      throw new Error("No available renderer for the current environment");
    const l = new t();
    return await l.init(a), l;
  }
  const ho = "8.13.2";
  class zu {
    static init() {
      globalThis.__PIXI_APP_INIT__?.(this, ho);
    }
    static destroy() { }
  }
  zu.extension = P.Application;
  class Wu {
    constructor(e) {
      this._renderer = e;
    }
    init() {
      globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, ho);
    }
    destroy() {
      this._renderer = null;
    }
  }
  Wu.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem],
    name: "initHook",
    priority: -10,
  };
  const Vu = class ld {
    constructor(...e) {
      (this.stage = new Ne()),
        e[0] !== void 0 &&
        me(
          Ie,
          "Application constructor options are deprecated, please use Application.init() instead."
        );
    }
    async init(e) {
      (e = { ...e }),
        (this.renderer = await c_(e)),
        ld._plugins.forEach((t) => {
          t.init.call(this, e);
        });
    }
    render() {
      this.renderer.render({ container: this.stage });
    }
    get canvas() {
      return this.renderer.canvas;
    }
    get view() {
      return (
        me(
          Ie,
          "Application.view is deprecated, please use Application.canvas instead."
        ),
        this.renderer.canvas
      );
    }
    get screen() {
      return this.renderer.screen;
    }
    destroy(e = !1, t = !1) {
      const a = ld._plugins.slice(0);
      a.reverse(),
        a.forEach((l) => {
          l.destroy.call(this);
        }),
        this.stage.destroy(t),
        (this.stage = null),
        this.renderer.destroy(e),
        (this.renderer = null);
    }
  };
  Vu._plugins = [];
  let ju = Vu;
  ge.handleByList(P.Application, ju._plugins), ge.add(zu);
  class Xu {
    static init(e) {
      Object.defineProperty(this, "resizeTo", {
        set(t) {
          globalThis.removeEventListener("resize", this.queueResize),
            (this._resizeTo = t),
            t &&
            (globalThis.addEventListener("resize", this.queueResize),
              this.resize());
        },
        get() {
          return this._resizeTo;
        },
      }),
        (this.queueResize = () => {
          this._resizeTo &&
            (this._cancelResize(),
              (this._resizeId = requestAnimationFrame(() => this.resize())));
        }),
        (this._cancelResize = () => {
          this._resizeId &&
            (cancelAnimationFrame(this._resizeId), (this._resizeId = null));
        }),
        (this.resize = () => {
          if (!this._resizeTo) return;
          this._cancelResize();
          let t, a;
          if (this._resizeTo === globalThis.window)
            (t = globalThis.innerWidth), (a = globalThis.innerHeight);
          else {
            const { clientWidth: l, clientHeight: o } = this._resizeTo;
            (t = l), (a = o);
          }
          this.renderer.resize(t, a), this.render();
        }),
        (this._resizeId = null),
        (this._resizeTo = null),
        (this.resizeTo = e.resizeTo || null);
    }
    static destroy() {
      globalThis.removeEventListener("resize", this.queueResize),
        this._cancelResize(),
        (this._cancelResize = null),
        (this.queueResize = null),
        (this.resizeTo = null),
        (this.resize = null);
    }
  }
  Xu.extension = P.Application;
  class qu {
    static init(e) {
      (e = Object.assign({ autoStart: !0, sharedTicker: !1 }, e)),
        Object.defineProperty(this, "ticker", {
          set(t) {
            this._ticker && this._ticker.remove(this.render, this),
              (this._ticker = t),
              t && t.add(this.render, this, Qr.LOW);
          },
          get() {
            return this._ticker;
          },
        }),
        (this.stop = () => {
          this._ticker.stop();
        }),
        (this.start = () => {
          this._ticker.start();
        }),
        (this._ticker = null),
        (this.ticker = e.sharedTicker ? Js.shared : new Js()),
        e.autoStart && this.start();
    }
    static destroy() {
      if (this._ticker) {
        const e = this._ticker;
        (this.ticker = null), e.destroy();
      }
    }
  }
  qu.extension = P.Application;
  class Yu extends Os {
    constructor() {
      super(...arguments),
        (this.chars = Object.create(null)),
        (this.lineHeight = 0),
        (this.fontFamily = ""),
        (this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }),
        (this.baseLineOffset = 0),
        (this.distanceField = { type: "none", range: 0 }),
        (this.pages = []),
        (this.applyFillAsTint = !0),
        (this.baseMeasurementFontSize = 100),
        (this.baseRenderedFontSize = 100);
    }
    get font() {
      return (
        me(
          Ie,
          "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."
        ),
        this.fontFamily
      );
    }
    get pageTextures() {
      return (
        me(
          Ie,
          "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."
        ),
        this.pages
      );
    }
    get size() {
      return (
        me(
          Ie,
          "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."
        ),
        this.fontMetrics.fontSize
      );
    }
    get distanceFieldRange() {
      return (
        me(
          Ie,
          "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."
        ),
        this.distanceField.range
      );
    }
    get distanceFieldType() {
      return (
        me(
          Ie,
          "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."
        ),
        this.distanceField.type
      );
    }
    destroy(e = !1) {
      this.emit("destroy", this), this.removeAllListeners();
      for (const t in this.chars) this.chars[t].texture?.destroy();
      (this.chars = null),
        e &&
        (this.pages.forEach((t) => t.texture.destroy(!0)),
          (this.pages = null));
    }
  }
  /**
   * tiny-lru
   *
   * @copyright 2025 Jason Mulligan <jason.mulligan@avoidwork.com>
   * @license BSD-3-Clause
   * @version 11.4.5
   */ class d_ {
    constructor(e = 0, t = 0, a = !1) {
      (this.first = null),
        (this.items = Object.create(null)),
        (this.last = null),
        (this.max = e),
        (this.resetTtl = a),
        (this.size = 0),
        (this.ttl = t);
    }
    clear() {
      return (
        (this.first = null),
        (this.items = Object.create(null)),
        (this.last = null),
        (this.size = 0),
        this
      );
    }
    delete(e) {
      if (this.has(e)) {
        const t = this.items[e];
        delete this.items[e],
          this.size--,
          t.prev !== null && (t.prev.next = t.next),
          t.next !== null && (t.next.prev = t.prev),
          this.first === t && (this.first = t.next),
          this.last === t && (this.last = t.prev);
      }
      return this;
    }
    entries(e = this.keys()) {
      return e.map((t) => [t, this.get(t)]);
    }
    evict(e = !1) {
      if (e || this.size > 0) {
        const t = this.first;
        delete this.items[t.key],
          --this.size === 0
            ? ((this.first = null), (this.last = null))
            : ((this.first = t.next), (this.first.prev = null));
      }
      return this;
    }
    expiresAt(e) {
      let t;
      return this.has(e) && (t = this.items[e].expiry), t;
    }
    get(e) {
      const t = this.items[e];
      if (t !== void 0) {
        if (this.ttl > 0 && t.expiry <= Date.now()) {
          this.delete(e);
          return;
        }
        return this.moveToEnd(t), t.value;
      }
    }
    has(e) {
      return e in this.items;
    }
    moveToEnd(e) {
      this.last !== e &&
        (e.prev !== null && (e.prev.next = e.next),
          e.next !== null && (e.next.prev = e.prev),
          this.first === e && (this.first = e.next),
          (e.prev = this.last),
          (e.next = null),
          this.last !== null && (this.last.next = e),
          (this.last = e),
          this.first === null && (this.first = e));
    }
    keys() {
      const e = [];
      let t = this.first;
      for (; t !== null;) e.push(t.key), (t = t.next);
      return e;
    }
    setWithEvicted(e, t, a = this.resetTtl) {
      let l = null;
      if (this.has(e)) this.set(e, t, !0, a);
      else {
        this.max > 0 &&
          this.size === this.max &&
          ((l = { ...this.first }), this.evict(!0));
        let o = (this.items[e] = {
          expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
          key: e,
          prev: this.last,
          next: null,
          value: t,
        });
        ++this.size === 1 ? (this.first = o) : (this.last.next = o),
          (this.last = o);
      }
      return l;
    }
    set(e, t, a = !1, l = this.resetTtl) {
      let o = this.items[e];
      return (
        a || o !== void 0
          ? ((o.value = t),
            a === !1 &&
            l &&
            (o.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl),
            this.moveToEnd(o))
          : (this.max > 0 && this.size === this.max && this.evict(!0),
            (o = this.items[e] =
            {
              expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
              key: e,
              prev: this.last,
              next: null,
              value: t,
            }),
            ++this.size === 1 ? (this.first = o) : (this.last.next = o),
            (this.last = o)),
        this
      );
    }
    values(e = this.keys()) {
      return e.map((t) => this.get(t));
    }
  }
  function $u(r = 1e3, e = 0, t = !1) {
    if (isNaN(r) || r < 0) throw new TypeError("Invalid max value");
    if (isNaN(e) || e < 0) throw new TypeError("Invalid ttl value");
    if (typeof t != "boolean") throw new TypeError("Invalid resetTtl value");
    return new d_(r, e, t);
  }
  const u_ = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui",
  ];
  function co(r) {
    const e = typeof r.fontSize == "number" ? `${r.fontSize}px` : r.fontSize;
    let t = r.fontFamily;
    Array.isArray(r.fontFamily) || (t = r.fontFamily.split(","));
    for (let a = t.length - 1; a >= 0; a--) {
      let l = t[a].trim();
      !/([\"\'])[^\'\"]+\1/.test(l) && !u_.includes(l) && (l = `"${l}"`),
        (t[a] = l);
    }
    return `${r.fontStyle} ${r.fontVariant} ${r.fontWeight} ${e} ${t.join(
      ","
    )}`;
  }
  const fh = { willReadFrequently: !0 },
    mi = class oe {
      static get experimentalLetterSpacingSupported() {
        let e = oe._experimentalLetterSpacingSupported;
        if (e === void 0) {
          const t = xe.get().getCanvasRenderingContext2D().prototype;
          e = oe._experimentalLetterSpacingSupported =
            "letterSpacing" in t || "textLetterSpacing" in t;
        }
        return e;
      }
      constructor(e, t, a, l, o, h, c, u, d) {
        (this.text = e),
          (this.style = t),
          (this.width = a),
          (this.height = l),
          (this.lines = o),
          (this.lineWidths = h),
          (this.lineHeight = c),
          (this.maxLineWidth = u),
          (this.fontProperties = d);
      }
      static measureText(e = " ", t, a = oe._canvas, l = t.wordWrap) {
        const o = `${e}-${t.styleKey}-wordWrap-${l}`;
        if (oe._measurementCache.has(o)) return oe._measurementCache.get(o);
        const h = co(t),
          c = oe.measureFont(h);
        c.fontSize === 0 &&
          ((c.fontSize = t.fontSize), (c.ascent = t.fontSize));
        const u = oe.__context;
        u.font = h;
        const f = (l ? oe._wordWrap(e, t, a) : e).split(/(?:\r\n|\r|\n)/),
          p = new Array(f.length);
        let g = 0;
        for (let b = 0; b < f.length; b++) {
          const T = oe._measureText(f[b], t.letterSpacing, u);
          (p[b] = T), (g = Math.max(g, T));
        }
        const _ = t._stroke?.width || 0;
        let m = g + _;
        t.dropShadow && (m += t.dropShadow.distance);
        const w = t.lineHeight || c.fontSize;
        let x = Math.max(w, c.fontSize + _) + (f.length - 1) * (w + t.leading);
        t.dropShadow && (x += t.dropShadow.distance);
        const M = new oe(e, t, m, x, f, p, w + t.leading, g, c);
        return oe._measurementCache.set(o, M), M;
      }
      static _measureText(e, t, a) {
        let l = !1;
        oe.experimentalLetterSpacingSupported &&
          (oe.experimentalLetterSpacing
            ? ((a.letterSpacing = `${t}px`),
              (a.textLetterSpacing = `${t}px`),
              (l = !0))
            : ((a.letterSpacing = "0px"), (a.textLetterSpacing = "0px")));
        const o = a.measureText(e);
        let h = o.width;
        const c = -o.actualBoundingBoxLeft;
        let d = o.actualBoundingBoxRight - c;
        if (h > 0)
          if (l) (h -= t), (d -= t);
          else {
            const f = (oe.graphemeSegmenter(e).length - 1) * t;
            (h += f), (d += f);
          }
        return Math.max(h, d);
      }
      static _wordWrap(e, t, a = oe._canvas) {
        const l = a.getContext("2d", fh);
        let o = 0,
          h = "",
          c = "";
        const u = Object.create(null),
          { letterSpacing: d, whiteSpace: f } = t,
          p = oe._collapseSpaces(f),
          g = oe._collapseNewlines(f);
        let _ = !p;
        const m = t.wordWrapWidth + d,
          w = oe._tokenize(e);
        for (let x = 0; x < w.length; x++) {
          let M = w[x];
          if (oe._isNewline(M)) {
            if (!g) {
              (c += oe._addLine(h)), (_ = !p), (h = ""), (o = 0);
              continue;
            }
            M = " ";
          }
          if (p) {
            const T = oe.isBreakingSpace(M),
              C = oe.isBreakingSpace(h[h.length - 1]);
            if (T && C) continue;
          }
          const b = oe._getFromCache(M, d, u, l);
          if (b > m)
            if (
              (h !== "" && ((c += oe._addLine(h)), (h = ""), (o = 0)),
                oe.canBreakWords(M, t.breakWords))
            ) {
              const T = oe.wordWrapSplit(M);
              for (let C = 0; C < T.length; C++) {
                let A = T[C],
                  R = A,
                  k = 1;
                for (; T[C + k];) {
                  const D = T[C + k];
                  if (!oe.canBreakChars(R, D, M, C, t.breakWords)) A += D;
                  else break;
                  (R = D), k++;
                }
                C += k - 1;
                const W = oe._getFromCache(A, d, u, l);
                W + o > m &&
                  ((c += oe._addLine(h)), (_ = !1), (h = ""), (o = 0)),
                  (h += A),
                  (o += W);
              }
            } else {
              h.length > 0 && ((c += oe._addLine(h)), (h = ""), (o = 0));
              const T = x === w.length - 1;
              (c += oe._addLine(M, !T)), (_ = !1), (h = ""), (o = 0);
            }
          else
            b + o > m && ((_ = !1), (c += oe._addLine(h)), (h = ""), (o = 0)),
              (h.length > 0 || !oe.isBreakingSpace(M) || _) &&
              ((h += M), (o += b));
        }
        return (c += oe._addLine(h, !1)), c;
      }
      static _addLine(e, t = !0) {
        return (
          (e = oe._trimRight(e)),
          (e = t
            ? `${e}
`
            : e),
          e
        );
      }
      static _getFromCache(e, t, a, l) {
        let o = a[e];
        return (
          typeof o != "number" &&
          ((o = oe._measureText(e, t, l) + t), (a[e] = o)),
          o
        );
      }
      static _collapseSpaces(e) {
        return e === "normal" || e === "pre-line";
      }
      static _collapseNewlines(e) {
        return e === "normal";
      }
      static _trimRight(e) {
        if (typeof e != "string") return "";
        for (let t = e.length - 1; t >= 0; t--) {
          const a = e[t];
          if (!oe.isBreakingSpace(a)) break;
          e = e.slice(0, -1);
        }
        return e;
      }
      static _isNewline(e) {
        return typeof e != "string"
          ? !1
          : oe._newlines.includes(e.charCodeAt(0));
      }
      static isBreakingSpace(e, t) {
        return typeof e != "string"
          ? !1
          : oe._breakingSpaces.includes(e.charCodeAt(0));
      }
      static _tokenize(e) {
        const t = [];
        let a = "";
        if (typeof e != "string") return t;
        for (let l = 0; l < e.length; l++) {
          const o = e[l],
            h = e[l + 1];
          if (oe.isBreakingSpace(o, h) || oe._isNewline(o)) {
            a !== "" && (t.push(a), (a = "")),
              o === "\r" &&
                h ===
                `
`
                ? (t.push(`\r
`),
                  l++)
                : t.push(o);
            continue;
          }
          a += o;
        }
        return a !== "" && t.push(a), t;
      }
      static canBreakWords(e, t) {
        return t;
      }
      static canBreakChars(e, t, a, l, o) {
        return !0;
      }
      static wordWrapSplit(e) {
        return oe.graphemeSegmenter(e);
      }
      static measureFont(e) {
        if (oe._fonts[e]) return oe._fonts[e];
        const t = oe._context;
        t.font = e;
        const a = t.measureText(oe.METRICS_STRING + oe.BASELINE_SYMBOL),
          l = {
            ascent: a.actualBoundingBoxAscent,
            descent: a.actualBoundingBoxDescent,
            fontSize: a.actualBoundingBoxAscent + a.actualBoundingBoxDescent,
          };
        return (oe._fonts[e] = l), l;
      }
      static clearMetrics(e = "") {
        e ? delete oe._fonts[e] : (oe._fonts = {});
      }
      static get _canvas() {
        if (!oe.__canvas) {
          let e;
          try {
            const t = new OffscreenCanvas(0, 0);
            if (t.getContext("2d", fh)?.measureText)
              return (oe.__canvas = t), t;
            e = xe.get().createCanvas();
          } catch {
            e = xe.get().createCanvas();
          }
          (e.width = e.height = 10), (oe.__canvas = e);
        }
        return oe.__canvas;
      }
      static get _context() {
        return (
          oe.__context || (oe.__context = oe._canvas.getContext("2d", fh)),
          oe.__context
        );
      }
    };
  (mi.METRICS_STRING = "|q"),
    (mi.BASELINE_SYMBOL = "M"),
    (mi.BASELINE_MULTIPLIER = 1.4),
    (mi.HEIGHT_MULTIPLIER = 2),
    (mi.graphemeSegmenter = (() => {
      if (typeof Intl?.Segmenter == "function") {
        const r = new Intl.Segmenter();
        return (e) => {
          const t = r.segment(e),
            a = [];
          let l = 0;
          for (const o of t) a[l++] = o.segment;
          return a;
        };
      }
      return (r) => [...r];
    })()),
    (mi.experimentalLetterSpacing = !1),
    (mi._fonts = {}),
    (mi._newlines = [10, 13]),
    (mi._breakingSpaces = [
      9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287,
      12288,
    ]),
    (mi._measurementCache = $u(1e3));
  let _i = mi;
  const Ku = [
    { offset: 0, color: "white" },
    { offset: 1, color: "black" },
  ],
    ph = class hd {
      constructor(...e) {
        (this.uid = et("fillGradient")),
          (this._tick = 0),
          (this.type = "linear"),
          (this.colorStops = []);
        let t = f_(e);
        (t = {
          ...(t.type === "radial"
            ? hd.defaultRadialOptions
            : hd.defaultLinearOptions),
          ...Sd(t),
        }),
          (this._textureSize = t.textureSize),
          (this._wrapMode = t.wrapMode),
          t.type === "radial"
            ? ((this.center = t.center),
              (this.outerCenter = t.outerCenter ?? this.center),
              (this.innerRadius = t.innerRadius),
              (this.outerRadius = t.outerRadius),
              (this.scale = t.scale),
              (this.rotation = t.rotation))
            : ((this.start = t.start), (this.end = t.end)),
          (this.textureSpace = t.textureSpace),
          (this.type = t.type),
          t.colorStops.forEach((l) => {
            this.addColorStop(l.offset, l.color);
          });
      }
      addColorStop(e, t) {
        return (
          this.colorStops.push({
            offset: e,
            color: mt.shared.setValue(t).toHexa(),
          }),
          this
        );
      }
      buildLinearGradient() {
        if (this.texture) return;
        let { x: e, y: t } = this.start,
          { x: a, y: l } = this.end,
          o = a - e,
          h = l - t;
        const c = o < 0 || h < 0;
        if (this._wrapMode === "clamp-to-edge") {
          if (o < 0) {
            const x = e;
            (e = a), (a = x), (o *= -1);
          }
          if (h < 0) {
            const x = t;
            (t = l), (l = x), (h *= -1);
          }
        }
        const u = this.colorStops.length ? this.colorStops : Ku,
          d = this._textureSize,
          { canvas: f, context: p } = Qu(d, 1),
          g = c
            ? p.createLinearGradient(this._textureSize, 0, 0, 0)
            : p.createLinearGradient(0, 0, this._textureSize, 0);
        Zu(g, u),
          (p.fillStyle = g),
          p.fillRect(0, 0, d, 1),
          (this.texture = new te({
            source: new Rr({ resource: f, addressMode: this._wrapMode }),
          }));
        const _ = Math.sqrt(o * o + h * h),
          m = Math.atan2(h, o),
          w = new ae();
        w.scale(_ / d, 1),
          w.rotate(m),
          w.translate(e, t),
          this.textureSpace === "local" && w.scale(d, d),
          (this.transform = w);
      }
      buildGradient() {
        this.texture || this._tick++,
          this.type === "linear"
            ? this.buildLinearGradient()
            : this.buildRadialGradient();
      }
      buildRadialGradient() {
        if (this.texture) return;
        const e = this.colorStops.length ? this.colorStops : Ku,
          t = this._textureSize,
          { canvas: a, context: l } = Qu(t, t),
          { x: o, y: h } = this.center,
          { x: c, y: u } = this.outerCenter,
          d = this.innerRadius,
          f = this.outerRadius,
          p = c - f,
          g = u - f,
          _ = t / (f * 2),
          m = (o - p) * _,
          w = (h - g) * _,
          x = l.createRadialGradient(
            m,
            w,
            d * _,
            (c - p) * _,
            (u - g) * _,
            f * _
          );
        Zu(x, e),
          (l.fillStyle = e[e.length - 1].color),
          l.fillRect(0, 0, t, t),
          (l.fillStyle = x),
          l.translate(m, w),
          l.rotate(this.rotation),
          l.scale(1, this.scale),
          l.translate(-m, -w),
          l.fillRect(0, 0, t, t),
          (this.texture = new te({
            source: new Rr({ resource: a, addressMode: this._wrapMode }),
          }));
        const M = new ae();
        M.scale(1 / _, 1 / _),
          M.translate(p, g),
          this.textureSpace === "local" && M.scale(t, t),
          (this.transform = M);
      }
      destroy() {
        this.texture?.destroy(!0),
          (this.texture = null),
          (this.transform = null),
          (this.colorStops = []),
          (this.start = null),
          (this.end = null),
          (this.center = null),
          (this.outerCenter = null);
      }
      get styleKey() {
        return `fill-gradient-${this.uid}-${this._tick}`;
      }
    };
  (ph.defaultLinearOptions = {
    start: { x: 0, y: 0 },
    end: { x: 0, y: 1 },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256,
    wrapMode: "clamp-to-edge",
  }),
    (ph.defaultRadialOptions = {
      center: { x: 0.5, y: 0.5 },
      innerRadius: 0,
      outerRadius: 0.5,
      colorStops: [],
      scale: 1,
      textureSpace: "local",
      type: "radial",
      textureSize: 256,
      wrapMode: "clamp-to-edge",
    });
  let Yi = ph;
  function Zu(r, e) {
    for (let t = 0; t < e.length; t++) {
      const a = e[t];
      r.addColorStop(a.offset, a.color);
    }
  }
  function Qu(r, e) {
    const t = xe.get().createCanvas(r, e),
      a = t.getContext("2d");
    return { canvas: t, context: a };
  }
  function f_(r) {
    let e = r[0] ?? {};
    return (
      (typeof e == "number" || r[1]) &&
      (me("8.5.2", "use options object instead"),
        (e = {
          type: "linear",
          start: { x: r[0], y: r[1] },
          end: { x: r[2], y: r[3] },
          textureSpace: r[4],
          textureSize: r[5] ?? Yi.defaultLinearOptions.textureSize,
        })),
      e
    );
  }
  const Ju = {
    repeat: { addressModeU: "repeat", addressModeV: "repeat" },
    "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" },
    "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" },
    "no-repeat": {
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge",
    },
  };
  class uo {
    constructor(e, t) {
      (this.uid = et("fillPattern")),
        (this._tick = 0),
        (this.transform = new ae()),
        (this.texture = e),
        this.transform.scale(1 / e.frame.width, 1 / e.frame.height),
        t &&
        ((e.source.style.addressModeU = Ju[t].addressModeU),
          (e.source.style.addressModeV = Ju[t].addressModeV));
    }
    setTransform(e) {
      const t = this.texture;
      this.transform.copyFrom(e),
        this.transform.invert(),
        this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
        this._tick++;
    }
    get texture() {
      return this._texture;
    }
    set texture(e) {
      this._texture !== e && ((this._texture = e), this._tick++);
    }
    get styleKey() {
      return `fill-pattern-${this.uid}-${this._tick}`;
    }
    destroy() {
      this.texture.destroy(!0), (this.texture = null);
    }
  }
  var gh, ef;
  function p_() {
    if (ef) return gh;
    (ef = 1), (gh = t);
    var r = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
      e = /([astvzqmhlc])([^astvzqmhlc]*)/gi;
    function t(o) {
      var h = [];
      return (
        o.replace(e, function (c, u, d) {
          var f = u.toLowerCase();
          for (
            d = l(d),
            f == "m" &&
            d.length > 2 &&
            (h.push([u].concat(d.splice(0, 2))),
              (f = "l"),
              (u = u == "m" ? "l" : "L"));
            ;

          ) {
            if (d.length == r[f]) return d.unshift(u), h.push(d);
            if (d.length < r[f]) throw new Error("malformed path data");
            h.push([u].concat(d.splice(0, r[f])));
          }
        }),
        h
      );
    }
    var a = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
    function l(o) {
      var h = o.match(a);
      return h ? h.map(Number) : [];
    }
    return gh;
  }
  var g_ = p_();
  const m_ = _d(g_);
  function __(r, e) {
    const t = m_(r),
      a = [];
    let l = null,
      o = 0,
      h = 0;
    for (let c = 0; c < t.length; c++) {
      const u = t[c],
        d = u[0],
        f = u;
      switch (d) {
        case "M":
          (o = f[1]), (h = f[2]), e.moveTo(o, h);
          break;
        case "m":
          (o += f[1]), (h += f[2]), e.moveTo(o, h);
          break;
        case "H":
          (o = f[1]), e.lineTo(o, h);
          break;
        case "h":
          (o += f[1]), e.lineTo(o, h);
          break;
        case "V":
          (h = f[1]), e.lineTo(o, h);
          break;
        case "v":
          (h += f[1]), e.lineTo(o, h);
          break;
        case "L":
          (o = f[1]), (h = f[2]), e.lineTo(o, h);
          break;
        case "l":
          (o += f[1]), (h += f[2]), e.lineTo(o, h);
          break;
        case "C":
          (o = f[5]), (h = f[6]), e.bezierCurveTo(f[1], f[2], f[3], f[4], o, h);
          break;
        case "c":
          e.bezierCurveTo(
            o + f[1],
            h + f[2],
            o + f[3],
            h + f[4],
            o + f[5],
            h + f[6]
          ),
            (o += f[5]),
            (h += f[6]);
          break;
        case "S":
          (o = f[3]), (h = f[4]), e.bezierCurveToShort(f[1], f[2], o, h);
          break;
        case "s":
          e.bezierCurveToShort(o + f[1], h + f[2], o + f[3], h + f[4]),
            (o += f[3]),
            (h += f[4]);
          break;
        case "Q":
          (o = f[3]), (h = f[4]), e.quadraticCurveTo(f[1], f[2], o, h);
          break;
        case "q":
          e.quadraticCurveTo(o + f[1], h + f[2], o + f[3], h + f[4]),
            (o += f[3]),
            (h += f[4]);
          break;
        case "T":
          (o = f[1]), (h = f[2]), e.quadraticCurveToShort(o, h);
          break;
        case "t":
          (o += f[1]), (h += f[2]), e.quadraticCurveToShort(o, h);
          break;
        case "A":
          (o = f[6]),
            (h = f[7]),
            e.arcToSvg(f[1], f[2], f[3], f[4], f[5], o, h);
          break;
        case "a":
          (o += f[6]),
            (h += f[7]),
            e.arcToSvg(f[1], f[2], f[3], f[4], f[5], o, h);
          break;
        case "Z":
        case "z":
          e.closePath(),
            a.length > 0 &&
            ((l = a.pop()),
              l ? ((o = l.startX), (h = l.startY)) : ((o = 0), (h = 0))),
            (l = null);
          break;
        default:
          pe(`Unknown SVG path command: ${d}`);
      }
      d !== "Z" &&
        d !== "z" &&
        l === null &&
        ((l = { startX: o, startY: h }), a.push(l));
    }
    return e;
  }
  class mh {
    constructor(e = 0, t = 0, a = 0) {
      (this.type = "circle"), (this.x = e), (this.y = t), (this.radius = a);
    }
    clone() {
      return new mh(this.x, this.y, this.radius);
    }
    contains(e, t) {
      if (this.radius <= 0) return !1;
      const a = this.radius * this.radius;
      let l = this.x - e,
        o = this.y - t;
      return (l *= l), (o *= o), l + o <= a;
    }
    strokeContains(e, t, a, l = 0.5) {
      if (this.radius === 0) return !1;
      const o = this.x - e,
        h = this.y - t,
        c = this.radius,
        u = (1 - l) * a,
        d = Math.sqrt(o * o + h * h);
      return d <= c + u && d > c - (a - u);
    }
    getBounds(e) {
      return (
        e || (e = new Le()),
        (e.x = this.x - this.radius),
        (e.y = this.y - this.radius),
        (e.width = this.radius * 2),
        (e.height = this.radius * 2),
        e
      );
    }
    copyFrom(e) {
      return (this.x = e.x), (this.y = e.y), (this.radius = e.radius), this;
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
    }
  }
  class _h {
    constructor(e = 0, t = 0, a = 0, l = 0) {
      (this.type = "ellipse"),
        (this.x = e),
        (this.y = t),
        (this.halfWidth = a),
        (this.halfHeight = l);
    }
    clone() {
      return new _h(this.x, this.y, this.halfWidth, this.halfHeight);
    }
    contains(e, t) {
      if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
      let a = (e - this.x) / this.halfWidth,
        l = (t - this.y) / this.halfHeight;
      return (a *= a), (l *= l), a + l <= 1;
    }
    strokeContains(e, t, a, l = 0.5) {
      const { halfWidth: o, halfHeight: h } = this;
      if (o <= 0 || h <= 0) return !1;
      const c = a * (1 - l),
        u = a - c,
        d = o - u,
        f = h - u,
        p = o + c,
        g = h + c,
        _ = e - this.x,
        m = t - this.y,
        w = (_ * _) / (d * d) + (m * m) / (f * f),
        x = (_ * _) / (p * p) + (m * m) / (g * g);
      return w > 1 && x <= 1;
    }
    getBounds(e) {
      return (
        e || (e = new Le()),
        (e.x = this.x - this.halfWidth),
        (e.y = this.y - this.halfHeight),
        (e.width = this.halfWidth * 2),
        (e.height = this.halfHeight * 2),
        e
      );
    }
    copyFrom(e) {
      return (
        (this.x = e.x),
        (this.y = e.y),
        (this.halfWidth = e.halfWidth),
        (this.halfHeight = e.halfHeight),
        this
      );
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
    }
  }
  function y_(r, e, t, a, l, o) {
    const h = r - t,
      c = e - a,
      u = l - t,
      d = o - a,
      f = h * u + c * d,
      p = u * u + d * d;
    let g = -1;
    p !== 0 && (g = f / p);
    let _, m;
    g < 0
      ? ((_ = t), (m = a))
      : g > 1
        ? ((_ = l), (m = o))
        : ((_ = t + g * u), (m = a + g * d));
    const w = r - _,
      x = e - m;
    return w * w + x * x;
  }
  let x_, v_;
  class Vn {
    constructor(...e) {
      this.type = "polygon";
      let t = Array.isArray(e[0]) ? e[0] : e;
      if (typeof t[0] != "number") {
        const a = [];
        for (let l = 0, o = t.length; l < o; l++) a.push(t[l].x, t[l].y);
        t = a;
      }
      (this.points = t), (this.closePath = !0);
    }
    isClockwise() {
      let e = 0;
      const t = this.points,
        a = t.length;
      for (let l = 0; l < a; l += 2) {
        const o = t[l],
          h = t[l + 1],
          c = t[(l + 2) % a],
          u = t[(l + 3) % a];
        e += (c - o) * (u + h);
      }
      return e < 0;
    }
    containsPolygon(e) {
      const t = this.getBounds(x_),
        a = e.getBounds(v_);
      if (!t.containsRect(a)) return !1;
      const l = e.points;
      for (let o = 0; o < l.length; o += 2) {
        const h = l[o],
          c = l[o + 1];
        if (!this.contains(h, c)) return !1;
      }
      return !0;
    }
    clone() {
      const e = this.points.slice(),
        t = new Vn(e);
      return (t.closePath = this.closePath), t;
    }
    contains(e, t) {
      let a = !1;
      const l = this.points.length / 2;
      for (let o = 0, h = l - 1; o < l; h = o++) {
        const c = this.points[o * 2],
          u = this.points[o * 2 + 1],
          d = this.points[h * 2],
          f = this.points[h * 2 + 1];
        u > t != f > t && e < (d - c) * ((t - u) / (f - u)) + c && (a = !a);
      }
      return a;
    }
    strokeContains(e, t, a, l = 0.5) {
      const o = a * a,
        h = o * (1 - l),
        c = o - h,
        { points: u } = this,
        d = u.length - (this.closePath ? 0 : 2);
      for (let f = 0; f < d; f += 2) {
        const p = u[f],
          g = u[f + 1],
          _ = u[(f + 2) % u.length],
          m = u[(f + 3) % u.length],
          w = y_(e, t, p, g, _, m),
          x = Math.sign((_ - p) * (t - g) - (m - g) * (e - p));
        if (w <= (x < 0 ? c : h)) return !0;
      }
      return !1;
    }
    getBounds(e) {
      e || (e = new Le());
      const t = this.points;
      let a = 1 / 0,
        l = -1 / 0,
        o = 1 / 0,
        h = -1 / 0;
      for (let c = 0, u = t.length; c < u; c += 2) {
        const d = t[c],
          f = t[c + 1];
        (a = d < a ? d : a),
          (l = d > l ? d : l),
          (o = f < o ? f : o),
          (h = f > h ? f : h);
      }
      return (e.x = a), (e.width = l - a), (e.y = o), (e.height = h - o), e;
    }
    copyFrom(e) {
      return (
        (this.points = e.points.slice()), (this.closePath = e.closePath), this
      );
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath
        }points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return (
        me(
          "8.11.0",
          "Polygon.lastX is deprecated, please use Polygon.lastX instead."
        ),
        this.points[this.points.length - 2]
      );
    }
    get y() {
      return (
        me(
          "8.11.0",
          "Polygon.y is deprecated, please use Polygon.lastY instead."
        ),
        this.points[this.points.length - 1]
      );
    }
    get startX() {
      return this.points[0];
    }
    get startY() {
      return this.points[1];
    }
  }
  const fo = (r, e, t, a, l, o, h) => {
    const c = r - t,
      u = e - a,
      d = Math.sqrt(c * c + u * u);
    return d >= l - o && d <= l + h;
  };
  class yh {
    constructor(e = 0, t = 0, a = 0, l = 0, o = 20) {
      (this.type = "roundedRectangle"),
        (this.x = e),
        (this.y = t),
        (this.width = a),
        (this.height = l),
        (this.radius = o);
    }
    getBounds(e) {
      return (
        e || (e = new Le()),
        (e.x = this.x),
        (e.y = this.y),
        (e.width = this.width),
        (e.height = this.height),
        e
      );
    }
    clone() {
      return new yh(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(e) {
      return (
        (this.x = e.x),
        (this.y = e.y),
        (this.width = e.width),
        (this.height = e.height),
        this
      );
    }
    copyTo(e) {
      return e.copyFrom(this), e;
    }
    contains(e, t) {
      if (this.width <= 0 || this.height <= 0) return !1;
      if (
        e >= this.x &&
        e <= this.x + this.width &&
        t >= this.y &&
        t <= this.y + this.height
      ) {
        const a = Math.max(
          0,
          Math.min(this.radius, Math.min(this.width, this.height) / 2)
        );
        if (
          (t >= this.y + a && t <= this.y + this.height - a) ||
          (e >= this.x + a && e <= this.x + this.width - a)
        )
          return !0;
        let l = e - (this.x + a),
          o = t - (this.y + a);
        const h = a * a;
        if (
          l * l + o * o <= h ||
          ((l = e - (this.x + this.width - a)), l * l + o * o <= h) ||
          ((o = t - (this.y + this.height - a)), l * l + o * o <= h) ||
          ((l = e - (this.x + a)), l * l + o * o <= h)
        )
          return !0;
      }
      return !1;
    }
    strokeContains(e, t, a, l = 0.5) {
      const { x: o, y: h, width: c, height: u, radius: d } = this,
        f = a * (1 - l),
        p = a - f,
        g = o + d,
        _ = h + d,
        m = c - d * 2,
        w = u - d * 2,
        x = o + c,
        M = h + u;
      return (((e >= o - f && e <= o + p) || (e >= x - p && e <= x + f)) &&
        t >= _ &&
        t <= _ + w) ||
        (((t >= h - f && t <= h + p) || (t >= M - p && t <= M + f)) &&
          e >= g &&
          e <= g + m)
        ? !0
        : (e < g && t < _ && fo(e, t, g, _, d, p, f)) ||
        (e > x - d && t < _ && fo(e, t, x - d, _, d, p, f)) ||
        (e > x - d && t > M - d && fo(e, t, x - d, M - d, d, p, f)) ||
        (e < g && t > M - d && fo(e, t, g, M - d, d, p, f));
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  const tf = {};
  function xh(r, e, t) {
    let a = 2166136261;
    for (let l = 0; l < e; l++)
      (a ^= r[l].uid), (a = Math.imul(a, 16777619)), (a >>>= 0);
    return tf[a] || b_(r, e, a, t);
  }
  function b_(r, e, t, a) {
    const l = {};
    let o = 0;
    for (let c = 0; c < a; c++) {
      const u = c < e ? r[c] : te.EMPTY.source;
      (l[o++] = u.source), (l[o++] = u.style);
    }
    const h = new qi(l);
    return (tf[t] = h), h;
  }
  class rn {
    constructor(e) {
      typeof e == "number"
        ? (this.rawBinaryData = new ArrayBuffer(e))
        : e instanceof Uint8Array
          ? (this.rawBinaryData = e.buffer)
          : (this.rawBinaryData = e),
        (this.uint32View = new Uint32Array(this.rawBinaryData)),
        (this.float32View = new Float32Array(this.rawBinaryData)),
        (this.size = this.rawBinaryData.byteLength);
    }
    get int8View() {
      return (
        this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
        this._int8View
      );
    }
    get uint8View() {
      return (
        this._uint8View ||
        (this._uint8View = new Uint8Array(this.rawBinaryData)),
        this._uint8View
      );
    }
    get int16View() {
      return (
        this._int16View ||
        (this._int16View = new Int16Array(this.rawBinaryData)),
        this._int16View
      );
    }
    get int32View() {
      return (
        this._int32View ||
        (this._int32View = new Int32Array(this.rawBinaryData)),
        this._int32View
      );
    }
    get float64View() {
      return (
        this._float64Array ||
        (this._float64Array = new Float64Array(this.rawBinaryData)),
        this._float64Array
      );
    }
    get bigUint64View() {
      return (
        this._bigUint64Array ||
        (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)),
        this._bigUint64Array
      );
    }
    view(e) {
      return this[`${e}View`];
    }
    destroy() {
      (this.rawBinaryData = null),
        (this._int8View = null),
        (this._uint8View = null),
        (this._int16View = null),
        (this.uint16View = null),
        (this._int32View = null),
        (this.uint32View = null),
        (this.float32View = null);
    }
    static sizeOf(e) {
      switch (e) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(`${e} isn't a valid view type`);
      }
    }
  }
  function vh(r, e) {
    const t = (r.byteLength / 8) | 0,
      a = new Float64Array(r, 0, t);
    new Float64Array(e, 0, t).set(a);
    const o = r.byteLength - t * 8;
    if (o > 0) {
      const h = new Uint8Array(r, t * 8, o);
      new Uint8Array(e, t * 8, o).set(h);
    }
  }
  const w_ = { normal: "normal-npm", add: "add-npm", screen: "screen-npm" };
  var Ft = ((r) => (
    (r[(r.DISABLED = 0)] = "DISABLED"),
    (r[(r.RENDERING_MASK_ADD = 1)] = "RENDERING_MASK_ADD"),
    (r[(r.MASK_ACTIVE = 2)] = "MASK_ACTIVE"),
    (r[(r.INVERSE_MASK_ACTIVE = 3)] = "INVERSE_MASK_ACTIVE"),
    (r[(r.RENDERING_MASK_REMOVE = 4)] = "RENDERING_MASK_REMOVE"),
    (r[(r.NONE = 5)] = "NONE"),
    r
  ))(Ft || {});
  function jn(r, e) {
    return (e.alphaMode === "no-premultiply-alpha" && w_[r]) || r;
  }
  const S_ = [
    "precision mediump float;",
    "void main(void){",
    "float test = 0.1;",
    "%forloop%",
    "gl_FragColor = vec4(0.0);",
    "}",
  ].join(`
`);
  function M_(r) {
    let e = "";
    for (let t = 0; t < r; ++t)
      t > 0 &&
        (e += `
else `),
        t < r - 1 && (e += `if(test == ${t}.0){}`);
    return e;
  }
  function sf(r, e) {
    if (r === 0)
      throw new Error(
        "Invalid value of `0` passed to `checkMaxIfStatementsInShader`"
      );
    const t = e.createShader(e.FRAGMENT_SHADER);
    try {
      for (; ;) {
        const a = S_.replace(/%forloop%/gi, M_(r));
        if (
          (e.shaderSource(t, a),
            e.compileShader(t),
            !e.getShaderParameter(t, e.COMPILE_STATUS))
        )
          r = (r / 2) | 0;
        else break;
      }
    } finally {
      e.deleteShader(t);
    }
    return r;
  }
  let nn = null;
  function T_() {
    if (nn) return nn;
    const r = Cu();
    return (
      (nn = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS)),
      (nn = sf(nn, r)),
      r.getExtension("WEBGL_lose_context")?.loseContext(),
      nn
    );
  }
  class C_ {
    constructor() {
      (this.ids = Object.create(null)), (this.textures = []), (this.count = 0);
    }
    clear() {
      for (let e = 0; e < this.count; e++) {
        const t = this.textures[e];
        (this.textures[e] = null), (this.ids[t.uid] = null);
      }
      this.count = 0;
    }
  }
  class A_ {
    constructor() {
      (this.renderPipeId = "batch"),
        (this.action = "startBatch"),
        (this.start = 0),
        (this.size = 0),
        (this.textures = new C_()),
        (this.blendMode = "normal"),
        (this.topology = "triangle-strip"),
        (this.canBundle = !0);
    }
    destroy() {
      (this.textures = null),
        (this.gpuBindGroup = null),
        (this.bindGroup = null),
        (this.batcher = null);
    }
  }
  const Xn = [];
  let po = 0;
  Zr.register({
    clear: () => {
      if (Xn.length > 0) for (const r of Xn) r && r.destroy();
      (Xn.length = 0), (po = 0);
    },
  });
  function rf() {
    return po > 0 ? Xn[--po] : new A_();
  }
  function nf(r) {
    Xn[po++] = r;
  }
  let qn = 0;
  const af = class t1 {
    constructor(e) {
      (this.uid = et("batcher")),
        (this.dirty = !0),
        (this.batchIndex = 0),
        (this.batches = []),
        (this._elements = []),
        (e = { ...t1.defaultOptions, ...e }),
        e.maxTextures ||
        (me(
          "v8.8.0",
          "maxTextures is a required option for Batcher now, please pass it in the options"
        ),
          (e.maxTextures = T_()));
      const {
        maxTextures: t,
        attributesInitialSize: a,
        indicesInitialSize: l,
      } = e;
      (this.attributeBuffer = new rn(a * 4)),
        (this.indexBuffer = new Uint16Array(l)),
        (this.maxTextures = t);
    }
    begin() {
      (this.elementSize = 0),
        (this.elementStart = 0),
        (this.indexSize = 0),
        (this.attributeSize = 0);
      for (let e = 0; e < this.batchIndex; e++) nf(this.batches[e]);
      (this.batchIndex = 0),
        (this._batchIndexStart = 0),
        (this._batchIndexSize = 0),
        (this.dirty = !0);
    }
    add(e) {
      (this._elements[this.elementSize++] = e),
        (e._indexStart = this.indexSize),
        (e._attributeStart = this.attributeSize),
        (e._batcher = this),
        (this.indexSize += e.indexSize),
        (this.attributeSize += e.attributeSize * this.vertexSize);
    }
    checkAndUpdateTexture(e, t) {
      const a = e._batch.textures.ids[t._source.uid];
      return !a && a !== 0 ? !1 : ((e._textureId = a), (e.texture = t), !0);
    }
    updateElement(e) {
      this.dirty = !0;
      const t = this.attributeBuffer;
      e.packAsQuad
        ? this.packQuadAttributes(
          e,
          t.float32View,
          t.uint32View,
          e._attributeStart,
          e._textureId
        )
        : this.packAttributes(
          e,
          t.float32View,
          t.uint32View,
          e._attributeStart,
          e._textureId
        );
    }
    break(e) {
      const t = this._elements;
      if (!t[this.elementStart]) return;
      let a = rf(),
        l = a.textures;
      l.clear();
      const o = t[this.elementStart];
      let h = jn(o.blendMode, o.texture._source),
        c = o.topology;
      this.attributeSize * 4 > this.attributeBuffer.size &&
        this._resizeAttributeBuffer(this.attributeSize * 4),
        this.indexSize > this.indexBuffer.length &&
        this._resizeIndexBuffer(this.indexSize);
      const u = this.attributeBuffer.float32View,
        d = this.attributeBuffer.uint32View,
        f = this.indexBuffer;
      let p = this._batchIndexSize,
        g = this._batchIndexStart,
        _ = "startBatch";
      const m = this.maxTextures;
      for (let w = this.elementStart; w < this.elementSize; ++w) {
        const x = t[w];
        t[w] = null;
        const b = x.texture._source,
          T = jn(x.blendMode, b),
          C = h !== T || c !== x.topology;
        if (b._batchTick === qn && !C) {
          (x._textureId = b._textureBindLocation),
            (p += x.indexSize),
            x.packAsQuad
              ? (this.packQuadAttributes(
                x,
                u,
                d,
                x._attributeStart,
                x._textureId
              ),
                this.packQuadIndex(
                  f,
                  x._indexStart,
                  x._attributeStart / this.vertexSize
                ))
              : (this.packAttributes(x, u, d, x._attributeStart, x._textureId),
                this.packIndex(
                  x,
                  f,
                  x._indexStart,
                  x._attributeStart / this.vertexSize
                )),
            (x._batch = a);
          continue;
        }
        (b._batchTick = qn),
          (l.count >= m || C) &&
          (this._finishBatch(a, g, p - g, l, h, c, e, _),
            (_ = "renderBatch"),
            (g = p),
            (h = T),
            (c = x.topology),
            (a = rf()),
            (l = a.textures),
            l.clear(),
            ++qn),
          (x._textureId = b._textureBindLocation = l.count),
          (l.ids[b.uid] = l.count),
          (l.textures[l.count++] = b),
          (x._batch = a),
          (p += x.indexSize),
          x.packAsQuad
            ? (this.packQuadAttributes(
              x,
              u,
              d,
              x._attributeStart,
              x._textureId
            ),
              this.packQuadIndex(
                f,
                x._indexStart,
                x._attributeStart / this.vertexSize
              ))
            : (this.packAttributes(x, u, d, x._attributeStart, x._textureId),
              this.packIndex(
                x,
                f,
                x._indexStart,
                x._attributeStart / this.vertexSize
              ));
      }
      l.count > 0 &&
        (this._finishBatch(a, g, p - g, l, h, c, e, _), (g = p), ++qn),
        (this.elementStart = this.elementSize),
        (this._batchIndexStart = g),
        (this._batchIndexSize = p);
    }
    _finishBatch(e, t, a, l, o, h, c, u) {
      (e.gpuBindGroup = null),
        (e.bindGroup = null),
        (e.action = u),
        (e.batcher = this),
        (e.textures = l),
        (e.blendMode = o),
        (e.topology = h),
        (e.start = t),
        (e.size = a),
        ++qn,
        (this.batches[this.batchIndex++] = e),
        c.add(e);
    }
    finish(e) {
      this.break(e);
    }
    ensureAttributeBuffer(e) {
      e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
    }
    ensureIndexBuffer(e) {
      e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
    }
    _resizeAttributeBuffer(e) {
      const t = Math.max(e, this.attributeBuffer.size * 2),
        a = new rn(t);
      vh(this.attributeBuffer.rawBinaryData, a.rawBinaryData),
        (this.attributeBuffer = a);
    }
    _resizeIndexBuffer(e) {
      const t = this.indexBuffer;
      let a = Math.max(e, t.length * 1.5);
      a += a % 2;
      const l = a > 65535 ? new Uint32Array(a) : new Uint16Array(a);
      if (l.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT)
        for (let o = 0; o < t.length; o++) l[o] = t[o];
      else vh(t.buffer, l.buffer);
      this.indexBuffer = l;
    }
    packQuadIndex(e, t, a) {
      (e[t] = a + 0),
        (e[t + 1] = a + 1),
        (e[t + 2] = a + 2),
        (e[t + 3] = a + 0),
        (e[t + 4] = a + 2),
        (e[t + 5] = a + 3);
    }
    packIndex(e, t, a, l) {
      const o = e.indices,
        h = e.indexSize,
        c = e.indexOffset,
        u = e.attributeOffset;
      for (let d = 0; d < h; d++) t[a++] = l + o[d + c] - u;
    }
    destroy() {
      if (this.batches !== null) {
        for (let e = 0; e < this.batches.length; e++) nf(this.batches[e]);
        this.batches = null;
        for (let e = 0; e < this._elements.length; e++)
          this._elements[e] && (this._elements[e]._batch = null);
        (this._elements = null),
          (this.indexBuffer = null),
          this.attributeBuffer.destroy(),
          (this.attributeBuffer = null);
      }
    }
  };
  af.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6,
  };
  let P_ = af;
  var Fe = ((r) => (
    (r[(r.MAP_READ = 1)] = "MAP_READ"),
    (r[(r.MAP_WRITE = 2)] = "MAP_WRITE"),
    (r[(r.COPY_SRC = 4)] = "COPY_SRC"),
    (r[(r.COPY_DST = 8)] = "COPY_DST"),
    (r[(r.INDEX = 16)] = "INDEX"),
    (r[(r.VERTEX = 32)] = "VERTEX"),
    (r[(r.UNIFORM = 64)] = "UNIFORM"),
    (r[(r.STORAGE = 128)] = "STORAGE"),
    (r[(r.INDIRECT = 256)] = "INDIRECT"),
    (r[(r.QUERY_RESOLVE = 512)] = "QUERY_RESOLVE"),
    (r[(r.STATIC = 1024)] = "STATIC"),
    r
  ))(Fe || {});
  class Hs extends Os {
    constructor(e) {
      let { data: t, size: a } = e;
      const { usage: l, label: o, shrinkToFit: h } = e;
      super(),
        (this.uid = et("buffer")),
        (this._resourceType = "buffer"),
        (this._resourceId = et("resource")),
        (this._touched = 0),
        (this._updateID = 1),
        (this._dataInt32 = null),
        (this.shrinkToFit = !0),
        (this.destroyed = !1),
        t instanceof Array && (t = new Float32Array(t)),
        (this._data = t),
        a ?? (a = t?.byteLength);
      const c = !!t;
      (this.descriptor = { size: a, usage: l, mappedAtCreation: c, label: o }),
        (this.shrinkToFit = h ?? !0);
    }
    get data() {
      return this._data;
    }
    set data(e) {
      this.setDataWithSize(e, e.length, !0);
    }
    get dataInt32() {
      return (
        this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)),
        this._dataInt32
      );
    }
    get static() {
      return !!(this.descriptor.usage & Fe.STATIC);
    }
    set static(e) {
      e
        ? (this.descriptor.usage |= Fe.STATIC)
        : (this.descriptor.usage &= ~Fe.STATIC);
    }
    setDataWithSize(e, t, a) {
      if (
        (this._updateID++,
          (this._updateSize = t * e.BYTES_PER_ELEMENT),
          this._data === e)
      ) {
        a && this.emit("update", this);
        return;
      }
      const l = this._data;
      if (
        ((this._data = e),
          (this._dataInt32 = null),
          !l || l.length !== e.length)
      ) {
        !this.shrinkToFit && l && e.byteLength < l.byteLength
          ? a && this.emit("update", this)
          : ((this.descriptor.size = e.byteLength),
            (this._resourceId = et("resource")),
            this.emit("change", this));
        return;
      }
      a && this.emit("update", this);
    }
    update(e) {
      (this._updateSize = e ?? this._updateSize),
        this._updateID++,
        this.emit("update", this);
    }
    destroy() {
      (this.destroyed = !0),
        this.emit("destroy", this),
        this.emit("change", this),
        (this._data = null),
        (this.descriptor = null),
        this.removeAllListeners();
    }
  }
  function of(r, e) {
    if (!(r instanceof Hs)) {
      let t = e ? Fe.INDEX : Fe.VERTEX;
      r instanceof Array &&
        (e
          ? ((r = new Uint32Array(r)), (t = Fe.INDEX | Fe.COPY_DST))
          : ((r = new Float32Array(r)), (t = Fe.VERTEX | Fe.COPY_DST))),
        (r = new Hs({
          data: r,
          label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
          usage: t,
        }));
    }
    return r;
  }
  function E_(r, e, t) {
    const a = r.getAttribute(e);
    if (!a) return (t.minX = 0), (t.minY = 0), (t.maxX = 0), (t.maxY = 0), t;
    const l = a.buffer.data;
    let o = 1 / 0,
      h = 1 / 0,
      c = -1 / 0,
      u = -1 / 0;
    const d = l.BYTES_PER_ELEMENT,
      f = (a.offset || 0) / d,
      p = (a.stride || 8) / d;
    for (let g = f; g < l.length; g += p) {
      const _ = l[g],
        m = l[g + 1];
      _ > c && (c = _), m > u && (u = m), _ < o && (o = _), m < h && (h = m);
    }
    return (t.minX = o), (t.minY = h), (t.maxX = c), (t.maxY = u), t;
  }
  function k_(r) {
    return (
      (r instanceof Hs || Array.isArray(r) || r.BYTES_PER_ELEMENT) &&
      (r = { buffer: r }),
      (r.buffer = of(r.buffer, !1)),
      r
    );
  }
  class Yn extends Os {
    constructor(e = {}) {
      super(),
        (this.uid = et("geometry")),
        (this._layoutKey = 0),
        (this.instanceCount = 1),
        (this._bounds = new cs()),
        (this._boundsDirty = !0);
      const { attributes: t, indexBuffer: a, topology: l } = e;
      if (((this.buffers = []), (this.attributes = {}), t))
        for (const o in t) this.addAttribute(o, t[o]);
      (this.instanceCount = e.instanceCount ?? 1),
        a && this.addIndex(a),
        (this.topology = l || "triangle-list");
    }
    onBufferUpdate() {
      (this._boundsDirty = !0), this.emit("update", this);
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(e) {
      return this.getAttribute(e).buffer;
    }
    getSize() {
      for (const e in this.attributes) {
        const t = this.attributes[e];
        return t.buffer.data.length / (t.stride / 4 || t.size);
      }
      return 0;
    }
    addAttribute(e, t) {
      const a = k_(t);
      this.buffers.indexOf(a.buffer) === -1 &&
        (this.buffers.push(a.buffer),
          a.buffer.on("update", this.onBufferUpdate, this),
          a.buffer.on("change", this.onBufferUpdate, this)),
        (this.attributes[e] = a);
    }
    addIndex(e) {
      (this.indexBuffer = of(e, !0)), this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      return this._boundsDirty
        ? ((this._boundsDirty = !1), E_(this, "aPosition", this._bounds))
        : this._bounds;
    }
    destroy(e = !1) {
      this.emit("destroy", this),
        this.removeAllListeners(),
        e && this.buffers.forEach((t) => t.destroy()),
        (this.attributes = null),
        (this.buffers = null),
        (this.indexBuffer = null),
        (this._bounds = null);
    }
  }
  const R_ = new Float32Array(1),
    I_ = new Uint32Array(1);
  class B_ extends Yn {
    constructor() {
      const t = new Hs({
        data: R_,
        label: "attribute-batch-buffer",
        usage: Fe.VERTEX | Fe.COPY_DST,
        shrinkToFit: !1,
      }),
        a = new Hs({
          data: I_,
          label: "index-batch-buffer",
          usage: Fe.INDEX | Fe.COPY_DST,
          shrinkToFit: !1,
        }),
        l = 24;
      super({
        attributes: {
          aPosition: { buffer: t, format: "float32x2", stride: l, offset: 0 },
          aUV: { buffer: t, format: "float32x2", stride: l, offset: 8 },
          aColor: { buffer: t, format: "unorm8x4", stride: l, offset: 16 },
          aTextureIdAndRound: {
            buffer: t,
            format: "uint16x2",
            stride: l,
            offset: 20,
          },
        },
        indexBuffer: a,
      });
    }
  }
  function lf(r, e, t) {
    if (r)
      for (const a in r) {
        const l = a.toLocaleLowerCase(),
          o = e[l];
        if (o) {
          let h = r[a];
          a === "header" &&
            (h = h
              .replace(/@in\s+[^;]+;\s*/g, "")
              .replace(/@out\s+[^;]+;\s*/g, "")),
            t && o.push(`//----${t}----//`),
            o.push(h);
        } else pe(`${a} placement hook does not exist in shader`);
      }
  }
  const F_ = /\{\{(.*?)\}\}/g;
  function hf(r) {
    const e = {};
    return (
      (r.match(F_)?.map((a) => a.replace(/[{()}]/g, "")) ?? []).forEach((a) => {
        e[a] = [];
      }),
      e
    );
  }
  function cf(r, e) {
    let t;
    const a = /@in\s+([^;]+);/g;
    for (; (t = a.exec(r)) !== null;) e.push(t[1]);
  }
  function df(r, e, t = !1) {
    const a = [];
    cf(e, a),
      r.forEach((c) => {
        c.header && cf(c.header, a);
      });
    const l = a;
    t && l.sort();
    const o = l.map((c, u) => `       @location(${u}) ${c},`).join(`
`);
    let h = e.replace(/@in\s+[^;]+;\s*/g, "");
    return (
      (h = h.replace(
        "{{in}}",
        `
${o}
`
      )),
      h
    );
  }
  function uf(r, e) {
    let t;
    const a = /@out\s+([^;]+);/g;
    for (; (t = a.exec(r)) !== null;) e.push(t[1]);
  }
  function G_(r) {
    const t = /\b(\w+)\s*:/g.exec(r);
    return t ? t[1] : "";
  }
  function D_(r) {
    const e = /@.*?\s+/g;
    return r.replace(e, "");
  }
  function U_(r, e) {
    const t = [];
    uf(e, t),
      r.forEach((u) => {
        u.header && uf(u.header, t);
      });
    let a = 0;
    const l = t
      .sort()
      .map((u) => (u.indexOf("builtin") > -1 ? u : `@location(${a++}) ${u}`))
      .join(`,
`),
      o = t.sort().map((u) => `       var ${D_(u)};`).join(`

`),
      h = `return VSOutput(
            ${t.sort().map((u) => ` ${G_(u)}`).join(`,
`)});`;
    let c = e.replace(/@out\s+[^;]+;\s*/g, "");
    return (
      (c = c.replace(
        "{{struct}}",
        `
${l}
`
      )),
      (c = c.replace(
        "{{start}}",
        `
${o}
`
      )),
      (c = c.replace(
        "{{return}}",
        `
${h}
`
      )),
      c
    );
  }
  function ff(r, e) {
    let t = r;
    for (const a in e) {
      const l = e[a];
      l.join(`
`).length
        ? (t = t.replace(
          `{{${a}}}`,
          `//-----${a} START-----//
${l.join(`
`)}
//----${a} FINISH----//`
        ))
        : (t = t.replace(`{{${a}}}`, ""));
    }
    return t;
  }
  const hr = Object.create(null),
    bh = new Map();
  let O_ = 0;
  function L_({ template: r, bits: e }) {
    const t = pf(r, e);
    if (hr[t]) return hr[t];
    const { vertex: a, fragment: l } = H_(r, e);
    return (hr[t] = gf(a, l, e)), hr[t];
  }
  function N_({ template: r, bits: e }) {
    const t = pf(r, e);
    return hr[t] || (hr[t] = gf(r.vertex, r.fragment, e)), hr[t];
  }
  function H_(r, e) {
    const t = e.map((h) => h.vertex).filter((h) => !!h),
      a = e.map((h) => h.fragment).filter((h) => !!h);
    let l = df(t, r.vertex, !0);
    l = U_(t, l);
    const o = df(a, r.fragment, !0);
    return { vertex: l, fragment: o };
  }
  function pf(r, e) {
    return (
      e
        .map((t) => (bh.has(t) || bh.set(t, O_++), bh.get(t)))
        .sort((t, a) => t - a)
        .join("-") +
      r.vertex +
      r.fragment
    );
  }
  function gf(r, e, t) {
    const a = hf(r),
      l = hf(e);
    return (
      t.forEach((o) => {
        lf(o.vertex, a, o.name), lf(o.fragment, l, o.name);
      }),
      { vertex: ff(r, a), fragment: ff(e, l) }
    );
  }
  const z_ = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,
    W_ = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,
    V_ = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,
    j_ = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`,
    X_ = {
      name: "global-uniforms-bit",
      vertex: {
        header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `,
      },
    },
    q_ = {
      name: "global-uniforms-bit",
      vertex: {
        header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;        `,
      },
    };
  function $n({ bits: r, name: e }) {
    const t = L_({ template: { fragment: W_, vertex: z_ }, bits: [X_, ...r] });
    return Ir.from({
      name: e,
      vertex: { source: t.vertex, entryPoint: "main" },
      fragment: { source: t.fragment, entryPoint: "main" },
    });
  }
  function Kn({ bits: r, name: e }) {
    return new tn({
      name: e,
      ...N_({ template: { vertex: V_, fragment: j_ }, bits: [q_, ...r] }),
    });
  }
  const wh = {
    name: "color-bit",
    vertex: {
      header: `
            @in aColor: vec4<f32>;
        `,
      main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `,
    },
  },
    Sh = {
      name: "color-bit",
      vertex: {
        header: `
            in vec4 aColor;
        `,
        main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `,
      },
    },
    Mh = {};
  function Y_(r) {
    const e = [];
    if (r === 1)
      e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),
        e.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
      let t = 0;
      for (let a = 0; a < r; a++)
        e.push(
          `@group(1) @binding(${t++}) var textureSource${a + 1
          }: texture_2d<f32>;`
        ),
          e.push(
            `@group(1) @binding(${t++}) var textureSampler${a + 1}: sampler;`
          );
    }
    return e.join(`
`);
  }
  function $_(r) {
    const e = [];
    if (r === 1)
      e.push(
        "outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);"
      );
    else {
      e.push("switch vTextureId {");
      for (let t = 0; t < r; t++)
        t === r - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`),
          e.push(
            `      outColor = textureSampleGrad(textureSource${t + 1
            }, textureSampler${t + 1}, vUV, uvDx, uvDy);`
          ),
          e.push("      break;}");
      e.push("}");
    }
    return e.join(`
`);
  }
  function Th(r) {
    return (
      Mh[r] ||
      (Mh[r] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `,
        },
        fragment: {
          header: `
                @in @interpolate(flat) vTextureId: u32;

                ${Y_(r)}
            `,
          main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${$_(r)}
            `,
        },
      }),
      Mh[r]
    );
  }
  const Ch = {};
  function K_(r) {
    const e = [];
    for (let t = 0; t < r; t++)
      t > 0 && e.push("else"),
        t < r - 1 && e.push(`if(vTextureId < ${t}.5)`),
        e.push("{"),
        e.push(`	outColor = texture(uTextures[${t}], vUV);`),
        e.push("}");
    return e.join(`
`);
  }
  function Ah(r) {
    return (
      Ch[r] ||
      (Ch[r] = {
        name: "texture-batch-bit",
        vertex: {
          header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
          main: `
                vTextureId = aTextureIdAndRound.y;
            `,
          end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `,
        },
        fragment: {
          header: `
                in float vTextureId;

                uniform sampler2D uTextures[${r}];

            `,
          main: `

                ${K_(r)}            `,
        },
      }),
      Ch[r]
    );
  }
  const Zn = {
    name: "round-pixels-bit",
    vertex: {
      header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
    },
  },
    Qn = {
      name: "round-pixels-bit",
      vertex: {
        header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `,
      },
    },
    mf = {};
  function Ph(r) {
    let e = mf[r];
    if (e) return e;
    const t = new Int32Array(r);
    for (let a = 0; a < r; a++) t[a] = a;
    return (
      (e = mf[r] =
        new ys(
          { uTextures: { value: t, type: "i32", size: r } },
          { isStatic: !0 }
        )),
      e
    );
  }
  class Z_ extends ei {
    constructor(e) {
      const t = Kn({ name: "batch", bits: [Sh, Ah(e), Qn] }),
        a = $n({ name: "batch", bits: [wh, Th(e), Zn] });
      super({
        glProgram: t,
        gpuProgram: a,
        resources: { batchSamplers: Ph(e) },
      });
    }
  }
  let Eh = null;
  const _f = class s1 extends P_ {
    constructor(e) {
      super(e),
        (this.geometry = new B_()),
        (this.name = s1.extension.name),
        (this.vertexSize = 6),
        Eh ?? (Eh = new Z_(e.maxTextures)),
        (this.shader = Eh);
    }
    packAttributes(e, t, a, l, o) {
      const h = (o << 16) | (e.roundPixels & 65535),
        c = e.transform,
        u = c.a,
        d = c.b,
        f = c.c,
        p = c.d,
        g = c.tx,
        _ = c.ty,
        { positions: m, uvs: w } = e,
        x = e.color,
        M = e.attributeOffset,
        b = M + e.attributeSize;
      for (let T = M; T < b; T++) {
        const C = T * 2,
          A = m[C],
          R = m[C + 1];
        (t[l++] = u * A + f * R + g),
          (t[l++] = p * R + d * A + _),
          (t[l++] = w[C]),
          (t[l++] = w[C + 1]),
          (a[l++] = x),
          (a[l++] = h);
      }
    }
    packQuadAttributes(e, t, a, l, o) {
      const h = e.texture,
        c = e.transform,
        u = c.a,
        d = c.b,
        f = c.c,
        p = c.d,
        g = c.tx,
        _ = c.ty,
        m = e.bounds,
        w = m.maxX,
        x = m.minX,
        M = m.maxY,
        b = m.minY,
        T = h.uvs,
        C = e.color,
        A = (o << 16) | (e.roundPixels & 65535);
      (t[l + 0] = u * x + f * b + g),
        (t[l + 1] = p * b + d * x + _),
        (t[l + 2] = T.x0),
        (t[l + 3] = T.y0),
        (a[l + 4] = C),
        (a[l + 5] = A),
        (t[l + 6] = u * w + f * b + g),
        (t[l + 7] = p * b + d * w + _),
        (t[l + 8] = T.x1),
        (t[l + 9] = T.y1),
        (a[l + 10] = C),
        (a[l + 11] = A),
        (t[l + 12] = u * w + f * M + g),
        (t[l + 13] = p * M + d * w + _),
        (t[l + 14] = T.x2),
        (t[l + 15] = T.y2),
        (a[l + 16] = C),
        (a[l + 17] = A),
        (t[l + 18] = u * x + f * M + g),
        (t[l + 19] = p * M + d * x + _),
        (t[l + 20] = T.x3),
        (t[l + 21] = T.y3),
        (a[l + 22] = C),
        (a[l + 23] = A);
    }
  };
  _f.extension = { type: [P.Batcher], name: "default" };
  let kh = _f;
  function Q_(r, e, t, a, l, o, h, c = null) {
    let u = 0;
    (t *= e), (l *= o);
    const d = c.a,
      f = c.b,
      p = c.c,
      g = c.d,
      _ = c.tx,
      m = c.ty;
    for (; u < h;) {
      const w = r[t],
        x = r[t + 1];
      (a[l] = d * w + p * x + _),
        (a[l + 1] = f * w + g * x + m),
        (l += o),
        (t += e),
        u++;
    }
  }
  function J_(r, e, t, a) {
    let l = 0;
    for (e *= t; l < a;) (r[e] = 0), (r[e + 1] = 0), (e += t), l++;
  }
  function yf(r, e, t, a, l) {
    const o = e.a,
      h = e.b,
      c = e.c,
      u = e.d,
      d = e.tx,
      f = e.ty;
    t || (t = 0), a || (a = 2), l || (l = r.length / a - t);
    let p = t * a;
    for (let g = 0; g < l; g++) {
      const _ = r[p],
        m = r[p + 1];
      (r[p] = o * _ + c * m + d), (r[p + 1] = h * _ + u * m + f), (p += a);
    }
  }
  const ey = new ae();
  class Rh {
    constructor() {
      (this.packAsQuad = !1),
        (this.batcherName = "default"),
        (this.topology = "triangle-list"),
        (this.applyTransform = !0),
        (this.roundPixels = 0),
        (this._batcher = null),
        (this._batch = null);
    }
    get uvs() {
      return this.geometryData.uvs;
    }
    get positions() {
      return this.geometryData.vertices;
    }
    get indices() {
      return this.geometryData.indices;
    }
    get blendMode() {
      return this.renderable && this.applyTransform
        ? this.renderable.groupBlendMode
        : "normal";
    }
    get color() {
      const e = this.baseColor,
        t = (e >> 16) | (e & 65280) | ((e & 255) << 16),
        a = this.renderable;
      return a
        ? Vd(t, a.groupColor) + ((this.alpha * a.groupAlpha * 255) << 24)
        : t + ((this.alpha * 255) << 24);
    }
    get transform() {
      return this.renderable?.groupTransform || ey;
    }
    copyTo(e) {
      (e.indexOffset = this.indexOffset),
        (e.indexSize = this.indexSize),
        (e.attributeOffset = this.attributeOffset),
        (e.attributeSize = this.attributeSize),
        (e.baseColor = this.baseColor),
        (e.alpha = this.alpha),
        (e.texture = this.texture),
        (e.geometryData = this.geometryData),
        (e.topology = this.topology);
    }
    reset() {
      (this.applyTransform = !0),
        (this.renderable = null),
        (this.topology = "triangle-list");
    }
    destroy() {
      (this.renderable = null),
        (this.texture = null),
        (this.geometryData = null),
        (this._batcher = null),
        (this._batch = null);
    }
  }
  const Jn = {
    extension: { type: P.ShapeBuilder, name: "circle" },
    build(r, e) {
      let t, a, l, o, h, c;
      if (r.type === "circle") {
        const C = r;
        if (((h = c = C.radius), h <= 0)) return !1;
        (t = C.x), (a = C.y), (l = o = 0);
      } else if (r.type === "ellipse") {
        const C = r;
        if (((h = C.halfWidth), (c = C.halfHeight), h <= 0 || c <= 0))
          return !1;
        (t = C.x), (a = C.y), (l = o = 0);
      } else {
        const C = r,
          A = C.width / 2,
          R = C.height / 2;
        (t = C.x + A),
          (a = C.y + R),
          (h = c = Math.max(0, Math.min(C.radius, Math.min(A, R)))),
          (l = A - h),
          (o = R - c);
      }
      if (l < 0 || o < 0) return !1;
      const u = Math.ceil(2.3 * Math.sqrt(h + c)),
        d = u * 8 + (l ? 4 : 0) + (o ? 4 : 0);
      if (d === 0) return !1;
      if (u === 0)
        return (
          (e[0] = e[6] = t + l),
          (e[1] = e[3] = a + o),
          (e[2] = e[4] = t - l),
          (e[5] = e[7] = a - o),
          !0
        );
      let f = 0,
        p = u * 4 + (l ? 2 : 0) + 2,
        g = p,
        _ = d,
        m = l + h,
        w = o,
        x = t + m,
        M = t - m,
        b = a + w;
      if (((e[f++] = x), (e[f++] = b), (e[--p] = b), (e[--p] = M), o)) {
        const C = a - w;
        (e[g++] = M), (e[g++] = C), (e[--_] = C), (e[--_] = x);
      }
      for (let C = 1; C < u; C++) {
        const A = (Math.PI / 2) * (C / u),
          R = l + Math.cos(A) * h,
          k = o + Math.sin(A) * c,
          W = t + R,
          D = t - R,
          I = a + k,
          y = a - k;
        (e[f++] = W),
          (e[f++] = I),
          (e[--p] = I),
          (e[--p] = D),
          (e[g++] = D),
          (e[g++] = y),
          (e[--_] = y),
          (e[--_] = W);
      }
      (m = l), (w = o + c), (x = t + m), (M = t - m), (b = a + w);
      const T = a - w;
      return (
        (e[f++] = x),
        (e[f++] = b),
        (e[--_] = T),
        (e[--_] = x),
        l && ((e[f++] = M), (e[f++] = b), (e[--_] = T), (e[--_] = M)),
        !0
      );
    },
    triangulate(r, e, t, a, l, o) {
      if (r.length === 0) return;
      let h = 0,
        c = 0;
      for (let f = 0; f < r.length; f += 2) (h += r[f]), (c += r[f + 1]);
      (h /= r.length / 2), (c /= r.length / 2);
      let u = a;
      (e[u * t] = h), (e[u * t + 1] = c);
      const d = u++;
      for (let f = 0; f < r.length; f += 2)
        (e[u * t] = r[f]),
          (e[u * t + 1] = r[f + 1]),
          f > 0 && ((l[o++] = u), (l[o++] = d), (l[o++] = u - 1)),
          u++;
      (l[o++] = d + 1), (l[o++] = d), (l[o++] = u - 1);
    },
  },
    ty = { ...Jn, extension: { ...Jn.extension, name: "ellipse" } },
    sy = { ...Jn, extension: { ...Jn.extension, name: "roundedRectangle" } },
    xf = 1e-4,
    vf = 1e-4;
  function iy(r) {
    const e = r.length;
    if (e < 6) return 1;
    let t = 0;
    for (let a = 0, l = r[e - 2], o = r[e - 1]; a < e; a += 2) {
      const h = r[a],
        c = r[a + 1];
      (t += (h - l) * (c + o)), (l = h), (o = c);
    }
    return t < 0 ? -1 : 1;
  }
  function bf(r, e, t, a, l, o, h, c) {
    const u = r - t * l,
      d = e - a * l,
      f = r + t * o,
      p = e + a * o;
    let g, _;
    h ? ((g = a), (_ = -t)) : ((g = -a), (_ = t));
    const m = u + g,
      w = d + _,
      x = f + g,
      M = p + _;
    return c.push(m, w), c.push(x, M), 2;
  }
  function Fr(r, e, t, a, l, o, h, c) {
    const u = t - r,
      d = a - e;
    let f = Math.atan2(u, d),
      p = Math.atan2(l - r, o - e);
    c && f < p ? (f += Math.PI * 2) : !c && f > p && (p += Math.PI * 2);
    let g = f;
    const _ = p - f,
      m = Math.abs(_),
      w = Math.sqrt(u * u + d * d),
      x = (((15 * m * Math.sqrt(w)) / Math.PI) >> 0) + 1,
      M = _ / x;
    if (((g += M), c)) {
      h.push(r, e), h.push(t, a);
      for (let b = 1, T = g; b < x; b++, T += M)
        h.push(r, e), h.push(r + Math.sin(T) * w, e + Math.cos(T) * w);
      h.push(r, e), h.push(l, o);
    } else {
      h.push(t, a), h.push(r, e);
      for (let b = 1, T = g; b < x; b++, T += M)
        h.push(r + Math.sin(T) * w, e + Math.cos(T) * w), h.push(r, e);
      h.push(l, o), h.push(r, e);
    }
    return x * 2;
  }
  function ry(r, e, t, a, l, o) {
    const h = xf;
    if (r.length === 0) return;
    const c = e;
    let u = c.alignment;
    if (e.alignment !== 0.5) {
      let S = iy(r);
      u = (u - 0.5) * S + 0.5;
    }
    const d = new Je(r[0], r[1]),
      f = new Je(r[r.length - 2], r[r.length - 1]),
      p = a,
      g = Math.abs(d.x - f.x) < h && Math.abs(d.y - f.y) < h;
    if (p) {
      (r = r.slice()),
        g && (r.pop(), r.pop(), f.set(r[r.length - 2], r[r.length - 1]));
      const S = (d.x + f.x) * 0.5,
        J = (f.y + d.y) * 0.5;
      r.unshift(S, J), r.push(S, J);
    }
    const _ = l,
      m = r.length / 2;
    let w = r.length;
    const x = _.length / 2,
      M = c.width / 2,
      b = M * M,
      T = c.miterLimit * c.miterLimit;
    let C = r[0],
      A = r[1],
      R = r[2],
      k = r[3],
      W = 0,
      D = 0,
      I = -(A - k),
      y = C - R,
      Z = 0,
      V = 0,
      z = Math.sqrt(I * I + y * y);
    (I /= z), (y /= z), (I *= M), (y *= M);
    const $ = u,
      B = (1 - $) * 2,
      re = $ * 2;
    p ||
      (c.cap === "round"
        ? (w +=
          Fr(
            C - I * (B - re) * 0.5,
            A - y * (B - re) * 0.5,
            C - I * B,
            A - y * B,
            C + I * re,
            A + y * re,
            _,
            !0
          ) + 2)
        : c.cap === "square" && (w += bf(C, A, I, y, B, re, !0, _))),
      _.push(C - I * B, A - y * B),
      _.push(C + I * re, A + y * re);
    for (let S = 1; S < m - 1; ++S) {
      (C = r[(S - 1) * 2]),
        (A = r[(S - 1) * 2 + 1]),
        (R = r[S * 2]),
        (k = r[S * 2 + 1]),
        (W = r[(S + 1) * 2]),
        (D = r[(S + 1) * 2 + 1]),
        (I = -(A - k)),
        (y = C - R),
        (z = Math.sqrt(I * I + y * y)),
        (I /= z),
        (y /= z),
        (I *= M),
        (y *= M),
        (Z = -(k - D)),
        (V = R - W),
        (z = Math.sqrt(Z * Z + V * V)),
        (Z /= z),
        (V /= z),
        (Z *= M),
        (V *= M);
      const J = R - C,
        F = A - k,
        ht = R - W,
        it = D - k,
        Ue = J * ht + F * it,
        rs = F * ht - it * J,
        bs = rs < 0;
      if (Math.abs(rs) < 0.001 * Math.abs(Ue)) {
        _.push(R - I * B, k - y * B),
          _.push(R + I * re, k + y * re),
          Ue >= 0 &&
          (c.join === "round"
            ? (w +=
              Fr(R, k, R - I * B, k - y * B, R - Z * B, k - V * B, _, !1) +
              4)
            : (w += 2),
            _.push(R - Z * re, k - V * re),
            _.push(R + Z * B, k + V * B));
        continue;
      }
      const Ss = (-I + C) * (-y + k) - (-I + R) * (-y + A),
        oi = (-Z + W) * (-V + k) - (-Z + R) * (-V + D),
        Fi = (J * oi - ht * Ss) / rs,
        wr = (it * Ss - F * oi) / rs,
        Sr = (Fi - R) * (Fi - R) + (wr - k) * (wr - k),
        Et = R + (Fi - R) * B,
        Ut = k + (wr - k) * B,
        ds = R - (Fi - R) * re,
        O = k - (wr - k) * re,
        H = Math.min(J * J + F * F, ht * ht + it * it),
        ke = bs ? B : re,
        ct = H + ke * ke * b;
      Sr <= ct
        ? c.join === "bevel" || Sr / b > T
          ? (bs
            ? (_.push(Et, Ut),
              _.push(R + I * re, k + y * re),
              _.push(Et, Ut),
              _.push(R + Z * re, k + V * re))
            : (_.push(R - I * B, k - y * B),
              _.push(ds, O),
              _.push(R - Z * B, k - V * B),
              _.push(ds, O)),
            (w += 2))
          : c.join === "round"
            ? bs
              ? (_.push(Et, Ut),
                _.push(R + I * re, k + y * re),
                (w +=
                  Fr(
                    R,
                    k,
                    R + I * re,
                    k + y * re,
                    R + Z * re,
                    k + V * re,
                    _,
                    !0
                  ) + 4),
                _.push(Et, Ut),
                _.push(R + Z * re, k + V * re))
              : (_.push(R - I * B, k - y * B),
                _.push(ds, O),
                (w +=
                  Fr(R, k, R - I * B, k - y * B, R - Z * B, k - V * B, _, !1) +
                  4),
                _.push(R - Z * B, k - V * B),
                _.push(ds, O))
            : (_.push(Et, Ut), _.push(ds, O))
        : (_.push(R - I * B, k - y * B),
          _.push(R + I * re, k + y * re),
          c.join === "round"
            ? bs
              ? (w +=
                Fr(
                  R,
                  k,
                  R + I * re,
                  k + y * re,
                  R + Z * re,
                  k + V * re,
                  _,
                  !0
                ) + 2)
              : (w +=
                Fr(R, k, R - I * B, k - y * B, R - Z * B, k - V * B, _, !1) +
                2)
            : c.join === "miter" &&
            Sr / b <= T &&
            (bs
              ? (_.push(ds, O), _.push(ds, O))
              : (_.push(Et, Ut), _.push(Et, Ut)),
              (w += 2)),
          _.push(R - Z * B, k - V * B),
          _.push(R + Z * re, k + V * re),
          (w += 2));
    }
    (C = r[(m - 2) * 2]),
      (A = r[(m - 2) * 2 + 1]),
      (R = r[(m - 1) * 2]),
      (k = r[(m - 1) * 2 + 1]),
      (I = -(A - k)),
      (y = C - R),
      (z = Math.sqrt(I * I + y * y)),
      (I /= z),
      (y /= z),
      (I *= M),
      (y *= M),
      _.push(R - I * B, k - y * B),
      _.push(R + I * re, k + y * re),
      p ||
      (c.cap === "round"
        ? (w +=
          Fr(
            R - I * (B - re) * 0.5,
            k - y * (B - re) * 0.5,
            R - I * B,
            k - y * B,
            R + I * re,
            k + y * re,
            _,
            !1
          ) + 2)
        : c.cap === "square" && (w += bf(R, k, I, y, B, re, !1, _)));
    const qe = vf * vf;
    for (let S = x; S < w + x - 2; ++S)
      (C = _[S * 2]),
        (A = _[S * 2 + 1]),
        (R = _[(S + 1) * 2]),
        (k = _[(S + 1) * 2 + 1]),
        (W = _[(S + 2) * 2]),
        (D = _[(S + 2) * 2 + 1]),
        !(Math.abs(C * (k - D) + R * (D - A) + W * (A - k)) < qe) &&
        o.push(S, S + 1, S + 2);
  }
  function ny(r, e, t, a) {
    const l = xf;
    if (r.length === 0) return;
    const o = r[0],
      h = r[1],
      c = r[r.length - 2],
      u = r[r.length - 1],
      d = e || (Math.abs(o - c) < l && Math.abs(h - u) < l),
      f = t,
      p = r.length / 2,
      g = f.length / 2;
    for (let _ = 0; _ < p; _++) f.push(r[_ * 2]), f.push(r[_ * 2 + 1]);
    for (let _ = 0; _ < p - 1; _++) a.push(g + _, g + _ + 1);
    d && a.push(g + p - 1, g);
  }
  function wf(r, e, t, a, l, o, h) {
    const c = a_(r, e, 2);
    if (!c) return;
    for (let d = 0; d < c.length; d += 3)
      (o[h++] = c[d] + l), (o[h++] = c[d + 1] + l), (o[h++] = c[d + 2] + l);
    let u = l * a;
    for (let d = 0; d < r.length; d += 2)
      (t[u] = r[d]), (t[u + 1] = r[d + 1]), (u += a);
  }
  const oy = [],
    ly = {
      extension: { type: P.ShapeBuilder, name: "polygon" },
      build(r, e) {
        for (let t = 0; t < r.points.length; t++) e[t] = r.points[t];
        return !0;
      },
      triangulate(r, e, t, a, l, o) {
        wf(r, oy, e, t, a, l, o);
      },
    },
    hy = {
      extension: { type: P.ShapeBuilder, name: "rectangle" },
      build(r, e) {
        const t = r,
          a = t.x,
          l = t.y,
          o = t.width,
          h = t.height;
        return o > 0 && h > 0
          ? ((e[0] = a),
            (e[1] = l),
            (e[2] = a + o),
            (e[3] = l),
            (e[4] = a + o),
            (e[5] = l + h),
            (e[6] = a),
            (e[7] = l + h),
            !0)
          : !1;
      },
      triangulate(r, e, t, a, l, o) {
        let h = 0;
        (a *= t),
          (e[a + h] = r[0]),
          (e[a + h + 1] = r[1]),
          (h += t),
          (e[a + h] = r[2]),
          (e[a + h + 1] = r[3]),
          (h += t),
          (e[a + h] = r[6]),
          (e[a + h + 1] = r[7]),
          (h += t),
          (e[a + h] = r[4]),
          (e[a + h + 1] = r[5]),
          (h += t);
        const c = a / t;
        (l[o++] = c),
          (l[o++] = c + 1),
          (l[o++] = c + 2),
          (l[o++] = c + 1),
          (l[o++] = c + 3),
          (l[o++] = c + 2);
      },
    },
    cy = {
      extension: { type: P.ShapeBuilder, name: "triangle" },
      build(r, e) {
        return (
          (e[0] = r.x),
          (e[1] = r.y),
          (e[2] = r.x2),
          (e[3] = r.y2),
          (e[4] = r.x3),
          (e[5] = r.y3),
          !0
        );
      },
      triangulate(r, e, t, a, l, o) {
        let h = 0;
        (a *= t),
          (e[a + h] = r[0]),
          (e[a + h + 1] = r[1]),
          (h += t),
          (e[a + h] = r[2]),
          (e[a + h + 1] = r[3]),
          (h += t),
          (e[a + h] = r[4]),
          (e[a + h + 1] = r[5]);
        const c = a / t;
        (l[o++] = c), (l[o++] = c + 1), (l[o++] = c + 2);
      },
    },
    dy = new ae(),
    uy = new Le();
  function fy(r, e, t, a) {
    const l = e.matrix ? r.copyFrom(e.matrix).invert() : r.identity();
    if (e.textureSpace === "local") {
      const h = t.getBounds(uy);
      e.width && h.pad(e.width);
      const { x: c, y: u } = h,
        d = 1 / h.width,
        f = 1 / h.height,
        p = -c * d,
        g = -u * f,
        _ = l.a,
        m = l.b,
        w = l.c,
        x = l.d;
      (l.a *= d),
        (l.b *= d),
        (l.c *= f),
        (l.d *= f),
        (l.tx = p * _ + g * w + l.tx),
        (l.ty = p * m + g * x + l.ty);
    } else
      l.translate(e.texture.frame.x, e.texture.frame.y),
        l.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
    const o = e.texture.source.style;
    return (
      !(e.fill instanceof Yi) &&
      o.addressMode === "clamp-to-edge" &&
      ((o.addressMode = "repeat"), o.update()),
      a && l.append(dy.copyFrom(a).invert()),
      l
    );
  }
  const go = {};
  ge.handleByMap(P.ShapeBuilder, go), ge.add(hy, ly, cy, Jn, ty, sy);
  const py = new Le(),
    gy = new ae();
  function my(r, e) {
    const { geometryData: t, batches: a } = e;
    (a.length = 0),
      (t.indices.length = 0),
      (t.vertices.length = 0),
      (t.uvs.length = 0);
    for (let l = 0; l < r.instructions.length; l++) {
      const o = r.instructions[l];
      if (o.action === "texture") _y(o.data, a, t);
      else if (o.action === "fill" || o.action === "stroke") {
        const h = o.action === "stroke",
          c = o.data.path.shapePath,
          u = o.data.style,
          d = o.data.hole;
        h && d && Sf(d.shapePath, u, !0, a, t),
          d &&
          (c.shapePrimitives[c.shapePrimitives.length - 1].holes =
            d.shapePath.shapePrimitives),
          Sf(c, u, h, a, t);
      }
    }
  }
  function _y(r, e, t) {
    const a = [],
      l = go.rectangle,
      o = py;
    (o.x = r.dx), (o.y = r.dy), (o.width = r.dw), (o.height = r.dh);
    const h = r.transform;
    if (!l.build(o, a)) return;
    const { vertices: c, uvs: u, indices: d } = t,
      f = d.length,
      p = c.length / 2;
    h && yf(a, h), l.triangulate(a, c, 2, p, d, f);
    const g = r.image,
      _ = g.uvs;
    u.push(_.x0, _.y0, _.x1, _.y1, _.x3, _.y3, _.x2, _.y2);
    const m = Ot.get(Rh);
    (m.indexOffset = f),
      (m.indexSize = d.length - f),
      (m.attributeOffset = p),
      (m.attributeSize = c.length / 2 - p),
      (m.baseColor = r.style),
      (m.alpha = r.alpha),
      (m.texture = g),
      (m.geometryData = t),
      e.push(m);
  }
  function Sf(r, e, t, a, l) {
    const { vertices: o, uvs: h, indices: c } = l;
    r.shapePrimitives.forEach(({ shape: u, transform: d, holes: f }) => {
      const p = [],
        g = go[u.type];
      if (!g.build(u, p)) return;
      const _ = c.length,
        m = o.length / 2;
      let w = "triangle-list";
      if ((d && yf(p, d), t)) {
        const T = u.closePath ?? !0,
          C = e;
        C.pixelLine
          ? (ny(p, T, o, c), (w = "line-list"))
          : ry(p, C, !1, T, o, c);
      } else if (f) {
        const T = [],
          C = p.slice();
        xy(f).forEach((R) => {
          T.push(C.length / 2), C.push(...R);
        }),
          wf(C, T, o, 2, m, c, _);
      } else g.triangulate(p, o, 2, m, c, _);
      const x = h.length / 2,
        M = e.texture;
      if (M !== te.WHITE) {
        const T = fy(gy, e, u, d);
        Q_(o, 2, m, h, x, 2, o.length / 2 - m, T);
      } else J_(h, x, 2, o.length / 2 - m);
      const b = Ot.get(Rh);
      (b.indexOffset = _),
        (b.indexSize = c.length - _),
        (b.attributeOffset = m),
        (b.attributeSize = o.length / 2 - m),
        (b.baseColor = e.color),
        (b.alpha = e.alpha),
        (b.texture = M),
        (b.geometryData = l),
        (b.topology = w),
        a.push(b);
    });
  }
  function xy(r) {
    const e = [];
    for (let t = 0; t < r.length; t++) {
      const a = r[t].shape,
        l = [];
      go[a.type].build(a, l) && e.push(l);
    }
    return e;
  }
  class vy {
    constructor() {
      (this.batches = []),
        (this.geometryData = { vertices: [], uvs: [], indices: [] });
    }
  }
  class by {
    constructor() {
      this.instructions = new Yd();
    }
    init(e) {
      (this.batcher = new kh({ maxTextures: e })), this.instructions.reset();
    }
    get geometry() {
      return (
        me(
          A1,
          "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."
        ),
        this.batcher.geometry
      );
    }
    destroy() {
      this.batcher.destroy(),
        this.instructions.destroy(),
        (this.batcher = null),
        (this.instructions = null);
    }
  }
  const Ih = class cd {
    constructor(e) {
      (this._gpuContextHash = {}),
        (this._graphicsDataContextHash = Object.create(null)),
        (this._renderer = e),
        e.renderableGC.addManagedHash(this, "_gpuContextHash"),
        e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(e) {
      cd.defaultOptions.bezierSmoothness =
        e?.bezierSmoothness ?? cd.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(e) {
      return (
        this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e)
      );
    }
    updateGpuContext(e) {
      let t = this._gpuContextHash[e.uid] || this._initContext(e);
      if (e.dirty) {
        t ? this._cleanGraphicsContextData(e) : (t = this._initContext(e)),
          my(e, t);
        const a = e.batchMode;
        e.customShader || a === "no-batch"
          ? (t.isBatchable = !1)
          : a === "auto"
            ? (t.isBatchable = t.geometryData.vertices.length < 400)
            : (t.isBatchable = !0),
          (e.dirty = !1);
      }
      return t;
    }
    getGpuContext(e) {
      return this._gpuContextHash[e.uid] || this._initContext(e);
    }
    _initContextRenderData(e) {
      const t = Ot.get(by, {
        maxTextures: this._renderer.limits.maxBatchableTextures,
      }),
        { batches: a, geometryData: l } = this._gpuContextHash[e.uid],
        o = l.vertices.length,
        h = l.indices.length;
      for (let f = 0; f < a.length; f++) a[f].applyTransform = !1;
      const c = t.batcher;
      c.ensureAttributeBuffer(o), c.ensureIndexBuffer(h), c.begin();
      for (let f = 0; f < a.length; f++) {
        const p = a[f];
        c.add(p);
      }
      c.finish(t.instructions);
      const u = c.geometry;
      u.indexBuffer.setDataWithSize(c.indexBuffer, c.indexSize, !0),
        u.buffers[0].setDataWithSize(
          c.attributeBuffer.float32View,
          c.attributeSize,
          !0
        );
      const d = c.batches;
      for (let f = 0; f < d.length; f++) {
        const p = d[f];
        p.bindGroup = xh(
          p.textures.textures,
          p.textures.count,
          this._renderer.limits.maxBatchableTextures
        );
      }
      return (this._graphicsDataContextHash[e.uid] = t), t;
    }
    _initContext(e) {
      const t = new vy();
      return (
        (t.context = e),
        (this._gpuContextHash[e.uid] = t),
        e.on("destroy", this.onGraphicsContextDestroy, this),
        this._gpuContextHash[e.uid]
      );
    }
    onGraphicsContextDestroy(e) {
      this._cleanGraphicsContextData(e),
        e.off("destroy", this.onGraphicsContextDestroy, this),
        (this._gpuContextHash[e.uid] = null);
    }
    _cleanGraphicsContextData(e) {
      const t = this._gpuContextHash[e.uid];
      t.isBatchable ||
        (this._graphicsDataContextHash[e.uid] &&
          (Ot.return(this.getContextRenderData(e)),
            (this._graphicsDataContextHash[e.uid] = null))),
        t.batches &&
        t.batches.forEach((a) => {
          Ot.return(a);
        });
    }
    destroy() {
      for (const e in this._gpuContextHash)
        this._gpuContextHash[e] &&
          this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
    }
  };
  (Ih.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "graphicsContext",
  }),
    (Ih.defaultOptions = { bezierSmoothness: 0.5 });
  let Bh = Ih;
  const wy = 8,
    mo = 11920929e-14,
    Sy = 1;
  function Mf(r, e, t, a, l, o, h, c, u, d) {
    const p = Math.min(
      0.99,
      Math.max(0, d ?? Bh.defaultOptions.bezierSmoothness)
    );
    let g = (Sy - p) / 1;
    return (g *= g), My(e, t, a, l, o, h, c, u, r, g), r;
  }
  function My(r, e, t, a, l, o, h, c, u, d) {
    Fh(r, e, t, a, l, o, h, c, u, d, 0), u.push(h, c);
  }
  function Fh(r, e, t, a, l, o, h, c, u, d, f) {
    if (f > wy) return;
    const p = (r + t) / 2,
      g = (e + a) / 2,
      _ = (t + l) / 2,
      m = (a + o) / 2,
      w = (l + h) / 2,
      x = (o + c) / 2,
      M = (p + _) / 2,
      b = (g + m) / 2,
      T = (_ + w) / 2,
      C = (m + x) / 2,
      A = (M + T) / 2,
      R = (b + C) / 2;
    if (f > 0) {
      let k = h - r,
        W = c - e;
      const D = Math.abs((t - h) * W - (a - c) * k),
        I = Math.abs((l - h) * W - (o - c) * k);
      if (D > mo && I > mo) {
        if ((D + I) * (D + I) <= d * (k * k + W * W)) {
          u.push(A, R);
          return;
        }
      } else if (D > mo) {
        if (D * D <= d * (k * k + W * W)) {
          u.push(A, R);
          return;
        }
      } else if (I > mo) {
        if (I * I <= d * (k * k + W * W)) {
          u.push(A, R);
          return;
        }
      } else if (
        ((k = A - (r + h) / 2), (W = R - (e + c) / 2), k * k + W * W <= d)
      ) {
        u.push(A, R);
        return;
      }
    }
    Fh(r, e, p, g, M, b, A, R, u, d, f + 1),
      Fh(A, R, T, C, w, x, h, c, u, d, f + 1);
  }
  const Ty = 8,
    Cy = 11920929e-14,
    Ay = 1;
  function Py(r, e, t, a, l, o, h, c) {
    const d = Math.min(
      0.99,
      Math.max(0, c ?? Bh.defaultOptions.bezierSmoothness)
    );
    let f = (Ay - d) / 1;
    return (f *= f), Ey(e, t, a, l, o, h, r, f), r;
  }
  function Ey(r, e, t, a, l, o, h, c) {
    Gh(h, r, e, t, a, l, o, c, 0), h.push(l, o);
  }
  function Gh(r, e, t, a, l, o, h, c, u) {
    if (u > Ty) return;
    const d = (e + a) / 2,
      f = (t + l) / 2,
      p = (a + o) / 2,
      g = (l + h) / 2,
      _ = (d + p) / 2,
      m = (f + g) / 2;
    let w = o - e,
      x = h - t;
    const M = Math.abs((a - o) * x - (l - h) * w);
    if (M > Cy) {
      if (M * M <= c * (w * w + x * x)) {
        r.push(_, m);
        return;
      }
    } else if (
      ((w = _ - (e + o) / 2), (x = m - (t + h) / 2), w * w + x * x <= c)
    ) {
      r.push(_, m);
      return;
    }
    Gh(r, e, t, d, f, _, m, c, u + 1), Gh(r, _, m, p, g, o, h, c, u + 1);
  }
  function Tf(r, e, t, a, l, o, h, c) {
    let u = Math.abs(l - o);
    ((!h && l > o) || (h && o > l)) && (u = 2 * Math.PI - u),
      c ||
      (c = Math.max(6, Math.floor(6 * Math.pow(a, 1 / 3) * (u / Math.PI)))),
      (c = Math.max(c, 3));
    let d = u / c,
      f = l;
    d *= h ? -1 : 1;
    for (let p = 0; p < c + 1; p++) {
      const g = Math.cos(f),
        _ = Math.sin(f),
        m = e + g * a,
        w = t + _ * a;
      r.push(m, w), (f += d);
    }
  }
  function ky(r, e, t, a, l, o) {
    const h = r[r.length - 2],
      u = r[r.length - 1] - t,
      d = h - e,
      f = l - t,
      p = a - e,
      g = Math.abs(u * p - d * f);
    if (g < 1e-8 || o === 0) {
      (r[r.length - 2] !== e || r[r.length - 1] !== t) && r.push(e, t);
      return;
    }
    const _ = u * u + d * d,
      m = f * f + p * p,
      w = u * f + d * p,
      x = (o * Math.sqrt(_)) / g,
      M = (o * Math.sqrt(m)) / g,
      b = (x * w) / _,
      T = (M * w) / m,
      C = x * p + M * d,
      A = x * f + M * u,
      R = d * (M + b),
      k = u * (M + b),
      W = p * (x + T),
      D = f * (x + T),
      I = Math.atan2(k - A, R - C),
      y = Math.atan2(D - A, W - C);
    Tf(r, C + e, A + t, o, I, y, d * f > p * u);
  }
  const ea = Math.PI * 2,
    Dh = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 },
    Uh = ({ x: r, y: e }, t, a, l, o, h, c, u) => {
      (r *= t), (e *= a);
      const d = l * r - o * e,
        f = o * r + l * e;
      return (u.x = d + h), (u.y = f + c), u;
    };
  function Ry(r, e) {
    const t =
      e === -1.5707963267948966
        ? -0.551915024494
        : 1.3333333333333333 * Math.tan(e / 4),
      a = e === 1.5707963267948966 ? 0.551915024494 : t,
      l = Math.cos(r),
      o = Math.sin(r),
      h = Math.cos(r + e),
      c = Math.sin(r + e);
    return [
      { x: l - o * a, y: o + l * a },
      { x: h + c * a, y: c - h * a },
      { x: h, y: c },
    ];
  }
  const Cf = (r, e, t, a) => {
    const l = r * a - e * t < 0 ? -1 : 1;
    let o = r * t + e * a;
    return o > 1 && (o = 1), o < -1 && (o = -1), l * Math.acos(o);
  },
    Iy = (r, e, t, a, l, o, h, c, u, d, f, p, g) => {
      const _ = Math.pow(l, 2),
        m = Math.pow(o, 2),
        w = Math.pow(f, 2),
        x = Math.pow(p, 2);
      let M = _ * m - _ * x - m * w;
      M < 0 && (M = 0),
        (M /= _ * x + m * w),
        (M = Math.sqrt(M) * (h === c ? -1 : 1));
      const b = ((M * l) / o) * p,
        T = ((M * -o) / l) * f,
        C = d * b - u * T + (r + t) / 2,
        A = u * b + d * T + (e + a) / 2,
        R = (f - b) / l,
        k = (p - T) / o,
        W = (-f - b) / l,
        D = (-p - T) / o,
        I = Cf(1, 0, R, k);
      let y = Cf(R, k, W, D);
      c === 0 && y > 0 && (y -= ea),
        c === 1 && y < 0 && (y += ea),
        (g.centerX = C),
        (g.centerY = A),
        (g.ang1 = I),
        (g.ang2 = y);
    };
  function By(r, e, t, a, l, o, h, c = 0, u = 0, d = 0) {
    if (o === 0 || h === 0) return;
    const f = Math.sin((c * ea) / 360),
      p = Math.cos((c * ea) / 360),
      g = (p * (e - a)) / 2 + (f * (t - l)) / 2,
      _ = (-f * (e - a)) / 2 + (p * (t - l)) / 2;
    if (g === 0 && _ === 0) return;
    (o = Math.abs(o)), (h = Math.abs(h));
    const m = Math.pow(g, 2) / Math.pow(o, 2) + Math.pow(_, 2) / Math.pow(h, 2);
    m > 1 && ((o *= Math.sqrt(m)), (h *= Math.sqrt(m))),
      Iy(e, t, a, l, o, h, u, d, f, p, g, _, Dh);
    let { ang1: w, ang2: x } = Dh;
    const { centerX: M, centerY: b } = Dh;
    let T = Math.abs(x) / (ea / 4);
    Math.abs(1 - T) < 1e-7 && (T = 1);
    const C = Math.max(Math.ceil(T), 1);
    x /= C;
    let A = r[r.length - 2],
      R = r[r.length - 1];
    const k = { x: 0, y: 0 };
    for (let W = 0; W < C; W++) {
      const D = Ry(w, x),
        { x: I, y } = Uh(D[0], o, h, p, f, M, b, k),
        { x: Z, y: V } = Uh(D[1], o, h, p, f, M, b, k),
        { x: z, y: $ } = Uh(D[2], o, h, p, f, M, b, k);
      Mf(r, A, R, I, y, Z, V, z, $), (A = z), (R = $), (w += x);
    }
  }
  function Fy(r, e, t) {
    const a = (h, c) => {
      const u = c.x - h.x,
        d = c.y - h.y,
        f = Math.sqrt(u * u + d * d),
        p = u / f,
        g = d / f;
      return { len: f, nx: p, ny: g };
    },
      l = (h, c) => {
        h === 0 ? r.moveTo(c.x, c.y) : r.lineTo(c.x, c.y);
      };
    let o = e[e.length - 1];
    for (let h = 0; h < e.length; h++) {
      const c = e[h % e.length],
        u = c.radius ?? t;
      if (u <= 0) {
        l(h, c), (o = c);
        continue;
      }
      const d = e[(h + 1) % e.length],
        f = a(c, o),
        p = a(c, d);
      if (f.len < 1e-4 || p.len < 1e-4) {
        l(h, c), (o = c);
        continue;
      }
      let g = Math.asin(f.nx * p.ny - f.ny * p.nx),
        _ = 1,
        m = !1;
      f.nx * p.nx - f.ny * -p.ny < 0
        ? g < 0
          ? (g = Math.PI + g)
          : ((g = Math.PI - g), (_ = -1), (m = !0))
        : g > 0 && ((_ = -1), (m = !0));
      const w = g / 2;
      let x,
        M = Math.abs((Math.cos(w) * u) / Math.sin(w));
      M > Math.min(f.len / 2, p.len / 2)
        ? ((M = Math.min(f.len / 2, p.len / 2)),
          (x = Math.abs((M * Math.sin(w)) / Math.cos(w))))
        : (x = u);
      const b = c.x + p.nx * M + -p.ny * x * _,
        T = c.y + p.ny * M + p.nx * x * _,
        C = Math.atan2(f.ny, f.nx) + (Math.PI / 2) * _,
        A = Math.atan2(p.ny, p.nx) - (Math.PI / 2) * _;
      h === 0 && r.moveTo(b + Math.cos(C) * x, T + Math.sin(C) * x),
        r.arc(b, T, x, C, A, m),
        (o = c);
    }
  }
  function Gy(r, e, t, a) {
    const l = (c, u) => Math.sqrt((c.x - u.x) ** 2 + (c.y - u.y) ** 2),
      o = (c, u, d) => ({ x: c.x + (u.x - c.x) * d, y: c.y + (u.y - c.y) * d }),
      h = e.length;
    for (let c = 0; c < h; c++) {
      const u = e[(c + 1) % h],
        d = u.radius ?? t;
      if (d <= 0) {
        c === 0 ? r.moveTo(u.x, u.y) : r.lineTo(u.x, u.y);
        continue;
      }
      const f = e[c],
        p = e[(c + 2) % h],
        g = l(f, u);
      let _;
      if (g < 1e-4) _ = u;
      else {
        const x = Math.min(g / 2, d);
        _ = o(u, f, x / g);
      }
      const m = l(p, u);
      let w;
      if (m < 1e-4) w = u;
      else {
        const x = Math.min(m / 2, d);
        w = o(u, p, x / m);
      }
      c === 0 ? r.moveTo(_.x, _.y) : r.lineTo(_.x, _.y),
        r.quadraticCurveTo(u.x, u.y, w.x, w.y, a);
    }
  }
  const Dy = new Le();
  class Uy {
    constructor(e) {
      (this.shapePrimitives = []),
        (this._currentPoly = null),
        (this._bounds = new cs()),
        (this._graphicsPath2D = e),
        (this.signed = e.checkForHoles);
    }
    moveTo(e, t) {
      return this.startPoly(e, t), this;
    }
    lineTo(e, t) {
      this._ensurePoly();
      const a = this._currentPoly.points,
        l = a[a.length - 2],
        o = a[a.length - 1];
      return (l !== e || o !== t) && a.push(e, t), this;
    }
    arc(e, t, a, l, o, h) {
      this._ensurePoly(!1);
      const c = this._currentPoly.points;
      return Tf(c, e, t, a, l, o, h), this;
    }
    arcTo(e, t, a, l, o) {
      this._ensurePoly();
      const h = this._currentPoly.points;
      return ky(h, e, t, a, l, o), this;
    }
    arcToSvg(e, t, a, l, o, h, c) {
      const u = this._currentPoly.points;
      return (
        By(
          u,
          this._currentPoly.lastX,
          this._currentPoly.lastY,
          h,
          c,
          e,
          t,
          a,
          l,
          o
        ),
        this
      );
    }
    bezierCurveTo(e, t, a, l, o, h, c) {
      this._ensurePoly();
      const u = this._currentPoly;
      return (
        Mf(this._currentPoly.points, u.lastX, u.lastY, e, t, a, l, o, h, c),
        this
      );
    }
    quadraticCurveTo(e, t, a, l, o) {
      this._ensurePoly();
      const h = this._currentPoly;
      return (
        Py(this._currentPoly.points, h.lastX, h.lastY, e, t, a, l, o), this
      );
    }
    closePath() {
      return this.endPoly(!0), this;
    }
    addPath(e, t) {
      this.endPoly(),
        t && !t.isIdentity() && ((e = e.clone(!0)), e.transform(t));
      const a = this.shapePrimitives,
        l = a.length;
      for (let o = 0; o < e.instructions.length; o++) {
        const h = e.instructions[o];
        this[h.action](...h.data);
      }
      if (e.checkForHoles && a.length - l > 1) {
        let o = null;
        for (let h = l; h < a.length; h++) {
          const c = a[h];
          if (c.shape.type === "polygon") {
            const u = c.shape,
              d = o?.shape;
            d && d.containsPolygon(u)
              ? (o.holes || (o.holes = []),
                o.holes.push(c),
                a.copyWithin(h, h + 1),
                a.length--,
                h--)
              : (o = c);
          }
        }
      }
      return this;
    }
    finish(e = !1) {
      this.endPoly(e);
    }
    rect(e, t, a, l, o) {
      return this.drawShape(new Le(e, t, a, l), o), this;
    }
    circle(e, t, a, l) {
      return this.drawShape(new mh(e, t, a), l), this;
    }
    poly(e, t, a) {
      const l = new Vn(e);
      return (l.closePath = t), this.drawShape(l, a), this;
    }
    regularPoly(e, t, a, l, o = 0, h) {
      l = Math.max(l | 0, 3);
      const c = (-1 * Math.PI) / 2 + o,
        u = (Math.PI * 2) / l,
        d = [];
      for (let f = 0; f < l; f++) {
        const p = c - f * u;
        d.push(e + a * Math.cos(p), t + a * Math.sin(p));
      }
      return this.poly(d, !0, h), this;
    }
    roundPoly(e, t, a, l, o, h = 0, c) {
      if (((l = Math.max(l | 0, 3)), o <= 0))
        return this.regularPoly(e, t, a, l, h);
      const u = a * Math.sin(Math.PI / l) - 0.001;
      o = Math.min(o, u);
      const d = (-1 * Math.PI) / 2 + h,
        f = (Math.PI * 2) / l,
        p = ((l - 2) * Math.PI) / l / 2;
      for (let g = 0; g < l; g++) {
        const _ = g * f + d,
          m = e + a * Math.cos(_),
          w = t + a * Math.sin(_),
          x = _ + Math.PI + p,
          M = _ - Math.PI - p,
          b = m + o * Math.cos(x),
          T = w + o * Math.sin(x),
          C = m + o * Math.cos(M),
          A = w + o * Math.sin(M);
        g === 0 ? this.moveTo(b, T) : this.lineTo(b, T),
          this.quadraticCurveTo(m, w, C, A, c);
      }
      return this.closePath();
    }
    roundShape(e, t, a = !1, l) {
      return e.length < 3
        ? this
        : (a ? Gy(this, e, t, l) : Fy(this, e, t), this.closePath());
    }
    filletRect(e, t, a, l, o) {
      if (o === 0) return this.rect(e, t, a, l);
      const h = Math.min(a, l) / 2,
        c = Math.min(h, Math.max(-h, o)),
        u = e + a,
        d = t + l,
        f = c < 0 ? -c : 0,
        p = Math.abs(c);
      return this.moveTo(e, t + p)
        .arcTo(e + f, t + f, e + p, t, p)
        .lineTo(u - p, t)
        .arcTo(u - f, t + f, u, t + p, p)
        .lineTo(u, d - p)
        .arcTo(u - f, d - f, e + a - p, d, p)
        .lineTo(e + p, d)
        .arcTo(e + f, d - f, e, d - p, p)
        .closePath();
    }
    chamferRect(e, t, a, l, o, h) {
      if (o <= 0) return this.rect(e, t, a, l);
      const c = Math.min(o, Math.min(a, l) / 2),
        u = e + a,
        d = t + l,
        f = [
          e + c,
          t,
          u - c,
          t,
          u,
          t + c,
          u,
          d - c,
          u - c,
          d,
          e + c,
          d,
          e,
          d - c,
          e,
          t + c,
        ];
      for (let p = f.length - 1; p >= 2; p -= 2)
        f[p] === f[p - 2] && f[p - 1] === f[p - 3] && f.splice(p - 1, 2);
      return this.poly(f, !0, h);
    }
    ellipse(e, t, a, l, o) {
      return this.drawShape(new _h(e, t, a, l), o), this;
    }
    roundRect(e, t, a, l, o, h) {
      return this.drawShape(new yh(e, t, a, l, o), h), this;
    }
    drawShape(e, t) {
      return (
        this.endPoly(),
        this.shapePrimitives.push({ shape: e, transform: t }),
        this
      );
    }
    startPoly(e, t) {
      let a = this._currentPoly;
      return (
        a && this.endPoly(),
        (a = new Vn()),
        a.points.push(e, t),
        (this._currentPoly = a),
        this
      );
    }
    endPoly(e = !1) {
      const t = this._currentPoly;
      return (
        t &&
        t.points.length > 2 &&
        ((t.closePath = e), this.shapePrimitives.push({ shape: t })),
        (this._currentPoly = null),
        this
      );
    }
    _ensurePoly(e = !0) {
      if (!this._currentPoly && ((this._currentPoly = new Vn()), e)) {
        const t = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (t) {
          let a = t.shape.x,
            l = t.shape.y;
          if (t.transform && !t.transform.isIdentity()) {
            const o = t.transform,
              h = a;
            (a = o.a * a + o.c * l + o.tx), (l = o.b * h + o.d * l + o.ty);
          }
          this._currentPoly.points.push(a, l);
        } else this._currentPoly.points.push(0, 0);
      }
    }
    buildPath() {
      const e = this._graphicsPath2D;
      (this.shapePrimitives.length = 0), (this._currentPoly = null);
      for (let t = 0; t < e.instructions.length; t++) {
        const a = e.instructions[t];
        this[a.action](...a.data);
      }
      this.finish();
    }
    get bounds() {
      const e = this._bounds;
      e.clear();
      const t = this.shapePrimitives;
      for (let a = 0; a < t.length; a++) {
        const l = t[a],
          o = l.shape.getBounds(Dy);
        l.transform ? e.addRect(o, l.transform) : e.addRect(o);
      }
      return e;
    }
  }
  class $i {
    constructor(e, t = !1) {
      (this.instructions = []),
        (this.uid = et("graphicsPath")),
        (this._dirty = !0),
        (this.checkForHoles = t),
        typeof e == "string"
          ? __(e, this)
          : (this.instructions = e?.slice() ?? []);
    }
    get shapePath() {
      return (
        this._shapePath || (this._shapePath = new Uy(this)),
        this._dirty && ((this._dirty = !1), this._shapePath.buildPath()),
        this._shapePath
      );
    }
    addPath(e, t) {
      return (
        (e = e.clone()),
        this.instructions.push({ action: "addPath", data: [e, t] }),
        (this._dirty = !0),
        this
      );
    }
    arc(...e) {
      return (
        this.instructions.push({ action: "arc", data: e }),
        (this._dirty = !0),
        this
      );
    }
    arcTo(...e) {
      return (
        this.instructions.push({ action: "arcTo", data: e }),
        (this._dirty = !0),
        this
      );
    }
    arcToSvg(...e) {
      return (
        this.instructions.push({ action: "arcToSvg", data: e }),
        (this._dirty = !0),
        this
      );
    }
    bezierCurveTo(...e) {
      return (
        this.instructions.push({ action: "bezierCurveTo", data: e }),
        (this._dirty = !0),
        this
      );
    }
    bezierCurveToShort(e, t, a, l, o) {
      const h = this.instructions[this.instructions.length - 1],
        c = this.getLastPoint(Je.shared);
      let u = 0,
        d = 0;
      if (!h || h.action !== "bezierCurveTo") (u = c.x), (d = c.y);
      else {
        (u = h.data[2]), (d = h.data[3]);
        const f = c.x,
          p = c.y;
        (u = f + (f - u)), (d = p + (p - d));
      }
      return (
        this.instructions.push({
          action: "bezierCurveTo",
          data: [u, d, e, t, a, l, o],
        }),
        (this._dirty = !0),
        this
      );
    }
    closePath() {
      return (
        this.instructions.push({ action: "closePath", data: [] }),
        (this._dirty = !0),
        this
      );
    }
    ellipse(...e) {
      return (
        this.instructions.push({ action: "ellipse", data: e }),
        (this._dirty = !0),
        this
      );
    }
    lineTo(...e) {
      return (
        this.instructions.push({ action: "lineTo", data: e }),
        (this._dirty = !0),
        this
      );
    }
    moveTo(...e) {
      return this.instructions.push({ action: "moveTo", data: e }), this;
    }
    quadraticCurveTo(...e) {
      return (
        this.instructions.push({ action: "quadraticCurveTo", data: e }),
        (this._dirty = !0),
        this
      );
    }
    quadraticCurveToShort(e, t, a) {
      const l = this.instructions[this.instructions.length - 1],
        o = this.getLastPoint(Je.shared);
      let h = 0,
        c = 0;
      if (!l || l.action !== "quadraticCurveTo") (h = o.x), (c = o.y);
      else {
        (h = l.data[0]), (c = l.data[1]);
        const u = o.x,
          d = o.y;
        (h = u + (u - h)), (c = d + (d - c));
      }
      return (
        this.instructions.push({
          action: "quadraticCurveTo",
          data: [h, c, e, t, a],
        }),
        (this._dirty = !0),
        this
      );
    }
    rect(e, t, a, l, o) {
      return (
        this.instructions.push({ action: "rect", data: [e, t, a, l, o] }),
        (this._dirty = !0),
        this
      );
    }
    circle(e, t, a, l) {
      return (
        this.instructions.push({ action: "circle", data: [e, t, a, l] }),
        (this._dirty = !0),
        this
      );
    }
    roundRect(...e) {
      return (
        this.instructions.push({ action: "roundRect", data: e }),
        (this._dirty = !0),
        this
      );
    }
    poly(...e) {
      return (
        this.instructions.push({ action: "poly", data: e }),
        (this._dirty = !0),
        this
      );
    }
    regularPoly(...e) {
      return (
        this.instructions.push({ action: "regularPoly", data: e }),
        (this._dirty = !0),
        this
      );
    }
    roundPoly(...e) {
      return (
        this.instructions.push({ action: "roundPoly", data: e }),
        (this._dirty = !0),
        this
      );
    }
    roundShape(...e) {
      return (
        this.instructions.push({ action: "roundShape", data: e }),
        (this._dirty = !0),
        this
      );
    }
    filletRect(...e) {
      return (
        this.instructions.push({ action: "filletRect", data: e }),
        (this._dirty = !0),
        this
      );
    }
    chamferRect(...e) {
      return (
        this.instructions.push({ action: "chamferRect", data: e }),
        (this._dirty = !0),
        this
      );
    }
    star(e, t, a, l, o, h, c) {
      o || (o = l / 2);
      const u = (-1 * Math.PI) / 2 + h,
        d = a * 2,
        f = (Math.PI * 2) / d,
        p = [];
      for (let g = 0; g < d; g++) {
        const _ = g % 2 ? o : l,
          m = g * f + u;
        p.push(e + _ * Math.cos(m), t + _ * Math.sin(m));
      }
      return this.poly(p, !0, c), this;
    }
    clone(e = !1) {
      const t = new $i();
      if (((t.checkForHoles = this.checkForHoles), !e))
        t.instructions = this.instructions.slice();
      else
        for (let a = 0; a < this.instructions.length; a++) {
          const l = this.instructions[a];
          t.instructions.push({ action: l.action, data: l.data.slice() });
        }
      return t;
    }
    clear() {
      return (this.instructions.length = 0), (this._dirty = !0), this;
    }
    transform(e) {
      if (e.isIdentity()) return this;
      const t = e.a,
        a = e.b,
        l = e.c,
        o = e.d,
        h = e.tx,
        c = e.ty;
      let u = 0,
        d = 0,
        f = 0,
        p = 0,
        g = 0,
        _ = 0,
        m = 0,
        w = 0;
      for (let x = 0; x < this.instructions.length; x++) {
        const M = this.instructions[x],
          b = M.data;
        switch (M.action) {
          case "moveTo":
          case "lineTo":
            (u = b[0]),
              (d = b[1]),
              (b[0] = t * u + l * d + h),
              (b[1] = a * u + o * d + c);
            break;
          case "bezierCurveTo":
            (f = b[0]),
              (p = b[1]),
              (g = b[2]),
              (_ = b[3]),
              (u = b[4]),
              (d = b[5]),
              (b[0] = t * f + l * p + h),
              (b[1] = a * f + o * p + c),
              (b[2] = t * g + l * _ + h),
              (b[3] = a * g + o * _ + c),
              (b[4] = t * u + l * d + h),
              (b[5] = a * u + o * d + c);
            break;
          case "quadraticCurveTo":
            (f = b[0]),
              (p = b[1]),
              (u = b[2]),
              (d = b[3]),
              (b[0] = t * f + l * p + h),
              (b[1] = a * f + o * p + c),
              (b[2] = t * u + l * d + h),
              (b[3] = a * u + o * d + c);
            break;
          case "arcToSvg":
            (u = b[5]),
              (d = b[6]),
              (m = b[0]),
              (w = b[1]),
              (b[0] = t * m + l * w),
              (b[1] = a * m + o * w),
              (b[5] = t * u + l * d + h),
              (b[6] = a * u + o * d + c);
            break;
          case "circle":
            b[4] = ta(b[3], e);
            break;
          case "rect":
            b[4] = ta(b[4], e);
            break;
          case "ellipse":
            b[8] = ta(b[8], e);
            break;
          case "roundRect":
            b[5] = ta(b[5], e);
            break;
          case "addPath":
            b[0].transform(e);
            break;
          case "poly":
            b[2] = ta(b[2], e);
            break;
          default:
            pe("unknown transform action", M.action);
            break;
        }
      }
      return (this._dirty = !0), this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(e) {
      let t = this.instructions.length - 1,
        a = this.instructions[t];
      if (!a) return (e.x = 0), (e.y = 0), e;
      for (; a.action === "closePath";) {
        if ((t--, t < 0)) return (e.x = 0), (e.y = 0), e;
        a = this.instructions[t];
      }
      switch (a.action) {
        case "moveTo":
        case "lineTo":
          (e.x = a.data[0]), (e.y = a.data[1]);
          break;
        case "quadraticCurveTo":
          (e.x = a.data[2]), (e.y = a.data[3]);
          break;
        case "bezierCurveTo":
          (e.x = a.data[4]), (e.y = a.data[5]);
          break;
        case "arc":
        case "arcToSvg":
          (e.x = a.data[5]), (e.y = a.data[6]);
          break;
        case "addPath":
          a.data[0].getLastPoint(e);
          break;
      }
      return e;
    }
  }
  function ta(r, e) {
    return r ? r.prepend(e) : e.clone();
  }
  function Ct(r, e, t) {
    const a = r.getAttribute(e);
    return a ? Number(a) : t;
  }
  function Oy(r, e) {
    const t = r.querySelectorAll("defs");
    for (let a = 0; a < t.length; a++) {
      const l = t[a];
      for (let o = 0; o < l.children.length; o++) {
        const h = l.children[o];
        switch (h.nodeName.toLowerCase()) {
          case "lineargradient":
            e.defs[h.id] = Ly(h);
            break;
          case "radialgradient":
            e.defs[h.id] = Ny();
            break;
        }
      }
    }
  }
  function Ly(r) {
    const e = Ct(r, "x1", 0),
      t = Ct(r, "y1", 0),
      a = Ct(r, "x2", 1),
      l = Ct(r, "y2", 0),
      o = r.getAttribute("gradientUnits") || "objectBoundingBox",
      h = new Yi(e, t, a, l, o === "objectBoundingBox" ? "local" : "global");
    for (let c = 0; c < r.children.length; c++) {
      const u = r.children[c],
        d = Ct(u, "offset", 0),
        f = mt.shared.setValue(u.getAttribute("stop-color")).toNumber();
      h.addColorStop(d, f);
    }
    return h;
  }
  function Ny(r) {
    return (
      pe("[SVG Parser] Radial gradients are not yet supported"),
      new Yi(0, 0, 1, 0)
    );
  }
  function Af(r) {
    const e = r.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return e ? e[1] : "";
  }
  const Pf = {
    fill: { type: "paint", default: 0 },
    "fill-opacity": { type: "number", default: 1 },
    stroke: { type: "paint", default: 0 },
    "stroke-width": { type: "number", default: 1 },
    "stroke-opacity": { type: "number", default: 1 },
    "stroke-linecap": { type: "string", default: "butt" },
    "stroke-linejoin": { type: "string", default: "miter" },
    "stroke-miterlimit": { type: "number", default: 10 },
    "stroke-dasharray": { type: "string", default: "none" },
    "stroke-dashoffset": { type: "number", default: 0 },
    opacity: { type: "number", default: 1 },
  };
  function Ef(r, e) {
    const t = r.getAttribute("style"),
      a = {},
      l = {},
      o = { strokeStyle: a, fillStyle: l, useFill: !1, useStroke: !1 };
    for (const h in Pf) {
      const c = r.getAttribute(h);
      c && kf(e, o, h, c.trim());
    }
    if (t) {
      const h = t.split(";");
      for (let c = 0; c < h.length; c++) {
        const u = h[c].trim(),
          [d, f] = u.split(":");
        Pf[d] && kf(e, o, d, f.trim());
      }
    }
    return {
      strokeStyle: o.useStroke ? a : null,
      fillStyle: o.useFill ? l : null,
      useFill: o.useFill,
      useStroke: o.useStroke,
    };
  }
  function kf(r, e, t, a) {
    switch (t) {
      case "stroke":
        if (a !== "none") {
          if (a.startsWith("url(")) {
            const l = Af(a);
            e.strokeStyle.fill = r.defs[l];
          } else e.strokeStyle.color = mt.shared.setValue(a).toNumber();
          e.useStroke = !0;
        }
        break;
      case "stroke-width":
        e.strokeStyle.width = Number(a);
        break;
      case "fill":
        if (a !== "none") {
          if (a.startsWith("url(")) {
            const l = Af(a);
            e.fillStyle.fill = r.defs[l];
          } else e.fillStyle.color = mt.shared.setValue(a).toNumber();
          e.useFill = !0;
        }
        break;
      case "fill-opacity":
        e.fillStyle.alpha = Number(a);
        break;
      case "stroke-opacity":
        e.strokeStyle.alpha = Number(a);
        break;
      case "opacity":
        (e.fillStyle.alpha = Number(a)), (e.strokeStyle.alpha = Number(a));
        break;
    }
  }
  function Hy(r) {
    if (r.length <= 2) return !0;
    const e = r.map((c) => c.area).sort((c, u) => u - c),
      [t, a] = e,
      l = e[e.length - 1],
      o = t / a,
      h = a / l;
    return !(o > 3 && h < 2);
  }
  function zy(r) {
    return r.split(/(?=[Mm])/).filter((a) => a.trim().length > 0);
  }
  function Wy(r) {
    const e = r.match(/[-+]?[0-9]*\.?[0-9]+/g);
    if (!e || e.length < 4) return 0;
    const t = e.map(Number),
      a = [],
      l = [];
    for (let f = 0; f < t.length; f += 2)
      f + 1 < t.length && (a.push(t[f]), l.push(t[f + 1]));
    if (a.length === 0 || l.length === 0) return 0;
    const o = Math.min(...a),
      h = Math.max(...a),
      c = Math.min(...l),
      u = Math.max(...l);
    return (h - o) * (u - c);
  }
  function Rf(r, e) {
    const t = new $i(r, !1);
    for (const a of t.instructions) e.instructions.push(a);
  }
  function Vy(r, e) {
    if (typeof r == "string") {
      const h = document.createElement("div");
      (h.innerHTML = r.trim()), (r = h.querySelector("svg"));
    }
    const t = { context: e, defs: {}, path: new $i() };
    Oy(r, t);
    const a = r.children,
      { fillStyle: l, strokeStyle: o } = Ef(r, t);
    for (let h = 0; h < a.length; h++) {
      const c = a[h];
      c.nodeName.toLowerCase() !== "defs" && If(c, t, l, o);
    }
    return e;
  }
  function If(r, e, t, a) {
    const l = r.children,
      { fillStyle: o, strokeStyle: h } = Ef(r, e);
    o && t ? (t = { ...t, ...o }) : o && (t = o),
      h && a ? (a = { ...a, ...h }) : h && (a = h);
    const c = !t && !a;
    c && (t = { color: 0 });
    let u, d, f, p, g, _, m, w, x, M, b, T, C, A, R, k, W;
    switch (r.nodeName.toLowerCase()) {
      case "path": {
        A = r.getAttribute("d");
        const D = r.getAttribute("fill-rule"),
          I = zy(A),
          y = D === "evenodd",
          Z = I.length > 1;
        if (y && Z) {
          const z = I.map((B) => ({ path: B, area: Wy(B) }));
          if ((z.sort((B, re) => re.area - B.area), I.length > 3 || !Hy(z)))
            for (let B = 0; B < z.length; B++) {
              const re = z[B],
                qe = B === 0;
              e.context.beginPath();
              const S = new $i(void 0, !0);
              Rf(re.path, S),
                e.context.path(S),
                qe
                  ? (t && e.context.fill(t), a && e.context.stroke(a))
                  : e.context.cut();
            }
          else
            for (let B = 0; B < z.length; B++) {
              const re = z[B],
                qe = B % 2 === 1;
              e.context.beginPath();
              const S = new $i(void 0, !0);
              Rf(re.path, S),
                e.context.path(S),
                qe
                  ? e.context.cut()
                  : (t && e.context.fill(t), a && e.context.stroke(a));
            }
        } else {
          const z = D ? D === "evenodd" : !0;
          (R = new $i(A, z)),
            e.context.path(R),
            t && e.context.fill(t),
            a && e.context.stroke(a);
        }
        break;
      }
      case "circle":
        (m = Ct(r, "cx", 0)),
          (w = Ct(r, "cy", 0)),
          (x = Ct(r, "r", 0)),
          e.context.ellipse(m, w, x, x),
          t && e.context.fill(t),
          a && e.context.stroke(a);
        break;
      case "rect":
        (u = Ct(r, "x", 0)),
          (d = Ct(r, "y", 0)),
          (k = Ct(r, "width", 0)),
          (W = Ct(r, "height", 0)),
          (M = Ct(r, "rx", 0)),
          (b = Ct(r, "ry", 0)),
          M || b
            ? e.context.roundRect(u, d, k, W, M || b)
            : e.context.rect(u, d, k, W),
          t && e.context.fill(t),
          a && e.context.stroke(a);
        break;
      case "ellipse":
        (m = Ct(r, "cx", 0)),
          (w = Ct(r, "cy", 0)),
          (M = Ct(r, "rx", 0)),
          (b = Ct(r, "ry", 0)),
          e.context.beginPath(),
          e.context.ellipse(m, w, M, b),
          t && e.context.fill(t),
          a && e.context.stroke(a);
        break;
      case "line":
        (f = Ct(r, "x1", 0)),
          (p = Ct(r, "y1", 0)),
          (g = Ct(r, "x2", 0)),
          (_ = Ct(r, "y2", 0)),
          e.context.beginPath(),
          e.context.moveTo(f, p),
          e.context.lineTo(g, _),
          a && e.context.stroke(a);
        break;
      case "polygon":
        (C = r.getAttribute("points")),
          (T = C.match(/\d+/g).map((D) => parseInt(D, 10))),
          e.context.poly(T, !0),
          t && e.context.fill(t),
          a && e.context.stroke(a);
        break;
      case "polyline":
        (C = r.getAttribute("points")),
          (T = C.match(/\d+/g).map((D) => parseInt(D, 10))),
          e.context.poly(T, !1),
          a && e.context.stroke(a);
        break;
      case "g":
      case "svg":
        break;
      default: {
        pe(`[SVG parser] <${r.nodeName}> elements unsupported`);
        break;
      }
    }
    c && (t = null);
    for (let D = 0; D < l.length; D++) If(l[D], e, t, a);
  }
  function jy(r) {
    return mt.isColorLike(r);
  }
  function Bf(r) {
    return r instanceof uo;
  }
  function Ff(r) {
    return r instanceof Yi;
  }
  function Xy(r) {
    return r instanceof te;
  }
  function qy(r, e, t) {
    const a = mt.shared.setValue(e ?? 0);
    return (
      (r.color = a.toNumber()),
      (r.alpha = a.alpha === 1 ? t.alpha : a.alpha),
      (r.texture = te.WHITE),
      { ...t, ...r }
    );
  }
  function Yy(r, e, t) {
    return (r.texture = e), { ...t, ...r };
  }
  function Gf(r, e, t) {
    return (
      (r.fill = e),
      (r.color = 16777215),
      (r.texture = e.texture),
      (r.matrix = e.transform),
      { ...t, ...r }
    );
  }
  function Df(r, e, t) {
    return (
      e.buildGradient(),
      (r.fill = e),
      (r.color = 16777215),
      (r.texture = e.texture),
      (r.matrix = e.transform),
      (r.textureSpace = e.textureSpace),
      { ...t, ...r }
    );
  }
  function $y(r, e) {
    const t = { ...e, ...r },
      a = mt.shared.setValue(t.color);
    return (t.alpha *= a.alpha), (t.color = a.toNumber()), t;
  }
  function Gr(r, e) {
    if (r == null) return null;
    const t = {},
      a = r;
    return jy(r)
      ? qy(t, r, e)
      : Xy(r)
        ? Yy(t, r, e)
        : Bf(r)
          ? Gf(t, r, e)
          : Ff(r)
            ? Df(t, r, e)
            : a.fill && Bf(a.fill)
              ? Gf(a, a.fill, e)
              : a.fill && Ff(a.fill)
                ? Df(a, a.fill, e)
                : $y(a, e);
  }
  function _o(r, e) {
    const {
      width: t,
      alignment: a,
      miterLimit: l,
      cap: o,
      join: h,
      pixelLine: c,
      ...u
    } = e,
      d = Gr(r, u);
    return d
      ? {
        width: t,
        alignment: a,
        miterLimit: l,
        cap: o,
        join: h,
        pixelLine: c,
        ...d,
      }
      : null;
  }
  const Ky = new Je(),
    Uf = new ae(),
    Oh = class zi extends Os {
      constructor() {
        super(...arguments),
          (this.uid = et("graphicsContext")),
          (this.dirty = !0),
          (this.batchMode = "auto"),
          (this.instructions = []),
          (this._activePath = new $i()),
          (this._transform = new ae()),
          (this._fillStyle = { ...zi.defaultFillStyle }),
          (this._strokeStyle = { ...zi.defaultStrokeStyle }),
          (this._stateStack = []),
          (this._tick = 0),
          (this._bounds = new cs()),
          (this._boundsDirty = !0);
      }
      clone() {
        const e = new zi();
        return (
          (e.batchMode = this.batchMode),
          (e.instructions = this.instructions.slice()),
          (e._activePath = this._activePath.clone()),
          (e._transform = this._transform.clone()),
          (e._fillStyle = { ...this._fillStyle }),
          (e._strokeStyle = { ...this._strokeStyle }),
          (e._stateStack = this._stateStack.slice()),
          (e._bounds = this._bounds.clone()),
          (e._boundsDirty = !0),
          e
        );
      }
      get fillStyle() {
        return this._fillStyle;
      }
      set fillStyle(e) {
        this._fillStyle = Gr(e, zi.defaultFillStyle);
      }
      get strokeStyle() {
        return this._strokeStyle;
      }
      set strokeStyle(e) {
        this._strokeStyle = _o(e, zi.defaultStrokeStyle);
      }
      setFillStyle(e) {
        return (this._fillStyle = Gr(e, zi.defaultFillStyle)), this;
      }
      setStrokeStyle(e) {
        return (this._strokeStyle = Gr(e, zi.defaultStrokeStyle)), this;
      }
      texture(e, t, a, l, o, h) {
        return (
          this.instructions.push({
            action: "texture",
            data: {
              image: e,
              dx: a || 0,
              dy: l || 0,
              dw: o || e.frame.width,
              dh: h || e.frame.height,
              transform: this._transform.clone(),
              alpha: this._fillStyle.alpha,
              style: t ? mt.shared.setValue(t).toNumber() : 16777215,
            },
          }),
          this.onUpdate(),
          this
        );
      }
      beginPath() {
        return (this._activePath = new $i()), this;
      }
      fill(e, t) {
        let a;
        const l = this.instructions[this.instructions.length - 1];
        return (
          this._tick === 0 && l && l.action === "stroke"
            ? (a = l.data.path)
            : (a = this._activePath.clone()),
          a
            ? (e != null &&
              (t !== void 0 &&
                typeof e == "number" &&
                (me(
                  Ie,
                  "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"
                ),
                  (e = { color: e, alpha: t })),
                (this._fillStyle = Gr(e, zi.defaultFillStyle))),
              this.instructions.push({
                action: "fill",
                data: { style: this.fillStyle, path: a },
              }),
              this.onUpdate(),
              this._initNextPathLocation(),
              (this._tick = 0),
              this)
            : this
        );
      }
      _initNextPathLocation() {
        const { x: e, y: t } = this._activePath.getLastPoint(Je.shared);
        this._activePath.clear(), this._activePath.moveTo(e, t);
      }
      stroke(e) {
        let t;
        const a = this.instructions[this.instructions.length - 1];
        return (
          this._tick === 0 && a && a.action === "fill"
            ? (t = a.data.path)
            : (t = this._activePath.clone()),
          t
            ? (e != null && (this._strokeStyle = _o(e, zi.defaultStrokeStyle)),
              this.instructions.push({
                action: "stroke",
                data: { style: this.strokeStyle, path: t },
              }),
              this.onUpdate(),
              this._initNextPathLocation(),
              (this._tick = 0),
              this)
            : this
        );
      }
      cut() {
        for (let e = 0; e < 2; e++) {
          const t = this.instructions[this.instructions.length - 1 - e],
            a = this._activePath.clone();
          if (t && (t.action === "stroke" || t.action === "fill"))
            if (t.data.hole) t.data.hole.addPath(a);
            else {
              t.data.hole = a;
              break;
            }
        }
        return this._initNextPathLocation(), this;
      }
      arc(e, t, a, l, o, h) {
        this._tick++;
        const c = this._transform;
        return (
          this._activePath.arc(
            c.a * e + c.c * t + c.tx,
            c.b * e + c.d * t + c.ty,
            a,
            l,
            o,
            h
          ),
          this
        );
      }
      arcTo(e, t, a, l, o) {
        this._tick++;
        const h = this._transform;
        return (
          this._activePath.arcTo(
            h.a * e + h.c * t + h.tx,
            h.b * e + h.d * t + h.ty,
            h.a * a + h.c * l + h.tx,
            h.b * a + h.d * l + h.ty,
            o
          ),
          this
        );
      }
      arcToSvg(e, t, a, l, o, h, c) {
        this._tick++;
        const u = this._transform;
        return (
          this._activePath.arcToSvg(
            e,
            t,
            a,
            l,
            o,
            u.a * h + u.c * c + u.tx,
            u.b * h + u.d * c + u.ty
          ),
          this
        );
      }
      bezierCurveTo(e, t, a, l, o, h, c) {
        this._tick++;
        const u = this._transform;
        return (
          this._activePath.bezierCurveTo(
            u.a * e + u.c * t + u.tx,
            u.b * e + u.d * t + u.ty,
            u.a * a + u.c * l + u.tx,
            u.b * a + u.d * l + u.ty,
            u.a * o + u.c * h + u.tx,
            u.b * o + u.d * h + u.ty,
            c
          ),
          this
        );
      }
      closePath() {
        return this._tick++, this._activePath?.closePath(), this;
      }
      ellipse(e, t, a, l) {
        return (
          this._tick++,
          this._activePath.ellipse(e, t, a, l, this._transform.clone()),
          this
        );
      }
      circle(e, t, a) {
        return (
          this._tick++,
          this._activePath.circle(e, t, a, this._transform.clone()),
          this
        );
      }
      path(e) {
        return (
          this._tick++,
          this._activePath.addPath(e, this._transform.clone()),
          this
        );
      }
      lineTo(e, t) {
        this._tick++;
        const a = this._transform;
        return (
          this._activePath.lineTo(
            a.a * e + a.c * t + a.tx,
            a.b * e + a.d * t + a.ty
          ),
          this
        );
      }
      moveTo(e, t) {
        this._tick++;
        const a = this._transform,
          l = this._activePath.instructions,
          o = a.a * e + a.c * t + a.tx,
          h = a.b * e + a.d * t + a.ty;
        return l.length === 1 && l[0].action === "moveTo"
          ? ((l[0].data[0] = o), (l[0].data[1] = h), this)
          : (this._activePath.moveTo(o, h), this);
      }
      quadraticCurveTo(e, t, a, l, o) {
        this._tick++;
        const h = this._transform;
        return (
          this._activePath.quadraticCurveTo(
            h.a * e + h.c * t + h.tx,
            h.b * e + h.d * t + h.ty,
            h.a * a + h.c * l + h.tx,
            h.b * a + h.d * l + h.ty,
            o
          ),
          this
        );
      }
      rect(e, t, a, l) {
        return (
          this._tick++,
          this._activePath.rect(e, t, a, l, this._transform.clone()),
          this
        );
      }
      roundRect(e, t, a, l, o) {
        return (
          this._tick++,
          this._activePath.roundRect(e, t, a, l, o, this._transform.clone()),
          this
        );
      }
      poly(e, t) {
        return (
          this._tick++,
          this._activePath.poly(e, t, this._transform.clone()),
          this
        );
      }
      regularPoly(e, t, a, l, o = 0, h) {
        return (
          this._tick++, this._activePath.regularPoly(e, t, a, l, o, h), this
        );
      }
      roundPoly(e, t, a, l, o, h) {
        return this._tick++, this._activePath.roundPoly(e, t, a, l, o, h), this;
      }
      roundShape(e, t, a, l) {
        return this._tick++, this._activePath.roundShape(e, t, a, l), this;
      }
      filletRect(e, t, a, l, o) {
        return this._tick++, this._activePath.filletRect(e, t, a, l, o), this;
      }
      chamferRect(e, t, a, l, o, h) {
        return (
          this._tick++, this._activePath.chamferRect(e, t, a, l, o, h), this
        );
      }
      star(e, t, a, l, o = 0, h = 0) {
        return (
          this._tick++,
          this._activePath.star(e, t, a, l, o, h, this._transform.clone()),
          this
        );
      }
      svg(e) {
        return this._tick++, Vy(e, this), this;
      }
      restore() {
        const e = this._stateStack.pop();
        return (
          e &&
          ((this._transform = e.transform),
            (this._fillStyle = e.fillStyle),
            (this._strokeStyle = e.strokeStyle)),
          this
        );
      }
      save() {
        return (
          this._stateStack.push({
            transform: this._transform.clone(),
            fillStyle: { ...this._fillStyle },
            strokeStyle: { ...this._strokeStyle },
          }),
          this
        );
      }
      getTransform() {
        return this._transform;
      }
      resetTransform() {
        return this._transform.identity(), this;
      }
      rotate(e) {
        return this._transform.rotate(e), this;
      }
      scale(e, t = e) {
        return this._transform.scale(e, t), this;
      }
      setTransform(e, t, a, l, o, h) {
        return e instanceof ae
          ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this)
          : (this._transform.set(e, t, a, l, o, h), this);
      }
      transform(e, t, a, l, o, h) {
        return e instanceof ae
          ? (this._transform.append(e), this)
          : (Uf.set(e, t, a, l, o, h), this._transform.append(Uf), this);
      }
      translate(e, t = e) {
        return this._transform.translate(e, t), this;
      }
      clear() {
        return (
          this._activePath.clear(),
          (this.instructions.length = 0),
          this.resetTransform(),
          this.onUpdate(),
          this
        );
      }
      onUpdate() {
        (this._boundsDirty = !0),
          !this.dirty && (this.emit("update", this, 16), (this.dirty = !0));
      }
      get bounds() {
        if (!this._boundsDirty) return this._bounds;
        this._boundsDirty = !1;
        const e = this._bounds;
        e.clear();
        for (let t = 0; t < this.instructions.length; t++) {
          const a = this.instructions[t],
            l = a.action;
          if (l === "fill") {
            const o = a.data;
            e.addBounds(o.path.bounds);
          } else if (l === "texture") {
            const o = a.data;
            e.addFrame(o.dx, o.dy, o.dx + o.dw, o.dy + o.dh, o.transform);
          }
          if (l === "stroke") {
            const o = a.data,
              h = o.style.alignment,
              c = o.style.width * (1 - h),
              u = o.path.bounds;
            e.addFrame(u.minX - c, u.minY - c, u.maxX + c, u.maxY + c);
          }
        }
        return e;
      }
      containsPoint(e) {
        if (!this.bounds.containsPoint(e.x, e.y)) return !1;
        const t = this.instructions;
        let a = !1;
        for (let l = 0; l < t.length; l++) {
          const o = t[l],
            h = o.data,
            c = h.path;
          if (!o.action || !c) continue;
          const u = h.style,
            d = c.shapePath.shapePrimitives;
          for (let f = 0; f < d.length; f++) {
            const p = d[f].shape;
            if (!u || !p) continue;
            const g = d[f].transform,
              _ = g ? g.applyInverse(e, Ky) : e;
            if (o.action === "fill") a = p.contains(_.x, _.y);
            else {
              const w = u;
              a = p.strokeContains(_.x, _.y, w.width, w.alignment);
            }
            const m = h.hole;
            if (m) {
              const w = m.shapePath?.shapePrimitives;
              if (w)
                for (let x = 0; x < w.length; x++)
                  w[x].shape.contains(_.x, _.y) && (a = !1);
            }
            if (a) return !0;
          }
        }
        return a;
      }
      destroy(e = !1) {
        if (
          ((this._stateStack.length = 0),
            (this._transform = null),
            this.emit("destroy", this),
            this.removeAllListeners(),
            typeof e == "boolean" ? e : e?.texture)
        ) {
          const a = typeof e == "boolean" ? e : e?.textureSource;
          this._fillStyle.texture &&
            (this._fillStyle.fill && "uid" in this._fillStyle.fill
              ? this._fillStyle.fill.destroy()
              : this._fillStyle.texture.destroy(a)),
            this._strokeStyle.texture &&
            (this._strokeStyle.fill && "uid" in this._strokeStyle.fill
              ? this._strokeStyle.fill.destroy()
              : this._strokeStyle.texture.destroy(a));
        }
        (this._fillStyle = null),
          (this._strokeStyle = null),
          (this.instructions = null),
          (this._activePath = null),
          (this._bounds = null),
          (this._stateStack = null),
          (this.customShader = null),
          (this._transform = null);
      }
    };
  (Oh.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: te.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
  }),
    (Oh.defaultStrokeStyle = {
      width: 1,
      color: 16777215,
      alpha: 1,
      alignment: 0.5,
      miterLimit: 10,
      cap: "butt",
      join: "miter",
      texture: te.WHITE,
      matrix: null,
      fill: null,
      textureSpace: "local",
      pixelLine: !1,
    });
  let ti = Oh;
  const Lh = class Pn extends Os {
    constructor(e = {}) {
      super(), (this.uid = et("textStyle")), (this._tick = 0), Zy(e);
      const t = { ...Pn.defaultTextStyle, ...e };
      for (const a in t) {
        const l = a;
        this[l] = t[a];
      }
      this.update(), (this._tick = 0);
    }
    get align() {
      return this._align;
    }
    set align(e) {
      (this._align = e), this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(e) {
      (this._breakWords = e), this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(e) {
      e !== null && typeof e == "object"
        ? (this._dropShadow = this._createProxy({
          ...Pn.defaultDropShadow,
          ...e,
        }))
        : (this._dropShadow = e
          ? this._createProxy({ ...Pn.defaultDropShadow })
          : null),
        this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(e) {
      (this._fontFamily = e), this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(e) {
      typeof e == "string"
        ? (this._fontSize = parseInt(e, 10))
        : (this._fontSize = e),
        this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(e) {
      (this._fontStyle = e.toLowerCase()), this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(e) {
      (this._fontVariant = e), this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(e) {
      (this._fontWeight = e), this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(e) {
      (this._leading = e), this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(e) {
      (this._letterSpacing = e), this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(e) {
      (this._lineHeight = e), this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(e) {
      (this._padding = e), this.update();
    }
    get filters() {
      return this._filters;
    }
    set filters(e) {
      (this._filters = Object.freeze(e)), this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(e) {
      (this._trim = e), this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(e) {
      (this._textBaseline = e), this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(e) {
      (this._whiteSpace = e), this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(e) {
      (this._wordWrap = e), this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(e) {
      (this._wordWrapWidth = e), this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(e) {
      e !== this._originalFill &&
        ((this._originalFill = e),
          this._isFillStyle(e) &&
          (this._originalFill = this._createProxy(
            { ...ti.defaultFillStyle, ...e },
            () => {
              this._fill = Gr({ ...this._originalFill }, ti.defaultFillStyle);
            }
          )),
          (this._fill = Gr(e === 0 ? "black" : e, ti.defaultFillStyle)),
          this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(e) {
      e !== this._originalStroke &&
        ((this._originalStroke = e),
          this._isFillStyle(e) &&
          (this._originalStroke = this._createProxy(
            { ...ti.defaultStrokeStyle, ...e },
            () => {
              this._stroke = _o(
                { ...this._originalStroke },
                ti.defaultStrokeStyle
              );
            }
          )),
          (this._stroke = _o(e, ti.defaultStrokeStyle)),
          this.update());
    }
    update() {
      this._tick++, this.emit("update", this);
    }
    reset() {
      const e = Pn.defaultTextStyle;
      for (const t in e) this[t] = e[t];
    }
    get styleKey() {
      return `${this.uid}-${this._tick}`;
    }
    clone() {
      return new Pn({
        align: this.align,
        breakWords: this.breakWords,
        dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
        fill: this._fill,
        fontFamily: this.fontFamily,
        fontSize: this.fontSize,
        fontStyle: this.fontStyle,
        fontVariant: this.fontVariant,
        fontWeight: this.fontWeight,
        leading: this.leading,
        letterSpacing: this.letterSpacing,
        lineHeight: this.lineHeight,
        padding: this.padding,
        stroke: this._stroke,
        textBaseline: this.textBaseline,
        whiteSpace: this.whiteSpace,
        wordWrap: this.wordWrap,
        wordWrapWidth: this.wordWrapWidth,
        filters: this._filters ? [...this._filters] : void 0,
      });
    }
    _getFinalPadding() {
      let e = 0;
      if (this._filters)
        for (let t = 0; t < this._filters.length; t++)
          e += this._filters[t].padding;
      return Math.max(this._padding, e);
    }
    destroy(e = !1) {
      if ((this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture)) {
        const a = typeof e == "boolean" ? e : e?.textureSource;
        this._fill?.texture && this._fill.texture.destroy(a),
          this._originalFill?.texture && this._originalFill.texture.destroy(a),
          this._stroke?.texture && this._stroke.texture.destroy(a),
          this._originalStroke?.texture &&
          this._originalStroke.texture.destroy(a);
      }
      (this._fill = null),
        (this._stroke = null),
        (this.dropShadow = null),
        (this._originalStroke = null),
        (this._originalFill = null);
    }
    _createProxy(e, t) {
      return new Proxy(e, {
        set: (a, l, o) => ((a[l] = o), t?.(l, o), this.update(), !0),
      });
    }
    _isFillStyle(e) {
      return (
        (e ?? null) !== null &&
        !(mt.isColorLike(e) || e instanceof Yi || e instanceof uo)
      );
    }
  };
  (Lh.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5,
  }),
    (Lh.defaultTextStyle = {
      align: "left",
      breakWords: !1,
      dropShadow: null,
      fill: "black",
      fontFamily: "Arial",
      fontSize: 26,
      fontStyle: "normal",
      fontVariant: "normal",
      fontWeight: "normal",
      leading: 0,
      letterSpacing: 0,
      lineHeight: 0,
      padding: 0,
      stroke: null,
      textBaseline: "alphabetic",
      trim: !1,
      whiteSpace: "pre",
      wordWrap: !1,
      wordWrapWidth: 100,
    });
  let Dr = Lh;
  function Zy(r) {
    const e = r;
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
      const t = Dr.defaultDropShadow;
      r.dropShadow = {
        alpha: e.dropShadowAlpha ?? t.alpha,
        angle: e.dropShadowAngle ?? t.angle,
        blur: e.dropShadowBlur ?? t.blur,
        color: e.dropShadowColor ?? t.color,
        distance: e.dropShadowDistance ?? t.distance,
      };
    }
    if (e.strokeThickness !== void 0) {
      me(Ie, "strokeThickness is now a part of stroke");
      const t = e.stroke;
      let a = {};
      if (mt.isColorLike(t)) a.color = t;
      else if (t instanceof Yi || t instanceof uo) a.fill = t;
      else if (
        Object.hasOwnProperty.call(t, "color") ||
        Object.hasOwnProperty.call(t, "fill")
      )
        a = t;
      else throw new Error("Invalid stroke value.");
      r.stroke = { ...a, width: e.strokeThickness };
    }
    if (Array.isArray(e.fillGradientStops)) {
      if (
        (me(Ie, "gradient fill is now a fill pattern: `new FillGradient(...)`"),
          !Array.isArray(e.fill) || e.fill.length === 0)
      )
        throw new Error(
          "Invalid fill value. Expected an array of colors for gradient fill."
        );
      e.fill.length !== e.fillGradientStops.length &&
        pe(
          "The number of fill colors must match the number of fill gradient stops."
        );
      const t = new Yi({
        start: { x: 0, y: 0 },
        end: { x: 0, y: 1 },
        textureSpace: "local",
      }),
        a = e.fillGradientStops.slice(),
        l = e.fill.map((o) => mt.shared.setValue(o).toNumber());
      a.forEach((o, h) => {
        t.addColorStop(o, l[h]);
      }),
        (r.fill = { fill: t });
    }
  }
  class Qy {
    constructor(e) {
      (this._canvasPool = Object.create(null)),
        (this.canvasOptions = e || {}),
        (this.enableFullScreen = !1);
    }
    _createCanvasAndContext(e, t) {
      const a = xe.get().createCanvas();
      (a.width = e), (a.height = t);
      const l = a.getContext("2d");
      return { canvas: a, context: l };
    }
    getOptimalCanvasAndContext(e, t, a = 1) {
      (e = Math.ceil(e * a - 1e-6)),
        (t = Math.ceil(t * a - 1e-6)),
        (e = $r(e)),
        (t = $r(t));
      const l = (e << 17) + (t << 1);
      this._canvasPool[l] || (this._canvasPool[l] = []);
      let o = this._canvasPool[l].pop();
      return o || (o = this._createCanvasAndContext(e, t)), o;
    }
    returnCanvasAndContext(e) {
      const t = e.canvas,
        { width: a, height: l } = t,
        o = (a << 17) + (l << 1);
      e.context.resetTransform(),
        e.context.clearRect(0, 0, a, l),
        this._canvasPool[o].push(e);
    }
    clear() {
      this._canvasPool = {};
    }
  }
  const Ki = new Qy();
  Zr.register(Ki);
  const Of = 1e5;
  function yo(r, e, t, a = 0) {
    if (r.texture === te.WHITE && !r.fill)
      return mt.shared
        .setValue(r.color)
        .setAlpha(r.alpha ?? 1)
        .toHexa();
    if (r.fill) {
      if (r.fill instanceof uo) {
        const l = r.fill,
          o = e.createPattern(l.texture.source.resource, "repeat"),
          h = l.transform.copyTo(ae.shared);
        return (
          h.scale(l.texture.frame.width, l.texture.frame.height),
          o.setTransform(h),
          o
        );
      } else if (r.fill instanceof Yi) {
        const l = r.fill,
          o = l.type === "linear",
          h = l.textureSpace === "local";
        let c = 1,
          u = 1;
        h && t && ((c = t.width + a), (u = t.height + a));
        let d,
          f = !1;
        if (o) {
          const { start: p, end: g } = l;
          (d = e.createLinearGradient(p.x * c, p.y * u, g.x * c, g.y * u)),
            (f = Math.abs(g.x - p.x) < Math.abs((g.y - p.y) * 0.1));
        } else {
          const {
            center: p,
            innerRadius: g,
            outerCenter: _,
            outerRadius: m,
          } = l;
          d = e.createRadialGradient(
            p.x * c,
            p.y * u,
            g * c,
            _.x * c,
            _.y * u,
            m * c
          );
        }
        if (f && h && t) {
          const p = t.lineHeight / u;
          for (let g = 0; g < t.lines.length; g++) {
            const _ = (g * t.lineHeight + a / 2) / u;
            l.colorStops.forEach((m) => {
              const w = _ + m.offset * p;
              d.addColorStop(
                Math.floor(w * Of) / Of,
                mt.shared.setValue(m.color).toHex()
              );
            });
          }
        } else
          l.colorStops.forEach((p) => {
            d.addColorStop(p.offset, mt.shared.setValue(p.color).toHex());
          });
        return d;
      }
    } else {
      const l = e.createPattern(r.texture.source.resource, "repeat"),
        o = r.matrix.copyTo(ae.shared);
      return (
        o.scale(r.texture.frame.width, r.texture.frame.height),
        l.setTransform(o),
        l
      );
    }
    return pe("FillStyle not recognised", r), "red";
  }
  const Lf = class i1 extends Yu {
    constructor(e) {
      super(),
        (this.resolution = 1),
        (this.pages = []),
        (this._padding = 0),
        (this._measureCache = Object.create(null)),
        (this._currentChars = []),
        (this._currentX = 0),
        (this._currentY = 0),
        (this._currentMaxCharHeight = 0),
        (this._currentPageIndex = -1),
        (this._skipKerning = !1);
      const t = { ...i1.defaultOptions, ...e };
      (this._textureSize = t.textureSize), (this._mipmap = t.mipmap);
      const a = t.style.clone();
      t.overrideFill &&
        ((a._fill.color = 16777215),
          (a._fill.alpha = 1),
          (a._fill.texture = te.WHITE),
          (a._fill.fill = null)),
        (this.applyFillAsTint = t.overrideFill);
      const l = a.fontSize;
      a.fontSize = this.baseMeasurementFontSize;
      const o = co(a);
      t.overrideSize
        ? a._stroke && (a._stroke.width *= this.baseRenderedFontSize / l)
        : (a.fontSize = this.baseRenderedFontSize = l),
        (this._style = a),
        (this._skipKerning = t.skipKerning ?? !1),
        (this.resolution = t.resolution ?? 1),
        (this._padding = t.padding ?? 4),
        t.textureStyle &&
        (this._textureStyle =
          t.textureStyle instanceof Pi
            ? t.textureStyle
            : new Pi(t.textureStyle)),
        (this.fontMetrics = _i.measureFont(o)),
        (this.lineHeight =
          a.lineHeight || this.fontMetrics.fontSize || a.fontSize);
    }
    ensureCharacters(e) {
      const t = _i
        .graphemeSegmenter(e)
        .filter((x) => !this._currentChars.includes(x))
        .filter((x, M, b) => b.indexOf(x) === M);
      if (!t.length) return;
      this._currentChars = [...this._currentChars, ...t];
      let a;
      this._currentPageIndex === -1
        ? (a = this._nextPage())
        : (a = this.pages[this._currentPageIndex]);
      let { canvas: l, context: o } = a.canvasAndContext,
        h = a.texture.source;
      const c = this._style;
      let u = this._currentX,
        d = this._currentY,
        f = this._currentMaxCharHeight;
      const p = this.baseRenderedFontSize / this.baseMeasurementFontSize,
        g = this._padding * p;
      let _ = !1;
      const m = l.width / this.resolution,
        w = l.height / this.resolution;
      for (let x = 0; x < t.length; x++) {
        const M = t[x],
          b = _i.measureText(M, c, l, !1);
        b.lineHeight = b.height;
        const T = b.width * p,
          C = Math.ceil((c.fontStyle === "italic" ? 2 : 1) * T),
          A = b.height * p,
          R = C + g * 2,
          k = A + g * 2;
        if (
          ((_ = !1),
            M !==
            `
` &&
            M !== "\r" &&
            M !== "	" &&
            M !== " " &&
            ((_ = !0), (f = Math.ceil(Math.max(k, f)))),
            u + R > m && ((d += f), (f = k), (u = 0), d + f > w))
        ) {
          h.update();
          const D = this._nextPage();
          (l = D.canvasAndContext.canvas),
            (o = D.canvasAndContext.context),
            (h = D.texture.source),
            (u = 0),
            (d = 0),
            (f = 0);
        }
        const W =
          T / p - (c.dropShadow?.distance ?? 0) - (c._stroke?.width ?? 0);
        if (
          ((this.chars[M] = {
            id: M.codePointAt(0),
            xOffset: -this._padding,
            yOffset: -this._padding,
            xAdvance: W,
            kerning: {},
          }),
            _)
        ) {
          this._drawGlyph(o, b, u + g, d + g, p, c);
          const D = h.width * p,
            I = h.height * p,
            y = new Le(
              (u / D) * h.width,
              (d / I) * h.height,
              (R / D) * h.width,
              (k / I) * h.height
            );
          (this.chars[M].texture = new te({ source: h, frame: y })),
            (u += Math.ceil(R));
        }
      }
      h.update(),
        (this._currentX = u),
        (this._currentY = d),
        (this._currentMaxCharHeight = f),
        this._skipKerning && this._applyKerning(t, o);
    }
    get pageTextures() {
      return (
        me(
          Ie,
          "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."
        ),
        this.pages
      );
    }
    _applyKerning(e, t) {
      const a = this._measureCache;
      for (let l = 0; l < e.length; l++) {
        const o = e[l];
        for (let h = 0; h < this._currentChars.length; h++) {
          const c = this._currentChars[h];
          let u = a[o];
          u || (u = a[o] = t.measureText(o).width);
          let d = a[c];
          d || (d = a[c] = t.measureText(c).width);
          let f = t.measureText(o + c).width,
            p = f - (u + d);
          p && (this.chars[o].kerning[c] = p),
            (f = t.measureText(o + c).width),
            (p = f - (u + d)),
            p && (this.chars[c].kerning[o] = p);
        }
      }
    }
    _nextPage() {
      this._currentPageIndex++;
      const e = this.resolution,
        t = Ki.getOptimalCanvasAndContext(
          this._textureSize,
          this._textureSize,
          e
        );
      this._setupContext(t.context, this._style, e);
      const a = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize),
        l = new te({
          source: new Rr({
            resource: t.canvas,
            resolution: a,
            alphaMode: "premultiply-alpha-on-upload",
            autoGenerateMipmaps: this._mipmap,
          }),
        });
      this._textureStyle && (l.source.style = this._textureStyle);
      const o = { canvasAndContext: t, texture: l };
      return (this.pages[this._currentPageIndex] = o), o;
    }
    _setupContext(e, t, a) {
      (t.fontSize = this.baseRenderedFontSize),
        e.scale(a, a),
        (e.font = co(t)),
        (t.fontSize = this.baseMeasurementFontSize),
        (e.textBaseline = t.textBaseline);
      const l = t._stroke,
        o = l?.width ?? 0;
      if (
        (l &&
          ((e.lineWidth = o),
            (e.lineJoin = l.join),
            (e.miterLimit = l.miterLimit),
            (e.strokeStyle = yo(l, e))),
          t._fill && (e.fillStyle = yo(t._fill, e)),
          t.dropShadow)
      ) {
        const h = t.dropShadow,
          c = mt.shared.setValue(h.color).toArray(),
          u = h.blur * a,
          d = h.distance * a;
        (e.shadowColor = `rgba(${c[0] * 255},${c[1] * 255},${c[2] * 255},${h.alpha
          })`),
          (e.shadowBlur = u),
          (e.shadowOffsetX = Math.cos(h.angle) * d),
          (e.shadowOffsetY = Math.sin(h.angle) * d);
      } else
        (e.shadowColor = "black"),
          (e.shadowBlur = 0),
          (e.shadowOffsetX = 0),
          (e.shadowOffsetY = 0);
    }
    _drawGlyph(e, t, a, l, o, h) {
      const c = t.text,
        u = t.fontProperties,
        f = (h._stroke?.width ?? 0) * o,
        p = a + f / 2,
        g = l - f / 2,
        _ = u.descent * o,
        m = t.lineHeight * o;
      let w = !1;
      h.stroke && f && ((w = !0), e.strokeText(c, p, g + m - _));
      const { shadowBlur: x, shadowOffsetX: M, shadowOffsetY: b } = e;
      h._fill &&
        (w &&
          ((e.shadowBlur = 0), (e.shadowOffsetX = 0), (e.shadowOffsetY = 0)),
          e.fillText(c, p, g + m - _)),
        w && ((e.shadowBlur = x), (e.shadowOffsetX = M), (e.shadowOffsetY = b));
    }
    destroy() {
      super.destroy();
      for (let e = 0; e < this.pages.length; e++) {
        const { canvasAndContext: t, texture: a } = this.pages[e];
        Ki.returnCanvasAndContext(t), a.destroy(!0);
      }
      this.pages = null;
    }
  };
  Lf.defaultOptions = { textureSize: 512, style: new Dr(), mipmap: !0 };
  let Nf = Lf;
  function Hf(r, e, t, a) {
    const l = {
      width: 0,
      height: 0,
      offsetY: 0,
      scale: e.fontSize / t.baseMeasurementFontSize,
      lines: [
        {
          width: 0,
          charPositions: [],
          spaceWidth: 0,
          spacesIndex: [],
          chars: [],
        },
      ],
    };
    l.offsetY = t.baseLineOffset;
    let o = l.lines[0],
      h = null,
      c = !0;
    const u = { width: 0, start: 0, index: 0, positions: [], chars: [] },
      d = t.baseMeasurementFontSize / e.fontSize,
      f = e.letterSpacing * d,
      p = e.wordWrapWidth * d,
      g = e.lineHeight ? e.lineHeight * d : t.lineHeight,
      _ = e.wordWrap && e.breakWords,
      m = (M) => {
        const b = o.width;
        for (let T = 0; T < u.index; T++) {
          const C = M.positions[T];
          o.chars.push(M.chars[T]), o.charPositions.push(C + b);
        }
        (o.width += M.width),
          (c = !1),
          (u.width = 0),
          (u.index = 0),
          (u.chars.length = 0);
      },
      w = () => {
        let M = o.chars.length - 1;
        if (a) {
          let b = o.chars[M];
          for (; b === " ";)
            (o.width -= t.chars[b].xAdvance), (b = o.chars[--M]);
        }
        (l.width = Math.max(l.width, o.width)),
          (o = {
            width: 0,
            charPositions: [],
            chars: [],
            spaceWidth: 0,
            spacesIndex: [],
          }),
          (c = !0),
          l.lines.push(o),
          (l.height += g);
      },
      x = (M) => M - f > p;
    for (let M = 0; M < r.length + 1; M++) {
      let b;
      const T = M === r.length;
      T || (b = r[M]);
      const C = t.chars[b] || t.chars[" "];
      if (
        /(?:\s)/.test(b) ||
        b === "\r" ||
        b ===
        `
` ||
        T
      ) {
        if (
          (!c && e.wordWrap && x(o.width + u.width)
            ? (w(), m(u), T || o.charPositions.push(0))
            : ((u.start = o.width), m(u), T || o.charPositions.push(0)),
            b === "\r" ||
            b ===
            `
`)
        )
          w();
        else if (!T) {
          const W = C.xAdvance + (C.kerning[h] || 0) + f;
          (o.width += W),
            (o.spaceWidth = W),
            o.spacesIndex.push(o.charPositions.length),
            o.chars.push(b);
        }
      } else {
        const k = C.kerning[h] || 0,
          W = C.xAdvance + k + f;
        _ && x(o.width + u.width + W) && (m(u), w()),
          (u.positions[u.index++] = u.width + k),
          u.chars.push(b),
          (u.width += W);
      }
      h = b;
    }
    return (
      w(),
      e.align === "center"
        ? Jy(l)
        : e.align === "right"
          ? ex(l)
          : e.align === "justify" && tx(l),
      l
    );
  }
  function Jy(r) {
    for (let e = 0; e < r.lines.length; e++) {
      const t = r.lines[e],
        a = r.width / 2 - t.width / 2;
      for (let l = 0; l < t.charPositions.length; l++) t.charPositions[l] += a;
    }
  }
  function ex(r) {
    for (let e = 0; e < r.lines.length; e++) {
      const t = r.lines[e],
        a = r.width - t.width;
      for (let l = 0; l < t.charPositions.length; l++) t.charPositions[l] += a;
    }
  }
  function tx(r) {
    const e = r.width;
    for (let t = 0; t < r.lines.length; t++) {
      const a = r.lines[t];
      let l = 0,
        o = a.spacesIndex[l++],
        h = 0;
      const c = a.spacesIndex.length,
        d = (e - a.width) / c;
      for (let f = 0; f < a.charPositions.length; f++)
        f === o && ((o = a.spacesIndex[l++]), (h += d)),
          (a.charPositions[f] += h);
    }
  }
  function sx(r) {
    if (r === "") return [];
    typeof r == "string" && (r = [r]);
    const e = [];
    for (let t = 0, a = r.length; t < a; t++) {
      const l = r[t];
      if (Array.isArray(l)) {
        if (l.length !== 2)
          throw new Error(
            `[BitmapFont]: Invalid character range length, expecting 2 got ${l.length}.`
          );
        if (l[0].length === 0 || l[1].length === 0)
          throw new Error("[BitmapFont]: Invalid character delimiter.");
        const o = l[0].charCodeAt(0),
          h = l[1].charCodeAt(0);
        if (h < o) throw new Error("[BitmapFont]: Invalid character range.");
        for (let c = o, u = h; c <= u; c++) e.push(String.fromCharCode(c));
      } else e.push(...Array.from(l));
    }
    if (e.length === 0)
      throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return e;
  }
  let xo = 0;
  class ix {
    constructor() {
      (this.ALPHA = [["a", "z"], ["A", "Z"], " "]),
        (this.NUMERIC = [["0", "9"]]),
        (this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "]),
        (this.ASCII = [[" ", "~"]]),
        (this.defaultOptions = {
          chars: this.ALPHANUMERIC,
          resolution: 1,
          padding: 4,
          skipKerning: !1,
          textureStyle: null,
        }),
        (this.measureCache = $u(1e3));
    }
    getFont(e, t) {
      let a = `${t.fontFamily}-bitmap`,
        l = !0;
      if (
        (t._fill.fill && !t._stroke
          ? ((a += t._fill.fill.styleKey), (l = !1))
          : (t._stroke || t.dropShadow) &&
          ((a = `${t.styleKey}-bitmap`), (l = !1)),
          !We.has(a))
      ) {
        const h = Object.create(t);
        h.lineHeight = 0;
        const c = new Nf({
          style: h,
          overrideFill: l,
          overrideSize: !0,
          ...this.defaultOptions,
        });
        xo++,
          xo > 50 &&
          pe(
            "BitmapText",
            `You have dynamically created ${xo} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``
          ),
          c.once("destroy", () => {
            xo--, We.remove(a);
          }),
          We.set(a, c);
      }
      const o = We.get(a);
      return o.ensureCharacters?.(e), o;
    }
    getLayout(e, t, a = !0) {
      const l = this.getFont(e, t),
        o = `${e}-${t.styleKey}-${a}`;
      if (this.measureCache.has(o)) return this.measureCache.get(o);
      const h = _i.graphemeSegmenter(e),
        c = Hf(h, t, l, a);
      return this.measureCache.set(o, c), c;
    }
    measureText(e, t, a = !0) {
      return this.getLayout(e, t, a);
    }
    install(...e) {
      let t = e[0];
      typeof t == "string" &&
        ((t = {
          name: t,
          style: e[1],
          chars: e[2]?.chars,
          resolution: e[2]?.resolution,
          padding: e[2]?.padding,
          skipKerning: e[2]?.skipKerning,
        }),
          me(
            Ie,
            "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"
          ));
      const a = t?.name;
      if (!a)
        throw new Error("[BitmapFontManager] Property `name` is required.");
      t = { ...this.defaultOptions, ...t };
      const l = t.style,
        o = l instanceof Dr ? l : new Dr(l),
        h = t.dynamicFill ?? this._canUseTintForStyle(o),
        c = new Nf({
          style: o,
          overrideFill: h,
          skipKerning: t.skipKerning,
          padding: t.padding,
          resolution: t.resolution,
          overrideSize: !1,
          textureStyle: t.textureStyle,
        }),
        u = sx(t.chars);
      return (
        c.ensureCharacters(u.join("")),
        We.set(`${a}-bitmap`, c),
        c.once("destroy", () => We.remove(`${a}-bitmap`)),
        c
      );
    }
    uninstall(e) {
      const t = `${e}-bitmap`,
        a = We.get(t);
      a && a.destroy();
    }
    _canUseTintForStyle(e) {
      return (
        !e._stroke &&
        (!e.dropShadow || e.dropShadow.color === 0) &&
        !e._fill.fill &&
        e._fill.color === 16777215
      );
    }
  }
  const Nh = new ix();
  class zf extends Yu {
    constructor(e, t) {
      super();
      const { textures: a, data: l } = e;
      Object.keys(l.pages).forEach((o) => {
        const h = l.pages[parseInt(o, 10)],
          c = a[h.id];
        this.pages.push({ texture: c });
      }),
        Object.keys(l.chars).forEach((o) => {
          const h = l.chars[o],
            { frame: c, source: u, rotate: d } = a[h.page],
            f = $e.transformRectCoords(h, c, d, new Le()),
            p = new te({
              frame: f,
              orig: new Le(0, 0, h.width, h.height),
              source: u,
              rotate: d,
            });
          this.chars[o] = {
            id: o.codePointAt(0),
            xOffset: h.xOffset,
            yOffset: h.yOffset,
            xAdvance: h.xAdvance,
            kerning: h.kerning ?? {},
            texture: p,
          };
        }),
        (this.baseRenderedFontSize = l.fontSize),
        (this.baseMeasurementFontSize = l.fontSize),
        (this.fontMetrics = { ascent: 0, descent: 0, fontSize: l.fontSize }),
        (this.baseLineOffset = l.baseLineOffset),
        (this.lineHeight = l.lineHeight),
        (this.fontFamily = l.fontFamily),
        (this.distanceField = l.distanceField ?? { type: "none", range: 0 }),
        (this.url = t);
    }
    destroy() {
      super.destroy();
      for (let e = 0; e < this.pages.length; e++) {
        const { texture: t } = this.pages[e];
        t.destroy(!0);
      }
      this.pages = null;
    }
    static install(e) {
      Nh.install(e);
    }
    static uninstall(e) {
      Nh.uninstall(e);
    }
  }
  const Hh = {
    test(r) {
      return typeof r == "string" && r.startsWith("info face=");
    },
    parse(r) {
      const e = r.match(/^[a-z]+\s+.+$/gm),
        t = {
          info: [],
          common: [],
          page: [],
          char: [],
          chars: [],
          kerning: [],
          kernings: [],
          distanceField: [],
        };
      for (const p in e) {
        const g = e[p].match(/^[a-z]+/gm)[0],
          _ = e[p].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
          m = {};
        for (const w in _) {
          const x = _[w].split("="),
            M = x[0],
            b = x[1].replace(/"/gm, ""),
            T = parseFloat(b),
            C = isNaN(T) ? b : T;
          m[M] = C;
        }
        t[g].push(m);
      }
      const a = {
        chars: {},
        pages: [],
        lineHeight: 0,
        fontSize: 0,
        fontFamily: "",
        distanceField: null,
        baseLineOffset: 0,
      },
        [l] = t.info,
        [o] = t.common,
        [h] = t.distanceField ?? [];
      h &&
        (a.distanceField = {
          range: parseInt(h.distanceRange, 10),
          type: h.fieldType,
        }),
        (a.fontSize = parseInt(l.size, 10)),
        (a.fontFamily = l.face),
        (a.lineHeight = parseInt(o.lineHeight, 10));
      const c = t.page;
      for (let p = 0; p < c.length; p++)
        a.pages.push({ id: parseInt(c[p].id, 10) || 0, file: c[p].file });
      const u = {};
      a.baseLineOffset = a.lineHeight - parseInt(o.base, 10);
      const d = t.char;
      for (let p = 0; p < d.length; p++) {
        const g = d[p],
          _ = parseInt(g.id, 10);
        let m = g.letter ?? g.char ?? String.fromCharCode(_);
        m === "space" && (m = " "),
          (u[_] = m),
          (a.chars[m] = {
            id: _,
            page: parseInt(g.page, 10) || 0,
            x: parseInt(g.x, 10),
            y: parseInt(g.y, 10),
            width: parseInt(g.width, 10),
            height: parseInt(g.height, 10),
            xOffset: parseInt(g.xoffset, 10),
            yOffset: parseInt(g.yoffset, 10),
            xAdvance: parseInt(g.xadvance, 10),
            kerning: {},
          });
      }
      const f = t.kerning || [];
      for (let p = 0; p < f.length; p++) {
        const g = parseInt(f[p].first, 10),
          _ = parseInt(f[p].second, 10),
          m = parseInt(f[p].amount, 10);
        a.chars[u[_]].kerning[u[g]] = m;
      }
      return a;
    },
  },
    Wf = {
      test(r) {
        const e = r;
        return (
          typeof e != "string" &&
          "getElementsByTagName" in e &&
          e.getElementsByTagName("page").length &&
          e.getElementsByTagName("info")[0].getAttribute("face") !== null
        );
      },
      parse(r) {
        const e = {
          chars: {},
          pages: [],
          lineHeight: 0,
          fontSize: 0,
          fontFamily: "",
          distanceField: null,
          baseLineOffset: 0,
        },
          t = r.getElementsByTagName("info")[0],
          a = r.getElementsByTagName("common")[0],
          l = r.getElementsByTagName("distanceField")[0];
        l &&
          (e.distanceField = {
            type: l.getAttribute("fieldType"),
            range: parseInt(l.getAttribute("distanceRange"), 10),
          });
        const o = r.getElementsByTagName("page"),
          h = r.getElementsByTagName("char"),
          c = r.getElementsByTagName("kerning");
        (e.fontSize = parseInt(t.getAttribute("size"), 10)),
          (e.fontFamily = t.getAttribute("face")),
          (e.lineHeight = parseInt(a.getAttribute("lineHeight"), 10));
        for (let d = 0; d < o.length; d++)
          e.pages.push({
            id: parseInt(o[d].getAttribute("id"), 10) || 0,
            file: o[d].getAttribute("file"),
          });
        const u = {};
        e.baseLineOffset = e.lineHeight - parseInt(a.getAttribute("base"), 10);
        for (let d = 0; d < h.length; d++) {
          const f = h[d],
            p = parseInt(f.getAttribute("id"), 10);
          let g =
            f.getAttribute("letter") ??
            f.getAttribute("char") ??
            String.fromCharCode(p);
          g === "space" && (g = " "),
            (u[p] = g),
            (e.chars[g] = {
              id: p,
              page: parseInt(f.getAttribute("page"), 10) || 0,
              x: parseInt(f.getAttribute("x"), 10),
              y: parseInt(f.getAttribute("y"), 10),
              width: parseInt(f.getAttribute("width"), 10),
              height: parseInt(f.getAttribute("height"), 10),
              xOffset: parseInt(f.getAttribute("xoffset"), 10),
              yOffset: parseInt(f.getAttribute("yoffset"), 10),
              xAdvance: parseInt(f.getAttribute("xadvance"), 10),
              kerning: {},
            });
        }
        for (let d = 0; d < c.length; d++) {
          const f = parseInt(c[d].getAttribute("first"), 10),
            p = parseInt(c[d].getAttribute("second"), 10),
            g = parseInt(c[d].getAttribute("amount"), 10);
          e.chars[u[p]].kerning[u[f]] = g;
        }
        return e;
      },
    },
    Vf = {
      test(r) {
        return typeof r == "string" && r.includes("<font>")
          ? Wf.test(xe.get().parseXML(r))
          : !1;
      },
      parse(r) {
        return Wf.parse(xe.get().parseXML(r));
      },
    },
    rx = [".xml", ".fnt"],
    nx = {
      extension: { type: P.CacheParser, name: "cacheBitmapFont" },
      test: (r) => r instanceof zf,
      getCacheableAssets(r, e) {
        const t = {};
        return (
          r.forEach((a) => {
            (t[a] = e), (t[`${a}-bitmap`] = e);
          }),
          (t[`${e.fontFamily}-bitmap`] = e),
          t
        );
      },
    },
    ox = {
      extension: { type: P.LoadParser, priority: or.Normal },
      name: "loadBitmapFont",
      id: "bitmap-font",
      test(r) {
        return rx.includes(Ls.extname(r).toLowerCase());
      },
      async testParse(r) {
        return Hh.test(r) || Vf.test(r);
      },
      async parse(r, e, t) {
        const a = Hh.test(r) ? Hh.parse(r) : Vf.parse(r),
          { src: l } = e,
          { pages: o } = a,
          h = [],
          c = a.distanceField
            ? {
              scaleMode: "linear",
              alphaMode: "premultiply-alpha-on-upload",
              autoGenerateMipmaps: !1,
              resolution: 1,
            }
            : {};
        for (let p = 0; p < o.length; ++p) {
          const g = o[p].file;
          let _ = Ls.join(Ls.dirname(l), g);
          (_ = Yl(_, l)), h.push({ src: _, data: c });
        }
        const u = await t.load(h),
          d = h.map((p) => u[p.src]);
        return new zf({ data: a, textures: d }, l);
      },
      async load(r, e) {
        return await (await xe.get().fetch(r)).text();
      },
      async unload(r, e, t) {
        await Promise.all(
          r.pages.map((a) => t.unload(a.texture.source._sourceOrigin))
        ),
          r.destroy();
      },
    };
  class lx {
    constructor(e, t = !1) {
      (this._loader = e),
        (this._assetList = []),
        (this._isLoading = !1),
        (this._maxConcurrent = 1),
        (this.verbose = t);
    }
    add(e) {
      e.forEach((t) => {
        this._assetList.push(t);
      }),
        this._isActive && !this._isLoading && this._next();
    }
    async _next() {
      if (this._assetList.length && this._isActive) {
        this._isLoading = !0;
        const e = [],
          t = Math.min(this._assetList.length, this._maxConcurrent);
        for (let a = 0; a < t; a++) e.push(this._assetList.pop());
        await this._loader.load(e), (this._isLoading = !1), this._next();
      }
    }
    get active() {
      return this._isActive;
    }
    set active(e) {
      this._isActive !== e &&
        ((this._isActive = e), e && !this._isLoading && this._next());
    }
  }
  const hx = {
    extension: { type: P.CacheParser, name: "cacheTextureArray" },
    test: (r) => Array.isArray(r) && r.every((e) => e instanceof te),
    getCacheableAssets: (r, e) => {
      const t = {};
      return (
        r.forEach((a) => {
          e.forEach((l, o) => {
            t[a + (o === 0 ? "" : o + 1)] = l;
          });
        }),
        t
      );
    },
  };
  async function jf(r) {
    if ("Image" in globalThis)
      return new Promise((e) => {
        const t = new Image();
        (t.onload = () => {
          e(!0);
        }),
          (t.onerror = () => {
            e(!1);
          }),
          (t.src = r);
      });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
      try {
        const e = await (await fetch(r)).blob();
        await createImageBitmap(e);
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  }
  const cx = {
    extension: { type: P.DetectionParser, priority: 1 },
    test: async () =>
      jf(
        "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
      ),
    add: async (r) => [...r, "avif"],
    remove: async (r) => r.filter((e) => e !== "avif"),
  },
    Xf = ["png", "jpg", "jpeg"],
    dx = {
      extension: { type: P.DetectionParser, priority: -1 },
      test: () => Promise.resolve(!0),
      add: async (r) => [...r, ...Xf],
      remove: async (r) => r.filter((e) => !Xf.includes(e)),
    },
    ux =
      "WorkerGlobalScope" in globalThis &&
      globalThis instanceof globalThis.WorkerGlobalScope;
  function vo(r) {
    return ux ? !1 : document.createElement("video").canPlayType(r) !== "";
  }
  const fx = {
    extension: { type: P.DetectionParser, priority: 0 },
    test: async () => vo("video/mp4"),
    add: async (r) => [...r, "mp4", "m4v"],
    remove: async (r) => r.filter((e) => e !== "mp4" && e !== "m4v"),
  },
    px = {
      extension: { type: P.DetectionParser, priority: 0 },
      test: async () => vo("video/ogg"),
      add: async (r) => [...r, "ogv"],
      remove: async (r) => r.filter((e) => e !== "ogv"),
    },
    gx = {
      extension: { type: P.DetectionParser, priority: 0 },
      test: async () => vo("video/webm"),
      add: async (r) => [...r, "webm"],
      remove: async (r) => r.filter((e) => e !== "webm"),
    },
    mx = {
      extension: { type: P.DetectionParser, priority: 0 },
      test: async () =>
        jf(
          "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
        ),
      add: async (r) => [...r, "webp"],
      remove: async (r) => r.filter((e) => e !== "webp"),
    };
  class _x {
    constructor() {
      (this._parsers = []),
        (this._parsersValidated = !1),
        (this.parsers = new Proxy(this._parsers, {
          set: (e, t, a) => ((this._parsersValidated = !1), (e[t] = a), !0),
        })),
        (this.promiseCache = {});
    }
    reset() {
      (this._parsersValidated = !1), (this.promiseCache = {});
    }
    _getLoadPromiseAndParser(e, t) {
      const a = { promise: null, parser: null };
      return (
        (a.promise = (async () => {
          let l = null,
            o = null;
          if (
            ((t.parser || t.loadParser) &&
              ((o = this._parserHash[t.parser || t.loadParser]),
                t.loadParser &&
                pe(
                  `[Assets] "loadParser" is deprecated, use "parser" instead for ${e}`
                ),
                o ||
                pe(
                  `[Assets] specified load parser "${t.parser || t.loadParser
                  }" not found while loading ${e}`
                )),
              !o)
          ) {
            for (let h = 0; h < this.parsers.length; h++) {
              const c = this.parsers[h];
              if (c.load && c.test?.(e, t, this)) {
                o = c;
                break;
              }
            }
            if (!o)
              return (
                pe(
                  `[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`
                ),
                null
              );
          }
          (l = await o.load(e, t, this)), (a.parser = o);
          for (let h = 0; h < this.parsers.length; h++) {
            const c = this.parsers[h];
            c.parse &&
              c.parse &&
              (await c.testParse?.(l, t, this)) &&
              ((l = (await c.parse(l, t, this)) || l), (a.parser = c));
          }
          return l;
        })()),
        a
      );
    }
    async load(e, t) {
      this._parsersValidated || this._validateParsers();
      let a = 0;
      const l = {},
        o = eo(e),
        h = ui(e, (d) => ({ alias: [d], src: d, data: {} })),
        c = h.length,
        u = h.map(async (d) => {
          const f = Ls.toAbsolute(d.src);
          if (!l[d.src])
            try {
              this.promiseCache[f] ||
                (this.promiseCache[f] = this._getLoadPromiseAndParser(f, d)),
                (l[d.src] = await this.promiseCache[f].promise),
                t && t(++a / c);
            } catch (p) {
              throw (
                (delete this.promiseCache[f],
                  delete l[d.src],
                  new Error(`[Loader.load] Failed to load ${f}.
${p}`))
              );
            }
        });
      return await Promise.all(u), o ? l[h[0].src] : l;
    }
    async unload(e) {
      const a = ui(e, (l) => ({ alias: [l], src: l })).map(async (l) => {
        const o = Ls.toAbsolute(l.src),
          h = this.promiseCache[o];
        if (h) {
          const c = await h.promise;
          delete this.promiseCache[o], await h.parser?.unload?.(c, l, this);
        }
      });
      await Promise.all(a);
    }
    _validateParsers() {
      (this._parsersValidated = !0),
        (this._parserHash = this._parsers
          .filter((e) => e.name || e.id)
          .reduce(
            (e, t) => (
              !t.name && !t.id
                ? pe("[Assets] parser should have an id")
                : (e[t.name] || e[t.id]) &&
                pe(`[Assets] parser id conflict "${t.id}"`),
              (e[t.name] = t),
              t.id && (e[t.id] = t),
              e
            ),
            {}
          ));
    }
  }
  function an(r, e) {
    if (Array.isArray(e)) {
      for (const t of e) if (r.startsWith(`data:${t}`)) return !0;
      return !1;
    }
    return r.startsWith(`data:${e}`);
  }
  function on(r, e) {
    const t = r.split("?")[0],
      a = Ls.extname(t).toLowerCase();
    return Array.isArray(e) ? e.includes(a) : a === e;
  }
  const yx = ".json",
    vx = "application/json",
    bx = {
      extension: { type: P.LoadParser, priority: or.Low },
      name: "loadJson",
      id: "json",
      test(r) {
        return an(r, vx) || on(r, yx);
      },
      async load(r) {
        return await (await xe.get().fetch(r)).json();
      },
    },
    wx = ".txt",
    Sx = "text/plain",
    Mx = {
      name: "loadTxt",
      id: "text",
      extension: { type: P.LoadParser, priority: or.Low, name: "loadTxt" },
      test(r) {
        return an(r, Sx) || on(r, wx);
      },
      async load(r) {
        return await (await xe.get().fetch(r)).text();
      },
    },
    Tx = [
      "normal",
      "bold",
      "100",
      "200",
      "300",
      "400",
      "500",
      "600",
      "700",
      "800",
      "900",
    ],
    Cx = [".ttf", ".otf", ".woff", ".woff2"],
    Ax = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
    Px = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
  function Ex(r) {
    const e = Ls.extname(r),
      l = Ls.basename(r, e)
        .replace(/(-|_)/g, " ")
        .toLowerCase()
        .split(" ")
        .map((c) => c.charAt(0).toUpperCase() + c.slice(1));
    let o = l.length > 0;
    for (const c of l)
      if (!c.match(Px)) {
        o = !1;
        break;
      }
    let h = l.join(" ");
    return o || (h = `"${h.replace(/[\\"]/g, "\\$&")}"`), h;
  }
  const kx = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  function Rx(r) {
    return kx.test(r) ? r : encodeURI(r);
  }
  const Ix = {
    extension: { type: P.LoadParser, priority: or.Low },
    name: "loadWebFont",
    id: "web-font",
    test(r) {
      return an(r, Ax) || on(r, Cx);
    },
    async load(r, e) {
      const t = xe.get().getFontFaceSet();
      if (t) {
        const a = [],
          l = e.data?.family ?? Ex(r),
          o = e.data?.weights?.filter((c) => Tx.includes(c)) ?? ["normal"],
          h = e.data ?? {};
        for (let c = 0; c < o.length; c++) {
          const u = o[c],
            d = new FontFace(l, `url(${Rx(r)})`, { ...h, weight: u });
          await d.load(), t.add(d), a.push(d);
        }
        return (
          We.has(`${l}-and-url`)
            ? We.get(`${l}-and-url`).entries.push({ url: r, faces: a })
            : We.set(`${l}-and-url`, { entries: [{ url: r, faces: a }] }),
          a.length === 1 ? a[0] : a
        );
      }
      return (
        pe(
          "[loadWebFont] FontFace API is not supported. Skipping loading font"
        ),
        null
      );
    },
    unload(r) {
      const e = Array.isArray(r) ? r : [r],
        t = e[0].family,
        a = We.get(`${t}-and-url`),
        l = a.entries.find((o) => o.faces.some((h) => e.indexOf(h) !== -1));
      (l.faces = l.faces.filter((o) => e.indexOf(o) === -1)),
        l.faces.length === 0 && (a.entries = a.entries.filter((o) => o !== l)),
        e.forEach((o) => {
          xe.get().getFontFaceSet().delete(o);
        }),
        a.entries.length === 0 && We.remove(`${t}-and-url`);
    },
  };
  function zh(r, e = 1) {
    const t = Jr.RETINA_PREFIX?.exec(r);
    return t ? parseFloat(t[1]) : e;
  }
  function Wh(r, e, t) {
    (r.label = t), (r._sourceOrigin = t);
    const a = new te({ source: r, label: t }),
      l = () => {
        delete e.promiseCache[t], We.has(t) && We.remove(t);
      };
    return (
      a.source.once("destroy", () => {
        e.promiseCache[t] &&
          (pe(
            "[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."
          ),
            l());
      }),
      a.once("destroy", () => {
        r.destroyed ||
          (pe(
            "[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."
          ),
            l());
      }),
      a
    );
  }
  const Bx = ".svg",
    Fx = "image/svg+xml",
    Gx = {
      extension: { type: P.LoadParser, priority: or.Low, name: "loadSVG" },
      name: "loadSVG",
      id: "svg",
      config: { crossOrigin: "anonymous", parseAsGraphicsContext: !1 },
      test(r) {
        return an(r, Fx) || on(r, Bx);
      },
      async load(r, e, t) {
        return e.data?.parseAsGraphicsContext ??
          this.config.parseAsGraphicsContext
          ? Ux(r)
          : Dx(r, e, t, this.config.crossOrigin);
      },
      unload(r) {
        r.destroy(!0);
      },
    };
  async function Dx(r, e, t, a) {
    const l = await xe.get().fetch(r),
      o = xe.get().createImage();
    (o.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(
      await l.text()
    )}`),
      (o.crossOrigin = a),
      await o.decode();
    const h = e.data?.width ?? o.width,
      c = e.data?.height ?? o.height,
      u = e.data?.resolution || zh(r),
      d = Math.ceil(h * u),
      f = Math.ceil(c * u),
      p = xe.get().createCanvas(d, f),
      g = p.getContext("2d");
    (g.imageSmoothingEnabled = !0),
      (g.imageSmoothingQuality = "high"),
      g.drawImage(o, 0, 0, h * u, c * u);
    const { parseAsGraphicsContext: _, ...m } = e.data ?? {},
      w = new Rr({
        resource: p,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: u,
        ...m,
      });
    return Wh(w, t, r);
  }
  async function Ux(r) {
    const t = await (await xe.get().fetch(r)).text(),
      a = new ti();
    return a.svg(t), a;
  }
  const Ox = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
  let ln = null,
    Vh = class {
      constructor() {
        ln ||
          (ln = URL.createObjectURL(
            new Blob([Ox], { type: "application/javascript" })
          )),
          (this.worker = new Worker(ln));
      }
    };
  Vh.revokeObjectURL = function () {
    ln && (URL.revokeObjectURL(ln), (ln = null));
  };
  const Lx = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
  let hn = null;
  class qf {
    constructor() {
      hn ||
        (hn = URL.createObjectURL(
          new Blob([Lx], { type: "application/javascript" })
        )),
        (this.worker = new Worker(hn));
    }
  }
  qf.revokeObjectURL = function () {
    hn && (URL.revokeObjectURL(hn), (hn = null));
  };
  let Yf = 0,
    jh;
  class Nx {
    constructor() {
      (this._initialized = !1),
        (this._createdWorkers = 0),
        (this._workerPool = []),
        (this._queue = []),
        (this._resolveHash = {});
    }
    isImageBitmapSupported() {
      return this._isImageBitmapSupported !== void 0
        ? this._isImageBitmapSupported
        : ((this._isImageBitmapSupported = new Promise((e) => {
          const { worker: t } = new Vh();
          t.addEventListener("message", (a) => {
            t.terminate(), Vh.revokeObjectURL(), e(a.data);
          });
        })),
          this._isImageBitmapSupported);
    }
    loadImageBitmap(e, t) {
      return this._run("loadImageBitmap", [e, t?.data?.alphaMode]);
    }
    async _initWorkers() {
      this._initialized || (this._initialized = !0);
    }
    _getWorker() {
      jh === void 0 && (jh = navigator.hardwareConcurrency || 4);
      let e = this._workerPool.pop();
      return (
        !e &&
        this._createdWorkers < jh &&
        (this._createdWorkers++,
          (e = new qf().worker),
          e.addEventListener("message", (t) => {
            this._complete(t.data), this._returnWorker(t.target), this._next();
          })),
        e
      );
    }
    _returnWorker(e) {
      this._workerPool.push(e);
    }
    _complete(e) {
      e.error !== void 0
        ? this._resolveHash[e.uuid].reject(e.error)
        : this._resolveHash[e.uuid].resolve(e.data),
        (this._resolveHash[e.uuid] = null);
    }
    async _run(e, t) {
      await this._initWorkers();
      const a = new Promise((l, o) => {
        this._queue.push({ id: e, arguments: t, resolve: l, reject: o });
      });
      return this._next(), a;
    }
    _next() {
      if (!this._queue.length) return;
      const e = this._getWorker();
      if (!e) return;
      const t = this._queue.pop(),
        a = t.id;
      (this._resolveHash[Yf] = { resolve: t.resolve, reject: t.reject }),
        e.postMessage({ data: t.arguments, uuid: Yf++, id: a });
    }
    reset() {
      this._workerPool.forEach((e) => e.terminate()),
        (this._workerPool.length = 0),
        Object.values(this._resolveHash).forEach(({ reject: e }) => {
          e?.(new Error("WorkerManager destroyed"));
        }),
        (this._resolveHash = {}),
        (this._queue.length = 0),
        (this._initialized = !1),
        (this._createdWorkers = 0);
    }
  }
  const $f = new Nx(),
    Hx = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
    zx = ["image/jpeg", "image/png", "image/webp", "image/avif"];
  async function Wx(r, e) {
    const t = await xe.get().fetch(r);
    if (!t.ok)
      throw new Error(
        `[loadImageBitmap] Failed to fetch ${r}: ${t.status} ${t.statusText}`
      );
    const a = await t.blob();
    return e?.data?.alphaMode === "premultiplied-alpha"
      ? createImageBitmap(a, { premultiplyAlpha: "none" })
      : createImageBitmap(a);
  }
  const Kf = {
    name: "loadTextures",
    id: "texture",
    extension: {
      type: P.LoadParser,
      priority: or.High,
      name: "loadTextures",
    },
    config: {
      preferWorkers: !0,
      preferCreateImageBitmap: !0,
      crossOrigin: "anonymous",
    },
    test(r) {
      return an(r, zx) || on(r, Hx);
    },
    async load(r, e, t) {
      let a = null;
      globalThis.createImageBitmap && this.config.preferCreateImageBitmap
        ? this.config.preferWorkers && (await $f.isImageBitmapSupported())
          ? (a = await $f.loadImageBitmap(r, e))
          : (a = await Wx(r, e))
        : (a = await new Promise((o, h) => {
          (a = xe.get().createImage()),
            (a.crossOrigin = this.config.crossOrigin),
            (a.src = r),
            a.complete
              ? o(a)
              : ((a.onload = () => {
                o(a);
              }),
                (a.onerror = h));
        }));
      const l = new Rr({
        resource: a,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: e.data?.resolution || zh(r),
        ...e.data,
      });
      return Wh(l, t, r);
    },
    unload(r) {
      r.destroy(!0);
    },
  },
    Vx = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
  let Xh, qh;
  function jx(r, e, t) {
    t === void 0 && !e.startsWith("data:")
      ? (r.crossOrigin = qx(e))
      : t !== !1 && (r.crossOrigin = typeof t == "string" ? t : "anonymous");
  }
  function Xx(r) {
    return new Promise((e, t) => {
      r.addEventListener("canplaythrough", a),
        r.addEventListener("error", l),
        r.load();
      function a() {
        o(), e();
      }
      function l(h) {
        o(), t(h);
      }
      function o() {
        r.removeEventListener("canplaythrough", a),
          r.removeEventListener("error", l);
      }
    });
  }
  function qx(r, e = globalThis.location) {
    if (r.startsWith("data:")) return "";
    e || (e = globalThis.location);
    const t = new URL(r, document.baseURI);
    return t.hostname !== e.hostname ||
      t.port !== e.port ||
      t.protocol !== e.protocol
      ? "anonymous"
      : "";
  }
  function Yx() {
    const r = [],
      e = [];
    for (const t of Vx) {
      const a = In.MIME_TYPES[t.substring(1)] || `video/${t.substring(1)}`;
      vo(a) && (r.push(t), e.includes(a) || e.push(a));
    }
    return { validVideoExtensions: r, validVideoMime: e };
  }
  const $x = {
    name: "loadVideo",
    id: "video",
    extension: { type: P.LoadParser, name: "loadVideo" },
    test(r) {
      if (!Xh || !qh) {
        const { validVideoExtensions: a, validVideoMime: l } = Yx();
        (Xh = a), (qh = l);
      }
      const e = an(r, qh),
        t = on(r, Xh);
      return e || t;
    },
    async load(r, e, t) {
      const a = {
        ...In.defaultOptions,
        resolution: e.data?.resolution || zh(r),
        alphaMode: e.data?.alphaMode || (await iu()),
        ...e.data,
      },
        l = document.createElement("video"),
        o = {
          preload: a.autoLoad !== !1 ? "auto" : void 0,
          "webkit-playsinline": a.playsinline !== !1 ? "" : void 0,
          playsinline: a.playsinline !== !1 ? "" : void 0,
          muted: a.muted === !0 ? "" : void 0,
          loop: a.loop === !0 ? "" : void 0,
          autoplay: a.autoPlay !== !1 ? "" : void 0,
        };
      Object.keys(o).forEach((u) => {
        const d = o[u];
        d !== void 0 && l.setAttribute(u, d);
      }),
        a.muted === !0 && (l.muted = !0),
        jx(l, r, a.crossorigin);
      const h = document.createElement("source");
      let c;
      if (a.mime) c = a.mime;
      else if (r.startsWith("data:")) c = r.slice(5, r.indexOf(";"));
      else if (!r.startsWith("blob:")) {
        const u = r
          .split("?")[0]
          .slice(r.lastIndexOf(".") + 1)
          .toLowerCase();
        c = In.MIME_TYPES[u] || `video/${u}`;
      }
      return (
        (h.src = r),
        c && (h.type = c),
        new Promise((u) => {
          const d = async () => {
            const f = new In({ ...a, resource: l });
            l.removeEventListener("canplay", d),
              e.data.preload && (await Xx(l)),
              u(Wh(f, t, r));
          };
          a.preload && !a.autoPlay && l.load(),
            l.addEventListener("canplay", d),
            l.appendChild(h);
        })
      );
    },
    unload(r) {
      r.destroy(!0);
    },
  },
    Zf = {
      extension: { type: P.ResolveParser, name: "resolveTexture" },
      test: Kf.test,
      parse: (r) => ({
        resolution: parseFloat(Jr.RETINA_PREFIX.exec(r)?.[1] ?? "1"),
        format: r.split(".").pop(),
        src: r,
      }),
    },
    Kx = {
      extension: { type: P.ResolveParser, priority: -2, name: "resolveJson" },
      test: (r) => Jr.RETINA_PREFIX.test(r) && r.endsWith(".json"),
      parse: Zf.parse,
    };
  class Zx {
    constructor() {
      (this._detections = []),
        (this._initialized = !1),
        (this.resolver = new Jr()),
        (this.loader = new _x()),
        (this.cache = We),
        (this._backgroundLoader = new lx(this.loader)),
        (this._backgroundLoader.active = !0),
        this.reset();
    }
    async init(e = {}) {
      if (this._initialized) {
        pe(
          "[Assets]AssetManager already initialized, did you load before calling this Assets.init()?"
        );
        return;
      }
      if (
        ((this._initialized = !0),
          e.defaultSearchParams &&
          this.resolver.setDefaultSearchParams(e.defaultSearchParams),
          e.basePath && (this.resolver.basePath = e.basePath),
          e.bundleIdentifier &&
          this.resolver.setBundleIdentifier(e.bundleIdentifier),
          e.manifest)
      ) {
        let o = e.manifest;
        typeof o == "string" && (o = await this.load(o)),
          this.resolver.addManifest(o);
      }
      const t = e.texturePreference?.resolution ?? 1,
        a = typeof t == "number" ? [t] : t,
        l = await this._detectFormats({
          preferredFormats: e.texturePreference?.format,
          skipDetections: e.skipDetections,
          detections: this._detections,
        });
      this.resolver.prefer({ params: { format: l, resolution: a } }),
        e.preferences && this.setPreferences(e.preferences);
    }
    add(e) {
      this.resolver.add(e);
    }
    async load(e, t) {
      this._initialized || (await this.init());
      const a = eo(e),
        l = ui(e).map((c) => {
          if (typeof c != "string") {
            const u = this.resolver.getAlias(c);
            return (
              u.some((d) => !this.resolver.hasKey(d)) && this.add(c),
              Array.isArray(u) ? u[0] : u
            );
          }
          return this.resolver.hasKey(c) || this.add({ alias: c, src: c }), c;
        }),
        o = this.resolver.resolve(l),
        h = await this._mapLoadToResolve(o, t);
      return a ? h[l[0]] : h;
    }
    addBundle(e, t) {
      this.resolver.addBundle(e, t);
    }
    async loadBundle(e, t) {
      this._initialized || (await this.init());
      let a = !1;
      typeof e == "string" && ((a = !0), (e = [e]));
      const l = this.resolver.resolveBundle(e),
        o = {},
        h = Object.keys(l);
      let c = 0,
        u = 0;
      const d = () => {
        t?.(++c / u);
      },
        f = h.map((p) => {
          const g = l[p],
            _ = Object.values(g),
            m = [...new Set(_.flat())];
          return (
            (u += m.length),
            this._mapLoadToResolve(g, d).then((w) => {
              o[p] = w;
            })
          );
        });
      return await Promise.all(f), a ? o[e[0]] : o;
    }
    async backgroundLoad(e) {
      this._initialized || (await this.init()),
        typeof e == "string" && (e = [e]);
      const t = this.resolver.resolve(e);
      this._backgroundLoader.add(Object.values(t));
    }
    async backgroundLoadBundle(e) {
      this._initialized || (await this.init()),
        typeof e == "string" && (e = [e]);
      const t = this.resolver.resolveBundle(e);
      Object.values(t).forEach((a) => {
        this._backgroundLoader.add(Object.values(a));
      });
    }
    reset() {
      this.resolver.reset(),
        this.loader.reset(),
        this.cache.reset(),
        (this._initialized = !1);
    }
    get(e) {
      if (typeof e == "string") return We.get(e);
      const t = {};
      for (let a = 0; a < e.length; a++) t[a] = We.get(e[a]);
      return t;
    }
    async _mapLoadToResolve(e, t) {
      const a = [...new Set(Object.values(e))];
      this._backgroundLoader.active = !1;
      const l = await this.loader.load(a, t);
      this._backgroundLoader.active = !0;
      const o = {};
      return (
        a.forEach((h) => {
          const c = l[h.src],
            u = [h.src];
          h.alias && u.push(...h.alias),
            u.forEach((d) => {
              o[d] = c;
            }),
            We.set(u, c);
        }),
        o
      );
    }
    async unload(e) {
      this._initialized || (await this.init());
      const t = ui(e).map((l) => (typeof l != "string" ? l.src : l)),
        a = this.resolver.resolve(t);
      await this._unloadFromResolved(a);
    }
    async unloadBundle(e) {
      this._initialized || (await this.init()), (e = ui(e));
      const t = this.resolver.resolveBundle(e),
        a = Object.keys(t).map((l) => this._unloadFromResolved(t[l]));
      await Promise.all(a);
    }
    async _unloadFromResolved(e) {
      const t = Object.values(e);
      t.forEach((a) => {
        We.remove(a.src);
      }),
        await this.loader.unload(t);
    }
    async _detectFormats(e) {
      let t = [];
      e.preferredFormats &&
        (t = Array.isArray(e.preferredFormats)
          ? e.preferredFormats
          : [e.preferredFormats]);
      for (const a of e.detections)
        e.skipDetections || (await a.test())
          ? (t = await a.add(t))
          : e.skipDetections || (t = await a.remove(t));
      return (t = t.filter((a, l) => t.indexOf(a) === l)), t;
    }
    get detections() {
      return this._detections;
    }
    setPreferences(e) {
      this.loader.parsers.forEach((t) => {
        t.config &&
          Object.keys(t.config)
            .filter((a) => a in e)
            .forEach((a) => {
              t.config[a] = e[a];
            });
      });
    }
  }
  const Ur = new Zx();
  window.Ur = Ur;
  ge
    .handleByList(P.LoadParser, Ur.loader.parsers)
    .handleByList(P.ResolveParser, Ur.resolver.parsers)
    .handleByList(P.CacheParser, Ur.cache.parsers)
    .handleByList(P.DetectionParser, Ur.detections),
    ge.add(hx, dx, cx, mx, fx, px, gx, bx, Mx, Ix, Gx, Kf, $x, ox, nx, Zf, Kx);
  const Qf = {
    loader: P.LoadParser,
    resolver: P.ResolveParser,
    cache: P.CacheParser,
    detection: P.DetectionParser,
  };
  ge.handle(
    P.Asset,
    (r) => {
      const e = r.ref;
      Object.entries(Qf)
        .filter(([t]) => !!e[t])
        .forEach(([t, a]) =>
          ge.add(Object.assign(e[t], { extension: e[t].extension ?? a }))
        );
    },
    (r) => {
      const e = r.ref;
      Object.keys(Qf)
        .filter((t) => !!e[t])
        .forEach((t) => ge.remove(e[t]));
    }
  );
  class Jf {
    constructor(e) {
      (this._attachedDomElements = []),
        (this._renderer = e),
        this._renderer.runners.postrender.add(this),
        this._renderer.runners.init.add(this),
        (this._domElement = document.createElement("div")),
        (this._domElement.style.position = "absolute"),
        (this._domElement.style.top = "0"),
        (this._domElement.style.left = "0"),
        (this._domElement.style.pointerEvents = "none"),
        (this._domElement.style.zIndex = "1000");
    }
    init() {
      this._canvasObserver = new hu({
        domElement: this._domElement,
        renderer: this._renderer,
      });
    }
    addRenderable(e, t) {
      this._attachedDomElements.includes(e) ||
        this._attachedDomElements.push(e);
    }
    updateRenderable(e) { }
    validateRenderable(e) {
      return !0;
    }
    postrender() {
      const e = this._attachedDomElements;
      if (e.length === 0) {
        this._domElement.remove();
        return;
      }
      this._canvasObserver.ensureAttached();
      for (let t = 0; t < e.length; t++) {
        const a = e[t],
          l = a.element;
        if (!a.parent || a.globalDisplayStatus < 7)
          l?.remove(), e.splice(t, 1), t--;
        else {
          this._domElement.contains(l) ||
            ((l.style.position = "absolute"),
              (l.style.pointerEvents = "auto"),
              this._domElement.appendChild(l));
          const o = a.worldTransform,
            h = a._anchor,
            c = a.width * h.x,
            u = a.height * h.y;
          (l.style.transformOrigin = `${c}px ${u}px`),
            (l.style.transform = `matrix(${o.a}, ${o.b}, ${o.c}, ${o.d}, ${o.tx - c
              }, ${o.ty - u})`),
            (l.style.opacity = a.groupAlpha.toString());
        }
      }
    }
    destroy() {
      this._renderer.runners.postrender.remove(this);
      for (let e = 0; e < this._attachedDomElements.length; e++)
        this._attachedDomElements[e].element?.remove();
      (this._attachedDomElements.length = 0),
        this._domElement.remove(),
        this._canvasObserver.destroy(),
        (this._renderer = null);
    }
  }
  Jf.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "dom",
  };
  class Qx {
    constructor() {
      (this.interactionFrequency = 10),
        (this._deltaTime = 0),
        (this._didMove = !1),
        (this._tickerAdded = !1),
        (this._pauseUpdate = !0);
    }
    init(e) {
      this.removeTickerListener(),
        (this.events = e),
        (this.interactionFrequency = 10),
        (this._deltaTime = 0),
        (this._didMove = !1),
        (this._tickerAdded = !1),
        (this._pauseUpdate = !0);
    }
    get pauseUpdate() {
      return this._pauseUpdate;
    }
    set pauseUpdate(e) {
      this._pauseUpdate = e;
    }
    addTickerListener() {
      this._tickerAdded ||
        !this.domElement ||
        (Js.system.add(this._tickerUpdate, this, Qr.INTERACTION),
          (this._tickerAdded = !0));
    }
    removeTickerListener() {
      this._tickerAdded &&
        (Js.system.remove(this._tickerUpdate, this), (this._tickerAdded = !1));
    }
    pointerMoved() {
      this._didMove = !0;
    }
    _update() {
      if (!this.domElement || this._pauseUpdate) return;
      if (this._didMove) {
        this._didMove = !1;
        return;
      }
      const e = this.events._rootPointerEvent;
      (this.events.supportsTouchEvents && e.pointerType === "touch") ||
        globalThis.document.dispatchEvent(
          this.events.supportsPointerEvents
            ? new PointerEvent("pointermove", {
              clientX: e.clientX,
              clientY: e.clientY,
              pointerType: e.pointerType,
              pointerId: e.pointerId,
            })
            : new MouseEvent("mousemove", {
              clientX: e.clientX,
              clientY: e.clientY,
            })
        );
    }
    _tickerUpdate(e) {
      (this._deltaTime += e.deltaTime),
        !(this._deltaTime < this.interactionFrequency) &&
        ((this._deltaTime = 0), this._update());
    }
    destroy() {
      this.removeTickerListener(),
        (this.events = null),
        (this.domElement = null),
        (this._deltaTime = 0),
        (this._didMove = !1),
        (this._tickerAdded = !1),
        (this._pauseUpdate = !0);
    }
  }
  const Zi = new Qx();
  class bo extends Fn {
    constructor() {
      super(...arguments),
        (this.client = new Je()),
        (this.movement = new Je()),
        (this.offset = new Je()),
        (this.global = new Je()),
        (this.screen = new Je());
    }
    get clientX() {
      return this.client.x;
    }
    get clientY() {
      return this.client.y;
    }
    get x() {
      return this.clientX;
    }
    get y() {
      return this.clientY;
    }
    get movementX() {
      return this.movement.x;
    }
    get movementY() {
      return this.movement.y;
    }
    get offsetX() {
      return this.offset.x;
    }
    get offsetY() {
      return this.offset.y;
    }
    get globalX() {
      return this.global.x;
    }
    get globalY() {
      return this.global.y;
    }
    get screenX() {
      return this.screen.x;
    }
    get screenY() {
      return this.screen.y;
    }
    getLocalPosition(e, t, a) {
      return e.worldTransform.applyInverse(a || this.global, t);
    }
    getModifierState(e) {
      return (
        "getModifierState" in this.nativeEvent &&
        this.nativeEvent.getModifierState(e)
      );
    }
    initMouseEvent(e, t, a, l, o, h, c, u, d, f, p, g, _, m, w) {
      throw new Error("Method not implemented.");
    }
  }
  class yi extends bo {
    constructor() {
      super(...arguments),
        (this.width = 0),
        (this.height = 0),
        (this.isPrimary = !1);
    }
    getCoalescedEvents() {
      return this.type === "pointermove" ||
        this.type === "mousemove" ||
        this.type === "touchmove"
        ? [this]
        : [];
    }
    getPredictedEvents() {
      throw new Error("getPredictedEvents is not supported!");
    }
  }
  class cn extends bo {
    constructor() {
      super(...arguments),
        (this.DOM_DELTA_PIXEL = 0),
        (this.DOM_DELTA_LINE = 1),
        (this.DOM_DELTA_PAGE = 2);
    }
  }
  (cn.DOM_DELTA_PIXEL = 0), (cn.DOM_DELTA_LINE = 1), (cn.DOM_DELTA_PAGE = 2);
  const Jx = 2048,
    ev = new Je(),
    sa = new Je();
  class tv {
    constructor(e) {
      (this.dispatch = new Os()),
        (this.moveOnAll = !1),
        (this.enableGlobalMoveEvents = !0),
        (this.mappingState = { trackingData: {} }),
        (this.eventPool = new Map()),
        (this._allInteractiveElements = []),
        (this._hitElements = []),
        (this._isPointerMoveEvent = !1),
        (this.rootTarget = e),
        (this.hitPruneFn = this.hitPruneFn.bind(this)),
        (this.hitTestFn = this.hitTestFn.bind(this)),
        (this.mapPointerDown = this.mapPointerDown.bind(this)),
        (this.mapPointerMove = this.mapPointerMove.bind(this)),
        (this.mapPointerOut = this.mapPointerOut.bind(this)),
        (this.mapPointerOver = this.mapPointerOver.bind(this)),
        (this.mapPointerUp = this.mapPointerUp.bind(this)),
        (this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
        (this.mapWheel = this.mapWheel.bind(this)),
        (this.mappingTable = {}),
        this.addEventMapping("pointerdown", this.mapPointerDown),
        this.addEventMapping("pointermove", this.mapPointerMove),
        this.addEventMapping("pointerout", this.mapPointerOut),
        this.addEventMapping("pointerleave", this.mapPointerOut),
        this.addEventMapping("pointerover", this.mapPointerOver),
        this.addEventMapping("pointerup", this.mapPointerUp),
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
        this.addEventMapping("wheel", this.mapWheel);
    }
    addEventMapping(e, t) {
      this.mappingTable[e] || (this.mappingTable[e] = []),
        this.mappingTable[e].push({ fn: t, priority: 0 }),
        this.mappingTable[e].sort((a, l) => a.priority - l.priority);
    }
    dispatchEvent(e, t) {
      (e.propagationStopped = !1),
        (e.propagationImmediatelyStopped = !1),
        this.propagate(e, t),
        this.dispatch.emit(t || e.type, e);
    }
    mapEvent(e) {
      if (!this.rootTarget) return;
      const t = this.mappingTable[e.type];
      if (t) for (let a = 0, l = t.length; a < l; a++) t[a].fn(e);
      else pe(`[EventBoundary]: Event mapping not defined for ${e.type}`);
    }
    hitTest(e, t) {
      Zi.pauseUpdate = !0;
      const l =
        this._isPointerMoveEvent && this.enableGlobalMoveEvents
          ? "hitTestMoveRecursive"
          : "hitTestRecursive",
        o = this[l](
          this.rootTarget,
          this.rootTarget.eventMode,
          ev.set(e, t),
          this.hitTestFn,
          this.hitPruneFn
        );
      return o && o[0];
    }
    propagate(e, t) {
      if (!e.target) return;
      const a = e.composedPath();
      e.eventPhase = e.CAPTURING_PHASE;
      for (let l = 0, o = a.length - 1; l < o; l++)
        if (
          ((e.currentTarget = a[l]),
            this.notifyTarget(e, t),
            e.propagationStopped || e.propagationImmediatelyStopped)
        )
          return;
      if (
        ((e.eventPhase = e.AT_TARGET),
          (e.currentTarget = e.target),
          this.notifyTarget(e, t),
          !(e.propagationStopped || e.propagationImmediatelyStopped))
      ) {
        e.eventPhase = e.BUBBLING_PHASE;
        for (let l = a.length - 2; l >= 0; l--)
          if (
            ((e.currentTarget = a[l]),
              this.notifyTarget(e, t),
              e.propagationStopped || e.propagationImmediatelyStopped)
          )
            return;
      }
    }
    all(e, t, a = this._allInteractiveElements) {
      if (a.length === 0) return;
      e.eventPhase = e.BUBBLING_PHASE;
      const l = Array.isArray(t) ? t : [t];
      for (let o = a.length - 1; o >= 0; o--)
        l.forEach((h) => {
          (e.currentTarget = a[o]), this.notifyTarget(e, h);
        });
    }
    propagationPath(e) {
      const t = [e];
      for (let a = 0; a < Jx && e !== this.rootTarget && e.parent; a++) {
        if (!e.parent)
          throw new Error(
            "Cannot find propagation path to disconnected target"
          );
        t.push(e.parent), (e = e.parent);
      }
      return t.reverse(), t;
    }
    hitTestMoveRecursive(e, t, a, l, o, h = !1) {
      let c = !1;
      if (this._interactivePrune(e)) return null;
      if (
        ((e.eventMode === "dynamic" || t === "dynamic") &&
          (Zi.pauseUpdate = !1),
          e.interactiveChildren && e.children)
      ) {
        const f = e.children;
        for (let p = f.length - 1; p >= 0; p--) {
          const g = f[p],
            _ = this.hitTestMoveRecursive(
              g,
              this._isInteractive(t) ? t : g.eventMode,
              a,
              l,
              o,
              h || o(e, a)
            );
          if (_) {
            if (_.length > 0 && !_[_.length - 1].parent) continue;
            const m = e.isInteractive();
            (_.length > 0 || m) &&
              (m && this._allInteractiveElements.push(e), _.push(e)),
              this._hitElements.length === 0 && (this._hitElements = _),
              (c = !0);
          }
        }
      }
      const u = this._isInteractive(t),
        d = e.isInteractive();
      return (
        d && d && this._allInteractiveElements.push(e),
        h || this._hitElements.length > 0
          ? null
          : c
            ? this._hitElements
            : u && !o(e, a) && l(e, a)
              ? d
                ? [e]
                : []
              : null
      );
    }
    hitTestRecursive(e, t, a, l, o) {
      if (this._interactivePrune(e) || o(e, a)) return null;
      if (
        ((e.eventMode === "dynamic" || t === "dynamic") &&
          (Zi.pauseUpdate = !1),
          e.interactiveChildren && e.children)
      ) {
        const u = e.children,
          d = a;
        for (let f = u.length - 1; f >= 0; f--) {
          const p = u[f],
            g = this.hitTestRecursive(
              p,
              this._isInteractive(t) ? t : p.eventMode,
              d,
              l,
              o
            );
          if (g) {
            if (g.length > 0 && !g[g.length - 1].parent) continue;
            const _ = e.isInteractive();
            return (g.length > 0 || _) && g.push(e), g;
          }
        }
      }
      const h = this._isInteractive(t),
        c = e.isInteractive();
      return h && l(e, a) ? (c ? [e] : []) : null;
    }
    _isInteractive(e) {
      return e === "static" || e === "dynamic";
    }
    _interactivePrune(e) {
      return (
        !e ||
        !e.visible ||
        !e.renderable ||
        !e.measurable ||
        e.eventMode === "none" ||
        (e.eventMode === "passive" && !e.interactiveChildren)
      );
    }
    hitPruneFn(e, t) {
      if (
        e.hitArea &&
        (e.worldTransform.applyInverse(t, sa), !e.hitArea.contains(sa.x, sa.y))
      )
        return !0;
      if (e.effects && e.effects.length)
        for (let a = 0; a < e.effects.length; a++) {
          const l = e.effects[a];
          if (l.containsPoint && !l.containsPoint(t, this.hitTestFn)) return !0;
        }
      return !1;
    }
    hitTestFn(e, t) {
      return e.hitArea
        ? !0
        : e?.containsPoint
          ? (e.worldTransform.applyInverse(t, sa), e.containsPoint(sa))
          : !1;
    }
    notifyTarget(e, t) {
      if (!e.currentTarget.isInteractive()) return;
      t ?? (t = e.type);
      const a = `on${t}`;
      e.currentTarget[a]?.(e);
      const l =
        e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET
          ? `${t}capture`
          : t;
      this._notifyListeners(e, l),
        e.eventPhase === e.AT_TARGET && this._notifyListeners(e, t);
    }
    mapPointerDown(e) {
      if (!(e instanceof yi)) {
        pe("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const t = this.createPointerEvent(e);
      if ((this.dispatchEvent(t, "pointerdown"), t.pointerType === "touch"))
        this.dispatchEvent(t, "touchstart");
      else if (t.pointerType === "mouse" || t.pointerType === "pen") {
        const l = t.button === 2;
        this.dispatchEvent(t, l ? "rightdown" : "mousedown");
      }
      const a = this.trackingData(e.pointerId);
      (a.pressTargetsByButton[e.button] = t.composedPath()), this.freeEvent(t);
    }
    mapPointerMove(e) {
      if (!(e instanceof yi)) {
        pe("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      (this._allInteractiveElements.length = 0),
        (this._hitElements.length = 0),
        (this._isPointerMoveEvent = !0);
      const t = this.createPointerEvent(e);
      this._isPointerMoveEvent = !1;
      const a = t.pointerType === "mouse" || t.pointerType === "pen",
        l = this.trackingData(e.pointerId),
        o = this.findMountedTarget(l.overTargets);
      if (l.overTargets?.length > 0 && o !== t.target) {
        const u = e.type === "mousemove" ? "mouseout" : "pointerout",
          d = this.createPointerEvent(e, u, o);
        if (
          (this.dispatchEvent(d, "pointerout"),
            a && this.dispatchEvent(d, "mouseout"),
            !t.composedPath().includes(o))
        ) {
          const f = this.createPointerEvent(e, "pointerleave", o);
          for (
            f.eventPhase = f.AT_TARGET;
            f.target && !t.composedPath().includes(f.target);

          )
            (f.currentTarget = f.target),
              this.notifyTarget(f),
              a && this.notifyTarget(f, "mouseleave"),
              (f.target = f.target.parent);
          this.freeEvent(f);
        }
        this.freeEvent(d);
      }
      if (o !== t.target) {
        const u = e.type === "mousemove" ? "mouseover" : "pointerover",
          d = this.clonePointerEvent(t, u);
        this.dispatchEvent(d, "pointerover"),
          a && this.dispatchEvent(d, "mouseover");
        let f = o?.parent;
        for (; f && f !== this.rootTarget.parent && f !== t.target;)
          f = f.parent;
        if (!f || f === this.rootTarget.parent) {
          const g = this.clonePointerEvent(t, "pointerenter");
          for (
            g.eventPhase = g.AT_TARGET;
            g.target && g.target !== o && g.target !== this.rootTarget.parent;

          )
            (g.currentTarget = g.target),
              this.notifyTarget(g),
              a && this.notifyTarget(g, "mouseenter"),
              (g.target = g.target.parent);
          this.freeEvent(g);
        }
        this.freeEvent(d);
      }
      const h = [],
        c = this.enableGlobalMoveEvents ?? !0;
      this.moveOnAll
        ? h.push("pointermove")
        : this.dispatchEvent(t, "pointermove"),
        c && h.push("globalpointermove"),
        t.pointerType === "touch" &&
        (this.moveOnAll
          ? h.splice(1, 0, "touchmove")
          : this.dispatchEvent(t, "touchmove"),
          c && h.push("globaltouchmove")),
        a &&
        (this.moveOnAll
          ? h.splice(1, 0, "mousemove")
          : this.dispatchEvent(t, "mousemove"),
          c && h.push("globalmousemove"),
          (this.cursor = t.target?.cursor)),
        h.length > 0 && this.all(t, h),
        (this._allInteractiveElements.length = 0),
        (this._hitElements.length = 0),
        (l.overTargets = t.composedPath()),
        this.freeEvent(t);
    }
    mapPointerOver(e) {
      if (!(e instanceof yi)) {
        pe("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const t = this.trackingData(e.pointerId),
        a = this.createPointerEvent(e),
        l = a.pointerType === "mouse" || a.pointerType === "pen";
      this.dispatchEvent(a, "pointerover"),
        l && this.dispatchEvent(a, "mouseover"),
        a.pointerType === "mouse" && (this.cursor = a.target?.cursor);
      const o = this.clonePointerEvent(a, "pointerenter");
      for (
        o.eventPhase = o.AT_TARGET;
        o.target && o.target !== this.rootTarget.parent;

      )
        (o.currentTarget = o.target),
          this.notifyTarget(o),
          l && this.notifyTarget(o, "mouseenter"),
          (o.target = o.target.parent);
      (t.overTargets = a.composedPath()), this.freeEvent(a), this.freeEvent(o);
    }
    mapPointerOut(e) {
      if (!(e instanceof yi)) {
        pe("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const t = this.trackingData(e.pointerId);
      if (t.overTargets) {
        const a = e.pointerType === "mouse" || e.pointerType === "pen",
          l = this.findMountedTarget(t.overTargets),
          o = this.createPointerEvent(e, "pointerout", l);
        this.dispatchEvent(o), a && this.dispatchEvent(o, "mouseout");
        const h = this.createPointerEvent(e, "pointerleave", l);
        for (
          h.eventPhase = h.AT_TARGET;
          h.target && h.target !== this.rootTarget.parent;

        )
          (h.currentTarget = h.target),
            this.notifyTarget(h),
            a && this.notifyTarget(h, "mouseleave"),
            (h.target = h.target.parent);
        (t.overTargets = null), this.freeEvent(o), this.freeEvent(h);
      }
      this.cursor = null;
    }
    mapPointerUp(e) {
      if (!(e instanceof yi)) {
        pe("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const t = performance.now(),
        a = this.createPointerEvent(e);
      if ((this.dispatchEvent(a, "pointerup"), a.pointerType === "touch"))
        this.dispatchEvent(a, "touchend");
      else if (a.pointerType === "mouse" || a.pointerType === "pen") {
        const c = a.button === 2;
        this.dispatchEvent(a, c ? "rightup" : "mouseup");
      }
      const l = this.trackingData(e.pointerId),
        o = this.findMountedTarget(l.pressTargetsByButton[e.button]);
      let h = o;
      if (o && !a.composedPath().includes(o)) {
        let c = o;
        for (; c && !a.composedPath().includes(c);) {
          if (
            ((a.currentTarget = c),
              this.notifyTarget(a, "pointerupoutside"),
              a.pointerType === "touch")
          )
            this.notifyTarget(a, "touchendoutside");
          else if (a.pointerType === "mouse" || a.pointerType === "pen") {
            const u = a.button === 2;
            this.notifyTarget(a, u ? "rightupoutside" : "mouseupoutside");
          }
          c = c.parent;
        }
        delete l.pressTargetsByButton[e.button], (h = c);
      }
      if (h) {
        const c = this.clonePointerEvent(a, "click");
        (c.target = h),
          (c.path = null),
          l.clicksByButton[e.button] ||
          (l.clicksByButton[e.button] = {
            clickCount: 0,
            target: c.target,
            timeStamp: t,
          });
        const u = l.clicksByButton[e.button];
        if (
          (u.target === c.target && t - u.timeStamp < 200
            ? ++u.clickCount
            : (u.clickCount = 1),
            (u.target = c.target),
            (u.timeStamp = t),
            (c.detail = u.clickCount),
            c.pointerType === "mouse")
        ) {
          const d = c.button === 2;
          this.dispatchEvent(c, d ? "rightclick" : "click");
        } else c.pointerType === "touch" && this.dispatchEvent(c, "tap");
        this.dispatchEvent(c, "pointertap"), this.freeEvent(c);
      }
      this.freeEvent(a);
    }
    mapPointerUpOutside(e) {
      if (!(e instanceof yi)) {
        pe("EventBoundary cannot map a non-pointer event as a pointer event");
        return;
      }
      const t = this.trackingData(e.pointerId),
        a = this.findMountedTarget(t.pressTargetsByButton[e.button]),
        l = this.createPointerEvent(e);
      if (a) {
        let o = a;
        for (; o;)
          (l.currentTarget = o),
            this.notifyTarget(l, "pointerupoutside"),
            l.pointerType === "touch"
              ? this.notifyTarget(l, "touchendoutside")
              : (l.pointerType === "mouse" || l.pointerType === "pen") &&
              this.notifyTarget(
                l,
                l.button === 2 ? "rightupoutside" : "mouseupoutside"
              ),
            (o = o.parent);
        delete t.pressTargetsByButton[e.button];
      }
      this.freeEvent(l);
    }
    mapWheel(e) {
      if (!(e instanceof cn)) {
        pe("EventBoundary cannot map a non-wheel event as a wheel event");
        return;
      }
      const t = this.createWheelEvent(e);
      this.dispatchEvent(t), this.freeEvent(t);
    }
    findMountedTarget(e) {
      if (!e) return null;
      let t = e[0];
      for (let a = 1; a < e.length && e[a].parent === t; a++) t = e[a];
      return t;
    }
    createPointerEvent(e, t, a) {
      const l = this.allocateEvent(yi);
      return (
        this.copyPointerData(e, l),
        this.copyMouseData(e, l),
        this.copyData(e, l),
        (l.nativeEvent = e.nativeEvent),
        (l.originalEvent = e),
        (l.target =
          a ?? this.hitTest(l.global.x, l.global.y) ?? this._hitElements[0]),
        typeof t == "string" && (l.type = t),
        l
      );
    }
    createWheelEvent(e) {
      const t = this.allocateEvent(cn);
      return (
        this.copyWheelData(e, t),
        this.copyMouseData(e, t),
        this.copyData(e, t),
        (t.nativeEvent = e.nativeEvent),
        (t.originalEvent = e),
        (t.target = this.hitTest(t.global.x, t.global.y)),
        t
      );
    }
    clonePointerEvent(e, t) {
      const a = this.allocateEvent(yi);
      return (
        (a.nativeEvent = e.nativeEvent),
        (a.originalEvent = e.originalEvent),
        this.copyPointerData(e, a),
        this.copyMouseData(e, a),
        this.copyData(e, a),
        (a.target = e.target),
        (a.path = e.composedPath().slice()),
        (a.type = t ?? a.type),
        a
      );
    }
    copyWheelData(e, t) {
      (t.deltaMode = e.deltaMode),
        (t.deltaX = e.deltaX),
        (t.deltaY = e.deltaY),
        (t.deltaZ = e.deltaZ);
    }
    copyPointerData(e, t) {
      e instanceof yi &&
        t instanceof yi &&
        ((t.pointerId = e.pointerId),
          (t.width = e.width),
          (t.height = e.height),
          (t.isPrimary = e.isPrimary),
          (t.pointerType = e.pointerType),
          (t.pressure = e.pressure),
          (t.tangentialPressure = e.tangentialPressure),
          (t.tiltX = e.tiltX),
          (t.tiltY = e.tiltY),
          (t.twist = e.twist));
    }
    copyMouseData(e, t) {
      e instanceof bo &&
        t instanceof bo &&
        ((t.altKey = e.altKey),
          (t.button = e.button),
          (t.buttons = e.buttons),
          t.client.copyFrom(e.client),
          (t.ctrlKey = e.ctrlKey),
          (t.metaKey = e.metaKey),
          t.movement.copyFrom(e.movement),
          t.screen.copyFrom(e.screen),
          (t.shiftKey = e.shiftKey),
          t.global.copyFrom(e.global));
    }
    copyData(e, t) {
      (t.isTrusted = e.isTrusted),
        (t.srcElement = e.srcElement),
        (t.timeStamp = performance.now()),
        (t.type = e.type),
        (t.detail = e.detail),
        (t.view = e.view),
        (t.which = e.which),
        t.layer.copyFrom(e.layer),
        t.page.copyFrom(e.page);
    }
    trackingData(e) {
      return (
        this.mappingState.trackingData[e] ||
        (this.mappingState.trackingData[e] = {
          pressTargetsByButton: {},
          clicksByButton: {},
          overTarget: null,
        }),
        this.mappingState.trackingData[e]
      );
    }
    allocateEvent(e) {
      this.eventPool.has(e) || this.eventPool.set(e, []);
      const t = this.eventPool.get(e).pop() || new e(this);
      return (
        (t.eventPhase = t.NONE),
        (t.currentTarget = null),
        (t.defaultPrevented = !1),
        (t.path = null),
        (t.target = null),
        t
      );
    }
    freeEvent(e) {
      if (e.manager !== this)
        throw new Error(
          "It is illegal to free an event not managed by this EventBoundary!"
        );
      const t = e.constructor;
      this.eventPool.has(t) || this.eventPool.set(t, []),
        this.eventPool.get(t).push(e);
    }
    _notifyListeners(e, t) {
      const a = e.currentTarget._events[t];
      if (a)
        if ("fn" in a)
          a.once && e.currentTarget.removeListener(t, a.fn, void 0, !0),
            a.fn.call(a.context, e);
        else
          for (
            let l = 0, o = a.length;
            l < o && !e.propagationImmediatelyStopped;
            l++
          )
            a[l].once && e.currentTarget.removeListener(t, a[l].fn, void 0, !0),
              a[l].fn.call(a[l].context, e);
    }
  }
  const sv = 1,
    iv = {
      touchstart: "pointerdown",
      touchend: "pointerup",
      touchendoutside: "pointerupoutside",
      touchmove: "pointermove",
      touchcancel: "pointercancel",
    },
    Yh = class dd {
      constructor(e) {
        (this.supportsTouchEvents = "ontouchstart" in globalThis),
          (this.supportsPointerEvents = !!globalThis.PointerEvent),
          (this.domElement = null),
          (this.resolution = 1),
          (this.renderer = e),
          (this.rootBoundary = new tv(null)),
          Zi.init(this),
          (this.autoPreventDefault = !0),
          (this._eventsAdded = !1),
          (this._rootPointerEvent = new yi(null)),
          (this._rootWheelEvent = new cn(null)),
          (this.cursorStyles = { default: "inherit", pointer: "pointer" }),
          (this.features = new Proxy(
            { ...dd.defaultEventFeatures },
            {
              set: (t, a, l) => (
                a === "globalMove" &&
                (this.rootBoundary.enableGlobalMoveEvents = l),
                (t[a] = l),
                !0
              ),
            }
          )),
          (this._onPointerDown = this._onPointerDown.bind(this)),
          (this._onPointerMove = this._onPointerMove.bind(this)),
          (this._onPointerUp = this._onPointerUp.bind(this)),
          (this._onPointerOverOut = this._onPointerOverOut.bind(this)),
          (this.onWheel = this.onWheel.bind(this));
      }
      static get defaultEventMode() {
        return this._defaultEventMode;
      }
      init(e) {
        const { canvas: t, resolution: a } = this.renderer;
        this.setTargetElement(t),
          (this.resolution = a),
          (dd._defaultEventMode = e.eventMode ?? "passive"),
          Object.assign(this.features, e.eventFeatures ?? {}),
          (this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove);
      }
      resolutionChange(e) {
        this.resolution = e;
      }
      destroy() {
        Zi.destroy(),
          this.setTargetElement(null),
          (this.renderer = null),
          (this._currentCursor = null);
      }
      setCursor(e) {
        e || (e = "default");
        let t = !0;
        if (
          (globalThis.OffscreenCanvas &&
            this.domElement instanceof OffscreenCanvas &&
            (t = !1),
            this._currentCursor === e)
        )
          return;
        this._currentCursor = e;
        const a = this.cursorStyles[e];
        if (a)
          switch (typeof a) {
            case "string":
              t && (this.domElement.style.cursor = a);
              break;
            case "function":
              a(e);
              break;
            case "object":
              t && Object.assign(this.domElement.style, a);
              break;
          }
        else
          t &&
            typeof e == "string" &&
            !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) &&
            (this.domElement.style.cursor = e);
      }
      get pointer() {
        return this._rootPointerEvent;
      }
      _onPointerDown(e) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const t = this._normalizeToPointerData(e);
        this.autoPreventDefault &&
          t[0].isNormalized &&
          (e.cancelable || !("cancelable" in e)) &&
          e.preventDefault();
        for (let a = 0, l = t.length; a < l; a++) {
          const o = t[a],
            h = this._bootstrapEvent(this._rootPointerEvent, o);
          this.rootBoundary.mapEvent(h);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      _onPointerMove(e) {
        if (!this.features.move) return;
        (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
          Zi.pointerMoved();
        const t = this._normalizeToPointerData(e);
        for (let a = 0, l = t.length; a < l; a++) {
          const o = this._bootstrapEvent(this._rootPointerEvent, t[a]);
          this.rootBoundary.mapEvent(o);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      _onPointerUp(e) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        let t = e.target;
        e.composedPath &&
          e.composedPath().length > 0 &&
          (t = e.composedPath()[0]);
        const a = t !== this.domElement ? "outside" : "",
          l = this._normalizeToPointerData(e);
        for (let o = 0, h = l.length; o < h; o++) {
          const c = this._bootstrapEvent(this._rootPointerEvent, l[o]);
          (c.type += a), this.rootBoundary.mapEvent(c);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      _onPointerOverOut(e) {
        if (!this.features.click) return;
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
        const t = this._normalizeToPointerData(e);
        for (let a = 0, l = t.length; a < l; a++) {
          const o = this._bootstrapEvent(this._rootPointerEvent, t[a]);
          this.rootBoundary.mapEvent(o);
        }
        this.setCursor(this.rootBoundary.cursor);
      }
      onWheel(e) {
        if (!this.features.wheel) return;
        const t = this.normalizeWheelEvent(e);
        (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
          this.rootBoundary.mapEvent(t);
      }
      setTargetElement(e) {
        this._removeEvents(),
          (this.domElement = e),
          (Zi.domElement = e),
          this._addEvents();
      }
      _addEvents() {
        if (this._eventsAdded || !this.domElement) return;
        Zi.addTickerListener();
        const e = this.domElement.style;
        e &&
          (globalThis.navigator.msPointerEnabled
            ? ((e.msContentZooming = "none"), (e.msTouchAction = "none"))
            : this.supportsPointerEvents && (e.touchAction = "none")),
          this.supportsPointerEvents
            ? (globalThis.document.addEventListener(
              "pointermove",
              this._onPointerMove,
              !0
            ),
              this.domElement.addEventListener(
                "pointerdown",
                this._onPointerDown,
                !0
              ),
              this.domElement.addEventListener(
                "pointerleave",
                this._onPointerOverOut,
                !0
              ),
              this.domElement.addEventListener(
                "pointerover",
                this._onPointerOverOut,
                !0
              ),
              globalThis.addEventListener("pointerup", this._onPointerUp, !0))
            : (globalThis.document.addEventListener(
              "mousemove",
              this._onPointerMove,
              !0
            ),
              this.domElement.addEventListener(
                "mousedown",
                this._onPointerDown,
                !0
              ),
              this.domElement.addEventListener(
                "mouseout",
                this._onPointerOverOut,
                !0
              ),
              this.domElement.addEventListener(
                "mouseover",
                this._onPointerOverOut,
                !0
              ),
              globalThis.addEventListener("mouseup", this._onPointerUp, !0),
              this.supportsTouchEvents &&
              (this.domElement.addEventListener(
                "touchstart",
                this._onPointerDown,
                !0
              ),
                this.domElement.addEventListener(
                  "touchend",
                  this._onPointerUp,
                  !0
                ),
                this.domElement.addEventListener(
                  "touchmove",
                  this._onPointerMove,
                  !0
                ))),
          this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0,
          }),
          (this._eventsAdded = !0);
      }
      _removeEvents() {
        if (!this._eventsAdded || !this.domElement) return;
        Zi.removeTickerListener();
        const e = this.domElement.style;
        e &&
          (globalThis.navigator.msPointerEnabled
            ? ((e.msContentZooming = ""), (e.msTouchAction = ""))
            : this.supportsPointerEvents && (e.touchAction = "")),
          this.supportsPointerEvents
            ? (globalThis.document.removeEventListener(
              "pointermove",
              this._onPointerMove,
              !0
            ),
              this.domElement.removeEventListener(
                "pointerdown",
                this._onPointerDown,
                !0
              ),
              this.domElement.removeEventListener(
                "pointerleave",
                this._onPointerOverOut,
                !0
              ),
              this.domElement.removeEventListener(
                "pointerover",
                this._onPointerOverOut,
                !0
              ),
              globalThis.removeEventListener(
                "pointerup",
                this._onPointerUp,
                !0
              ))
            : (globalThis.document.removeEventListener(
              "mousemove",
              this._onPointerMove,
              !0
            ),
              this.domElement.removeEventListener(
                "mousedown",
                this._onPointerDown,
                !0
              ),
              this.domElement.removeEventListener(
                "mouseout",
                this._onPointerOverOut,
                !0
              ),
              this.domElement.removeEventListener(
                "mouseover",
                this._onPointerOverOut,
                !0
              ),
              globalThis.removeEventListener("mouseup", this._onPointerUp, !0),
              this.supportsTouchEvents &&
              (this.domElement.removeEventListener(
                "touchstart",
                this._onPointerDown,
                !0
              ),
                this.domElement.removeEventListener(
                  "touchend",
                  this._onPointerUp,
                  !0
                ),
                this.domElement.removeEventListener(
                  "touchmove",
                  this._onPointerMove,
                  !0
                ))),
          this.domElement.removeEventListener("wheel", this.onWheel, !0),
          (this.domElement = null),
          (this._eventsAdded = !1);
      }
      mapPositionToPoint(e, t, a) {
        const l = this.domElement.isConnected
          ? this.domElement.getBoundingClientRect()
          : {
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0,
          },
          o = 1 / this.resolution;
        (e.x = (t - l.left) * (this.domElement.width / l.width) * o),
          (e.y = (a - l.top) * (this.domElement.height / l.height) * o);
      }
      _normalizeToPointerData(e) {
        const t = [];
        if (this.supportsTouchEvents && typeof TouchEvent !== "undefined" && e instanceof TouchEvent)
          for (let a = 0, l = e.changedTouches.length; a < l; a++) {
            const o = e.changedTouches[a];
            typeof o.button > "u" && (o.button = 0),
              typeof o.buttons > "u" && (o.buttons = 1),
              typeof o.isPrimary > "u" &&
              (o.isPrimary =
                e.touches.length === 1 && e.type === "touchstart"),
              typeof o.width > "u" && (o.width = o.radiusX || 1),
              typeof o.height > "u" && (o.height = o.radiusY || 1),
              typeof o.tiltX > "u" && (o.tiltX = 0),
              typeof o.tiltY > "u" && (o.tiltY = 0),
              typeof o.pointerType > "u" && (o.pointerType = "touch"),
              typeof o.pointerId > "u" && (o.pointerId = o.identifier || 0),
              typeof o.pressure > "u" && (o.pressure = o.force || 0.5),
              typeof o.twist > "u" && (o.twist = 0),
              typeof o.tangentialPressure > "u" && (o.tangentialPressure = 0),
              typeof o.layerX > "u" && (o.layerX = o.offsetX = o.clientX),
              typeof o.layerY > "u" && (o.layerY = o.offsetY = o.clientY),
              (o.isNormalized = !0),
              (o.type = e.type),
              t.push(o);
          }
        else if (
          !globalThis.MouseEvent ||
          (e instanceof MouseEvent &&
            (!this.supportsPointerEvents ||
              !(e instanceof globalThis.PointerEvent)))
        ) {
          const a = e;
          typeof a.isPrimary > "u" && (a.isPrimary = !0),
            typeof a.width > "u" && (a.width = 1),
            typeof a.height > "u" && (a.height = 1),
            typeof a.tiltX > "u" && (a.tiltX = 0),
            typeof a.tiltY > "u" && (a.tiltY = 0),
            typeof a.pointerType > "u" && (a.pointerType = "mouse"),
            typeof a.pointerId > "u" && (a.pointerId = sv),
            typeof a.pressure > "u" && (a.pressure = 0.5),
            typeof a.twist > "u" && (a.twist = 0),
            typeof a.tangentialPressure > "u" && (a.tangentialPressure = 0),
            (a.isNormalized = !0),
            t.push(a);
        } else t.push(e);
        return t;
      }
      normalizeWheelEvent(e) {
        const t = this._rootWheelEvent;
        return (
          this._transferMouseData(t, e),
          (t.deltaX = e.deltaX),
          (t.deltaY = e.deltaY),
          (t.deltaZ = e.deltaZ),
          (t.deltaMode = e.deltaMode),
          this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
          t.global.copyFrom(t.screen),
          t.offset.copyFrom(t.screen),
          (t.nativeEvent = e),
          (t.type = e.type),
          t
        );
      }
      _bootstrapEvent(e, t) {
        return (
          (e.originalEvent = null),
          (e.nativeEvent = t),
          (e.pointerId = t.pointerId),
          (e.width = t.width),
          (e.height = t.height),
          (e.isPrimary = t.isPrimary),
          (e.pointerType = t.pointerType),
          (e.pressure = t.pressure),
          (e.tangentialPressure = t.tangentialPressure),
          (e.tiltX = t.tiltX),
          (e.tiltY = t.tiltY),
          (e.twist = t.twist),
          this._transferMouseData(e, t),
          this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
          e.global.copyFrom(e.screen),
          e.offset.copyFrom(e.screen),
          (e.isTrusted = t.isTrusted),
          e.type === "pointerleave" && (e.type = "pointerout"),
          e.type.startsWith("mouse") &&
          (e.type = e.type.replace("mouse", "pointer")),
          e.type.startsWith("touch") && (e.type = iv[e.type] || e.type),
          e
        );
      }
      _transferMouseData(e, t) {
        (e.isTrusted = t.isTrusted),
          (e.srcElement = t.srcElement),
          (e.timeStamp = performance.now()),
          (e.type = t.type),
          (e.altKey = t.altKey),
          (e.button = t.button),
          (e.buttons = t.buttons),
          (e.client.x = t.clientX),
          (e.client.y = t.clientY),
          (e.ctrlKey = t.ctrlKey),
          (e.metaKey = t.metaKey),
          (e.movement.x = t.movementX),
          (e.movement.y = t.movementY),
          (e.page.x = t.pageX),
          (e.page.y = t.pageY),
          (e.relatedTarget = null),
          (e.shiftKey = t.shiftKey);
      }
    };
  (Yh.extension = {
    name: "events",
    type: [P.WebGLSystem, P.CanvasSystem, P.WebGPUSystem],
    priority: -1,
  }),
    (Yh.defaultEventFeatures = {
      move: !0,
      globalMove: !0,
      click: !0,
      wheel: !0,
    });
  let ep = Yh;
  const rv = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    get interactive() {
      return this.eventMode === "dynamic" || this.eventMode === "static";
    },
    set interactive(r) {
      this.eventMode = r ? "static" : "passive";
    },
    _internalEventMode: void 0,
    get eventMode() {
      return this._internalEventMode ?? ep.defaultEventMode;
    },
    set eventMode(r) {
      this._internalEventMode = r;
    },
    isInteractive() {
      return this.eventMode === "static" || this.eventMode === "dynamic";
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(r, e, t) {
      const a =
        (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
        l = typeof t == "object" ? t.signal : void 0,
        o = typeof t == "object" ? t.once === !0 : !1,
        h = typeof e == "function" ? void 0 : e;
      r = a ? `${r}capture` : r;
      const c = typeof e == "function" ? e : e.handleEvent,
        u = this;
      l &&
        l.addEventListener("abort", () => {
          u.off(r, c, h);
        }),
        o ? u.once(r, c, h) : u.on(r, c, h);
    },
    removeEventListener(r, e, t) {
      const a =
        (typeof t == "boolean" && t) || (typeof t == "object" && t.capture),
        l = typeof e == "function" ? void 0 : e;
      (r = a ? `${r}capture` : r),
        (e = typeof e == "function" ? e : e.handleEvent),
        this.off(r, e, l);
    },
    dispatchEvent(r) {
      if (!(r instanceof Fn))
        throw new Error(
          "Container cannot propagate events outside of the Federated Events API"
        );
      return (
        (r.defaultPrevented = !1),
        (r.path = null),
        (r.target = this),
        r.manager.dispatchEvent(r),
        !r.defaultPrevented
      );
    },
  };
  class tp {
    constructor(e) {
      this._renderer = e;
    }
    push(e, t, a) {
      this._renderer.renderPipes.batch.break(a),
        a.add({
          renderPipeId: "filter",
          canBundle: !1,
          action: "pushFilter",
          container: t,
          filterEffect: e,
        });
    }
    pop(e, t, a) {
      this._renderer.renderPipes.batch.break(a),
        a.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 });
    }
    execute(e) {
      e.action === "pushFilter"
        ? this._renderer.filter.push(e)
        : e.action === "popFilter" && this._renderer.filter.pop();
    }
    destroy() {
      this._renderer = null;
    }
  }
  tp.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "filter",
  };
  const sp = new ae();
  function nv(r, e) {
    e.clear();
    const t = e.matrix;
    for (let a = 0; a < r.length; a++) {
      const l = r[a];
      if (l.globalDisplayStatus < 7) continue;
      const o = l.renderGroup ?? l.parentRenderGroup;
      o?.isCachedAsTexture
        ? (e.matrix = sp
          .copyFrom(o.textureOffsetInverseTransform)
          .append(l.worldTransform))
        : o?._parentCacheAsTextureRenderGroup
          ? (e.matrix = sp
            .copyFrom(o._parentCacheAsTextureRenderGroup.inverseWorldTransform)
            .append(l.groupTransform))
          : (e.matrix = l.worldTransform),
        e.addBounds(l.bounds);
    }
    return (e.matrix = t), e;
  }
  const av = new Yn({
    attributes: {
      aPosition: {
        buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        format: "float32x2",
        stride: 8,
        offset: 0,
      },
    },
    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),
  });
  class ov {
    constructor() {
      (this.skip = !1),
        (this.inputTexture = null),
        (this.backTexture = null),
        (this.filters = null),
        (this.bounds = new cs()),
        (this.container = null),
        (this.blendRequired = !1),
        (this.outputRenderSurface = null),
        (this.globalFrame = { x: 0, y: 0, width: 0, height: 0 });
    }
  }
  class ip {
    constructor(e) {
      (this._filterStackIndex = 0),
        (this._filterStack = []),
        (this._filterGlobalUniforms = new ys({
          uInputSize: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputPixel: { value: new Float32Array(4), type: "vec4<f32>" },
          uInputClamp: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uGlobalFrame: { value: new Float32Array(4), type: "vec4<f32>" },
          uOutputTexture: { value: new Float32Array(4), type: "vec4<f32>" },
        })),
        (this._globalFilterBindGroup = new qi({})),
        (this.renderer = e);
    }
    get activeBackTexture() {
      return this._activeFilterData?.backTexture;
    }
    push(e) {
      const t = this.renderer,
        a = e.filterEffect.filters,
        l = this._pushFilterData();
      (l.skip = !1),
        (l.filters = a),
        (l.container = e.container),
        (l.outputRenderSurface = t.renderTarget.renderSurface);
      const o = t.renderTarget.renderTarget.colorTexture.source,
        h = o.resolution,
        c = o.antialias;
      if (a.length === 0) {
        l.skip = !0;
        return;
      }
      const u = l.bounds;
      if (
        (this._calculateFilterArea(e, u),
          this._calculateFilterBounds(l, t.renderTarget.rootViewPort, c, h, 1),
          l.skip)
      )
        return;
      const d = this._getPreviousFilterData(),
        f = this._findFilterResolution(h);
      let p = 0,
        g = 0;
      d && ((p = d.bounds.minX), (g = d.bounds.minY)),
        this._calculateGlobalFrame(l, p, g, f, o.width, o.height),
        this._setupFilterTextures(l, u, t, d);
    }
    generateFilteredTexture({ texture: e, filters: t }) {
      const a = this._pushFilterData();
      (this._activeFilterData = a), (a.skip = !1), (a.filters = t);
      const l = e.source,
        o = l.resolution,
        h = l.antialias;
      if (t.length === 0) return (a.skip = !0), e;
      const c = a.bounds;
      if (
        (c.addRect(e.frame),
          this._calculateFilterBounds(a, c.rectangle, h, o, 0),
          a.skip)
      )
        return e;
      const u = o;
      this._calculateGlobalFrame(a, 0, 0, u, l.width, l.height),
        (a.outputRenderSurface = ss.getOptimalTexture(
          c.width,
          c.height,
          a.resolution,
          a.antialias
        )),
        (a.backTexture = te.EMPTY),
        (a.inputTexture = e),
        this.renderer.renderTarget.finishRenderPass(),
        this._applyFiltersToTexture(a, !0);
      const g = a.outputRenderSurface;
      return (g.source.alphaMode = "premultiplied-alpha"), g;
    }
    pop() {
      const e = this.renderer,
        t = this._popFilterData();
      t.skip ||
        (e.globalUniforms.pop(),
          e.renderTarget.finishRenderPass(),
          (this._activeFilterData = t),
          this._applyFiltersToTexture(t, !1),
          t.blendRequired && ss.returnTexture(t.backTexture),
          ss.returnTexture(t.inputTexture));
    }
    getBackTexture(e, t, a) {
      const l = e.colorTexture.source._resolution,
        o = ss.getOptimalTexture(t.width, t.height, l, !1);
      let h = t.minX,
        c = t.minY;
      a && ((h -= a.minX), (c -= a.minY)),
        (h = Math.floor(h * l)),
        (c = Math.floor(c * l));
      const u = Math.ceil(t.width * l),
        d = Math.ceil(t.height * l);
      return (
        this.renderer.renderTarget.copyToTexture(
          e,
          o,
          { x: h, y: c },
          { width: u, height: d },
          { x: 0, y: 0 }
        ),
        o
      );
    }
    applyFilter(e, t, a, l) {
      const o = this.renderer,
        h = this._activeFilterData,
        u = h.outputRenderSurface === a,
        d = o.renderTarget.rootRenderTarget.colorTexture.source._resolution,
        f = this._findFilterResolution(d);
      let p = 0,
        g = 0;
      if (u) {
        const _ = this._findPreviousFilterOffset();
        (p = _.x), (g = _.y);
      }
      this._updateFilterUniforms(t, a, h, p, g, f, u, l),
        this._setupBindGroupsAndRender(e, t, o);
    }
    calculateSpriteMatrix(e, t) {
      const a = this._activeFilterData,
        l = e.set(
          a.inputTexture._source.width,
          0,
          0,
          a.inputTexture._source.height,
          a.bounds.minX,
          a.bounds.minY
        ),
        o = t.worldTransform.copyTo(ae.shared),
        h = t.renderGroup || t.parentRenderGroup;
      return (
        h && h.cacheToLocalTransform && o.prepend(h.cacheToLocalTransform),
        o.invert(),
        l.prepend(o),
        l.scale(1 / t.texture.orig.width, 1 / t.texture.orig.height),
        l.translate(t.anchor.x, t.anchor.y),
        l
      );
    }
    destroy() { }
    _setupBindGroupsAndRender(e, t, a) {
      if (a.renderPipes.uniformBatch) {
        const l = a.renderPipes.uniformBatch.getUboResource(
          this._filterGlobalUniforms
        );
        this._globalFilterBindGroup.setResource(l, 0);
      } else
        this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
      this._globalFilterBindGroup.setResource(t.source, 1),
        this._globalFilterBindGroup.setResource(t.source.style, 2),
        (e.groups[0] = this._globalFilterBindGroup),
        a.encoder.draw({
          geometry: av,
          shader: e,
          state: e._state,
          topology: "triangle-list",
        }),
        a.type === pi.WEBGL && a.renderTarget.finishRenderPass();
    }
    _setupFilterTextures(e, t, a, l) {
      if (
        ((e.backTexture = te.EMPTY),
          (e.inputTexture = ss.getOptimalTexture(
            t.width,
            t.height,
            e.resolution,
            e.antialias
          )),
          e.blendRequired)
      ) {
        a.renderTarget.finishRenderPass();
        const o = a.renderTarget.getRenderTarget(e.outputRenderSurface);
        e.backTexture = this.getBackTexture(o, t, l?.bounds);
      }
      a.renderTarget.bind(e.inputTexture, !0),
        a.globalUniforms.push({ offset: t });
    }
    _calculateGlobalFrame(e, t, a, l, o, h) {
      const c = e.globalFrame;
      (c.x = t * l), (c.y = a * l), (c.width = o * l), (c.height = h * l);
    }
    _updateFilterUniforms(e, t, a, l, o, h, c, u) {
      const d = this._filterGlobalUniforms.uniforms,
        f = d.uOutputFrame,
        p = d.uInputSize,
        g = d.uInputPixel,
        _ = d.uInputClamp,
        m = d.uGlobalFrame,
        w = d.uOutputTexture;
      c
        ? ((f[0] = a.bounds.minX - l), (f[1] = a.bounds.minY - o))
        : ((f[0] = 0), (f[1] = 0)),
        (f[2] = e.frame.width),
        (f[3] = e.frame.height),
        (p[0] = e.source.width),
        (p[1] = e.source.height),
        (p[2] = 1 / p[0]),
        (p[3] = 1 / p[1]),
        (g[0] = e.source.pixelWidth),
        (g[1] = e.source.pixelHeight),
        (g[2] = 1 / g[0]),
        (g[3] = 1 / g[1]),
        (_[0] = 0.5 * g[2]),
        (_[1] = 0.5 * g[3]),
        (_[2] = e.frame.width * p[2] - 0.5 * g[2]),
        (_[3] = e.frame.height * p[3] - 0.5 * g[3]);
      const x = this.renderer.renderTarget.rootRenderTarget.colorTexture;
      (m[0] = l * h),
        (m[1] = o * h),
        (m[2] = x.source.width * h),
        (m[3] = x.source.height * h),
        t instanceof te && (t.source.resource = null);
      const M = this.renderer.renderTarget.getRenderTarget(t);
      this.renderer.renderTarget.bind(t, !!u),
        t instanceof te
          ? ((w[0] = t.frame.width), (w[1] = t.frame.height))
          : ((w[0] = M.width), (w[1] = M.height)),
        (w[2] = M.isRoot ? -1 : 1),
        this._filterGlobalUniforms.update();
    }
    _findFilterResolution(e) {
      let t = this._filterStackIndex - 1;
      for (; t > 0 && this._filterStack[t].skip;) --t;
      return t > 0 && this._filterStack[t].inputTexture
        ? this._filterStack[t].inputTexture.source._resolution
        : e;
    }
    _findPreviousFilterOffset() {
      let e = 0,
        t = 0,
        a = this._filterStackIndex;
      for (; a > 0;) {
        a--;
        const l = this._filterStack[a];
        if (!l.skip) {
          (e = l.bounds.minX), (t = l.bounds.minY);
          break;
        }
      }
      return { x: e, y: t };
    }
    _calculateFilterArea(e, t) {
      if (
        (e.renderables
          ? nv(e.renderables, t)
          : e.filterEffect.filterArea
            ? (t.clear(),
              t.addRect(e.filterEffect.filterArea),
              t.applyMatrix(e.container.worldTransform))
            : e.container.getFastGlobalBounds(!0, t),
          e.container)
      ) {
        const l = (e.container.renderGroup || e.container.parentRenderGroup)
          .cacheToLocalTransform;
        l && t.applyMatrix(l);
      }
    }
    _applyFiltersToTexture(e, t) {
      const a = e.inputTexture,
        l = e.bounds,
        o = e.filters;
      if (
        (this._globalFilterBindGroup.setResource(a.source.style, 2),
          this._globalFilterBindGroup.setResource(e.backTexture.source, 3),
          o.length === 1)
      )
        o[0].apply(this, a, e.outputRenderSurface, t);
      else {
        let h = e.inputTexture;
        const c = ss.getOptimalTexture(
          l.width,
          l.height,
          h.source._resolution,
          !1
        );
        let u = c,
          d = 0;
        for (d = 0; d < o.length - 1; ++d) {
          o[d].apply(this, h, u, !0);
          const p = h;
          (h = u), (u = p);
        }
        o[d].apply(this, h, e.outputRenderSurface, t), ss.returnTexture(c);
      }
    }
    _calculateFilterBounds(e, t, a, l, o) {
      const h = this.renderer,
        c = e.bounds,
        u = e.filters;
      let d = 1 / 0,
        f = 0,
        p = !0,
        g = !1,
        _ = !1,
        m = !0;
      for (let w = 0; w < u.length; w++) {
        const x = u[w];
        if (
          ((d = Math.min(d, x.resolution === "inherit" ? l : x.resolution)),
            (f += x.padding),
            x.antialias === "off"
              ? (p = !1)
              : x.antialias === "inherit" && p && (p = a),
            x.clipToViewport || (m = !1),
            !!!(x.compatibleRenderers & h.type))
        ) {
          _ = !1;
          break;
        }
        if (x.blendRequired && !(h.backBuffer?.useBackBuffer ?? !0)) {
          pe(
            "Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."
          ),
            (_ = !1);
          break;
        }
        (_ = x.enabled || _), g || (g = x.blendRequired);
      }
      if (!_) {
        e.skip = !0;
        return;
      }
      if (
        (m && c.fitBounds(0, t.width / l, 0, t.height / l),
          c
            .scale(d)
            .ceil()
            .scale(1 / d)
            .pad((f | 0) * o),
          !c.isPositive)
      ) {
        e.skip = !0;
        return;
      }
      (e.antialias = p), (e.resolution = d), (e.blendRequired = g);
    }
    _popFilterData() {
      return (
        this._filterStackIndex--, this._filterStack[this._filterStackIndex]
      );
    }
    _getPreviousFilterData() {
      let e,
        t = this._filterStackIndex - 1;
      for (; t > 0 && (t--, (e = this._filterStack[t]), !!e.skip););
      return e;
    }
    _pushFilterData() {
      let e = this._filterStack[this._filterStackIndex];
      return (
        e || (e = this._filterStack[this._filterStackIndex] = new ov()),
        this._filterStackIndex++,
        e
      );
    }
  }
  ip.extension = { type: [P.WebGLSystem, P.WebGPUSystem], name: "filter" };
  var lv = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,
    hv = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,
    rp = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};
@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
  class cv extends z0 {
    constructor(e) {
      const { sprite: t, ...a } = e,
        l = new Pd(t.texture),
        o = new ys({
          uFilterMatrix: { value: new ae(), type: "mat3x3<f32>" },
          uMaskClamp: { value: l.uClampFrame, type: "vec4<f32>" },
          uAlpha: { value: 1, type: "f32" },
          uInverse: { value: e.inverse ? 1 : 0, type: "f32" },
        }),
        h = Ir.from({
          vertex: { source: rp, entryPoint: "mainVertex" },
          fragment: { source: rp, entryPoint: "mainFragment" },
        }),
        c = tn.from({ vertex: hv, fragment: lv, name: "mask-filter" });
      super({
        ...a,
        gpuProgram: h,
        glProgram: c,
        clipToViewport: !1,
        resources: { filterUniforms: o, uMaskTexture: t.texture.source },
      }),
        (this.sprite = t),
        (this._textureMatrix = l);
    }
    set inverse(e) {
      this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0;
    }
    get inverse() {
      return this.resources.filterUniforms.uniforms.uInverse === 1;
    }
    apply(e, t, a, l) {
      (this._textureMatrix.texture = this.sprite.texture),
        e
          .calculateSpriteMatrix(
            this.resources.filterUniforms.uniforms.uFilterMatrix,
            this.sprite
          )
          .prepend(this._textureMatrix.mapCoord),
        (this.resources.uMaskTexture = this.sprite.texture.source),
        e.applyFilter(this, t, a, l);
    }
  }
  class wo extends Qa {
    constructor(e) {
      e instanceof ti && (e = { context: e });
      const { context: t, roundPixels: a, ...l } = e || {};
      super({ label: "Graphics", ...l }),
        (this.renderPipeId = "graphics"),
        t
          ? (this._context = t)
          : (this._context = this._ownedContext = new ti()),
        this._context.on("update", this.onViewUpdate, this),
        (this.didViewUpdate = !0),
        (this.allowChildren = !1),
        (this.roundPixels = a ?? !1);
    }
    set context(e) {
      e !== this._context &&
        (this._context.off("update", this.onViewUpdate, this),
          (this._context = e),
          this._context.on("update", this.onViewUpdate, this),
          this.onViewUpdate());
    }
    get context() {
      return this._context;
    }
    get bounds() {
      return this._context.bounds;
    }
    updateBounds() { }
    containsPoint(e) {
      return this._context.containsPoint(e);
    }
    destroy(e) {
      this._ownedContext && !e
        ? this._ownedContext.destroy(e)
        : (e === !0 || e?.context === !0) && this._context.destroy(e),
        (this._ownedContext = null),
        (this._context = null),
        super.destroy(e);
    }
    _callContextMethod(e, t) {
      return this.context[e](...t), this;
    }
    setFillStyle(...e) {
      return this._callContextMethod("setFillStyle", e);
    }
    setStrokeStyle(...e) {
      return this._callContextMethod("setStrokeStyle", e);
    }
    fill(...e) {
      return this._callContextMethod("fill", e);
    }
    stroke(...e) {
      return this._callContextMethod("stroke", e);
    }
    texture(...e) {
      return this._callContextMethod("texture", e);
    }
    beginPath() {
      return this._callContextMethod("beginPath", []);
    }
    cut() {
      return this._callContextMethod("cut", []);
    }
    arc(...e) {
      return this._callContextMethod("arc", e);
    }
    arcTo(...e) {
      return this._callContextMethod("arcTo", e);
    }
    arcToSvg(...e) {
      return this._callContextMethod("arcToSvg", e);
    }
    bezierCurveTo(...e) {
      return this._callContextMethod("bezierCurveTo", e);
    }
    closePath() {
      return this._callContextMethod("closePath", []);
    }
    ellipse(...e) {
      return this._callContextMethod("ellipse", e);
    }
    circle(...e) {
      return this._callContextMethod("circle", e);
    }
    path(...e) {
      return this._callContextMethod("path", e);
    }
    lineTo(...e) {
      return this._callContextMethod("lineTo", e);
    }
    moveTo(...e) {
      return this._callContextMethod("moveTo", e);
    }
    quadraticCurveTo(...e) {
      return this._callContextMethod("quadraticCurveTo", e);
    }
    rect(...e) {
      return this._callContextMethod("rect", e);
    }
    roundRect(...e) {
      return this._callContextMethod("roundRect", e);
    }
    poly(...e) {
      return this._callContextMethod("poly", e);
    }
    regularPoly(...e) {
      return this._callContextMethod("regularPoly", e);
    }
    roundPoly(...e) {
      return this._callContextMethod("roundPoly", e);
    }
    roundShape(...e) {
      return this._callContextMethod("roundShape", e);
    }
    filletRect(...e) {
      return this._callContextMethod("filletRect", e);
    }
    chamferRect(...e) {
      return this._callContextMethod("chamferRect", e);
    }
    star(...e) {
      return this._callContextMethod("star", e);
    }
    svg(...e) {
      return this._callContextMethod("svg", e);
    }
    restore(...e) {
      return this._callContextMethod("restore", e);
    }
    save() {
      return this._callContextMethod("save", []);
    }
    getTransform() {
      return this.context.getTransform();
    }
    resetTransform() {
      return this._callContextMethod("resetTransform", []);
    }
    rotateTransform(...e) {
      return this._callContextMethod("rotate", e);
    }
    scaleTransform(...e) {
      return this._callContextMethod("scale", e);
    }
    setTransform(...e) {
      return this._callContextMethod("setTransform", e);
    }
    transform(...e) {
      return this._callContextMethod("transform", e);
    }
    translateTransform(...e) {
      return this._callContextMethod("translate", e);
    }
    clear() {
      return this._callContextMethod("clear", []);
    }
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(e) {
      this._context.fillStyle = e;
    }
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(e) {
      this._context.strokeStyle = e;
    }
    clone(e = !1) {
      return e
        ? new wo(this._context.clone())
        : ((this._ownedContext = null), new wo(this._context));
    }
    lineStyle(e, t, a) {
      me(
        Ie,
        "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style."
      );
      const l = {};
      return (
        e && (l.width = e),
        t && (l.color = t),
        a && (l.alpha = a),
        (this.context.strokeStyle = l),
        this
      );
    }
    beginFill(e, t) {
      me(
        Ie,
        "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."
      );
      const a = {};
      return (
        e !== void 0 && (a.color = e),
        t !== void 0 && (a.alpha = t),
        (this.context.fillStyle = a),
        this
      );
    }
    endFill() {
      me(
        Ie,
        "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."
      ),
        this.context.fill();
      const e = this.context.strokeStyle;
      return (
        (e.width !== ti.defaultStrokeStyle.width ||
          e.color !== ti.defaultStrokeStyle.color ||
          e.alpha !== ti.defaultStrokeStyle.alpha) &&
        this.context.stroke(),
        this
      );
    }
    drawCircle(...e) {
      return (
        me(Ie, "Graphics#drawCircle has been renamed to Graphics#circle"),
        this._callContextMethod("circle", e)
      );
    }
    drawEllipse(...e) {
      return (
        me(Ie, "Graphics#drawEllipse has been renamed to Graphics#ellipse"),
        this._callContextMethod("ellipse", e)
      );
    }
    drawPolygon(...e) {
      return (
        me(Ie, "Graphics#drawPolygon has been renamed to Graphics#poly"),
        this._callContextMethod("poly", e)
      );
    }
    drawRect(...e) {
      return (
        me(Ie, "Graphics#drawRect has been renamed to Graphics#rect"),
        this._callContextMethod("rect", e)
      );
    }
    drawRoundedRect(...e) {
      return (
        me(
          Ie,
          "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"
        ),
        this._callContextMethod("roundRect", e)
      );
    }
    drawStar(...e) {
      return (
        me(Ie, "Graphics#drawStar has been renamed to Graphics#star"),
        this._callContextMethod("star", e)
      );
    }
  }
  const np = class r1 extends Yn {
    constructor(...e) {
      let t = e[0] ?? {};
      t instanceof Float32Array &&
        (me(Ie, "use new MeshGeometry({ positions, uvs, indices }) instead"),
          (t = { positions: t, uvs: e[1], indices: e[2] })),
        (t = { ...r1.defaultOptions, ...t });
      const a = t.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      let l = t.uvs;
      l ||
        (t.positions
          ? (l = new Float32Array(a.length))
          : (l = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])));
      const o = t.indices || new Uint32Array([0, 1, 2, 0, 2, 3]),
        h = t.shrinkBuffersToFit,
        c = new Hs({
          data: a,
          label: "attribute-mesh-positions",
          shrinkToFit: h,
          usage: Fe.VERTEX | Fe.COPY_DST,
        }),
        u = new Hs({
          data: l,
          label: "attribute-mesh-uvs",
          shrinkToFit: h,
          usage: Fe.VERTEX | Fe.COPY_DST,
        }),
        d = new Hs({
          data: o,
          label: "index-mesh-buffer",
          shrinkToFit: h,
          usage: Fe.INDEX | Fe.COPY_DST,
        });
      super({
        attributes: {
          aPosition: { buffer: c, format: "float32x2", stride: 8, offset: 0 },
          aUV: { buffer: u, format: "float32x2", stride: 8, offset: 0 },
        },
        indexBuffer: d,
        topology: t.topology,
      }),
        (this.batchMode = "auto");
    }
    get positions() {
      return this.attributes.aPosition.buffer.data;
    }
    set positions(e) {
      this.attributes.aPosition.buffer.data = e;
    }
    get uvs() {
      return this.attributes.aUV.buffer.data;
    }
    set uvs(e) {
      this.attributes.aUV.buffer.data = e;
    }
    get indices() {
      return this.indexBuffer.data;
    }
    set indices(e) {
      this.indexBuffer.data = e;
    }
  };
  np.defaultOptions = { topology: "triangle-list", shrinkBuffersToFit: !1 };
  let $h = np;
  class dv {
    constructor({ matrix: e, observer: t } = {}) {
      (this.dirty = !0),
        (this._matrix = e ?? new ae()),
        (this.observer = t),
        (this.position = new Tt(this, 0, 0)),
        (this.scale = new Tt(this, 1, 1)),
        (this.pivot = new Tt(this, 0, 0)),
        (this.skew = new Tt(this, 0, 0)),
        (this._rotation = 0),
        (this._cx = 1),
        (this._sx = 0),
        (this._cy = 0),
        (this._sy = 1);
    }
    get matrix() {
      const e = this._matrix;
      return (
        this.dirty &&
        ((e.a = this._cx * this.scale.x),
          (e.b = this._sx * this.scale.x),
          (e.c = this._cy * this.scale.y),
          (e.d = this._sy * this.scale.y),
          (e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c)),
          (e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d)),
          (this.dirty = !1)),
        e
      );
    }
    _onUpdate(e) {
      (this.dirty = !0),
        e === this.skew && this.updateSkew(),
        this.observer?._onUpdate(this);
    }
    updateSkew() {
      (this._cx = Math.cos(this._rotation + this.skew.y)),
        (this._sx = Math.sin(this._rotation + this.skew.y)),
        (this._cy = -Math.sin(this._rotation - this.skew.x)),
        (this._sy = Math.cos(this._rotation - this.skew.x)),
        (this.dirty = !0);
    }
    toString() {
      return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
    }
    setFromMatrix(e) {
      e.decompose(this), (this.dirty = !0);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(e) {
      this._rotation !== e && ((this._rotation = e), this._onUpdate(this.skew));
    }
  }
  const ap = class Ml extends Qa {
    constructor(...e) {
      let t = e[0] || {};
      t instanceof te && (t = { texture: t }),
        e.length > 1 &&
        (me(
          Ie,
          "use new TilingSprite({ texture, width:100, height:100 }) instead"
        ),
          (t.width = e[1]),
          (t.height = e[2])),
        (t = { ...Ml.defaultOptions, ...t });
      const {
        texture: a,
        anchor: l,
        tilePosition: o,
        tileScale: h,
        tileRotation: c,
        width: u,
        height: d,
        applyAnchorToTexture: f,
        roundPixels: p,
        ...g
      } = t ?? {};
      super({ label: "TilingSprite", ...g }),
        (this.renderPipeId = "tilingSprite"),
        (this.batched = !0),
        (this.allowChildren = !1),
        (this._anchor = new Tt({
          _onUpdate: () => {
            this.onViewUpdate();
          },
        })),
        (this.applyAnchorToTexture = f),
        (this.texture = a),
        (this._width = u ?? a.width),
        (this._height = d ?? a.height),
        (this._tileTransform = new dv({
          observer: { _onUpdate: () => this.onViewUpdate() },
        })),
        l && (this.anchor = l),
        (this.tilePosition = o),
        (this.tileScale = h),
        (this.tileRotation = c),
        (this.roundPixels = p ?? !1);
    }
    static from(e, t = {}) {
      return typeof e == "string"
        ? new Ml({ texture: We.get(e), ...t })
        : new Ml({ texture: e, ...t });
    }
    get uvRespectAnchor() {
      return (
        me(
          Ie,
          "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"
        ),
        this.applyAnchorToTexture
      );
    }
    set uvRespectAnchor(e) {
      me(
        Ie,
        "uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"
      ),
        (this.applyAnchorToTexture = e);
    }
    get clampMargin() {
      return this._texture.textureMatrix.clampMargin;
    }
    set clampMargin(e) {
      this._texture.textureMatrix.clampMargin = e;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    get tilePosition() {
      return this._tileTransform.position;
    }
    set tilePosition(e) {
      this._tileTransform.position.copyFrom(e);
    }
    get tileScale() {
      return this._tileTransform.scale;
    }
    set tileScale(e) {
      typeof e == "number"
        ? this._tileTransform.scale.set(e)
        : this._tileTransform.scale.copyFrom(e);
    }
    set tileRotation(e) {
      this._tileTransform.rotation = e;
    }
    get tileRotation() {
      return this._tileTransform.rotation;
    }
    get tileTransform() {
      return this._tileTransform;
    }
    set texture(e) {
      e || (e = te.EMPTY);
      const t = this._texture;
      t !== e &&
        (t && t.dynamic && t.off("update", this.onViewUpdate, this),
          e.dynamic && e.on("update", this.onViewUpdate, this),
          (this._texture = e),
          this.onViewUpdate());
    }
    get texture() {
      return this._texture;
    }
    set width(e) {
      (this._width = e), this.onViewUpdate();
    }
    get width() {
      return this._width;
    }
    set height(e) {
      (this._height = e), this.onViewUpdate();
    }
    get height() {
      return this._height;
    }
    setSize(e, t) {
      typeof e == "object" && ((t = e.height ?? e.width), (e = e.width)),
        (this._width = e),
        (this._height = t ?? e),
        this.onViewUpdate();
    }
    getSize(e) {
      return (
        e || (e = {}), (e.width = this._width), (e.height = this._height), e
      );
    }
    updateBounds() {
      const e = this._bounds,
        t = this._anchor,
        a = this._width,
        l = this._height;
      (e.minX = -t._x * a),
        (e.maxX = e.minX + a),
        (e.minY = -t._y * l),
        (e.maxY = e.minY + l);
    }
    containsPoint(e) {
      const t = this._width,
        a = this._height,
        l = -t * this._anchor._x;
      let o = 0;
      return (
        e.x >= l &&
        e.x <= l + t &&
        ((o = -a * this._anchor._y), e.y >= o && e.y <= o + a)
      );
    }
    destroy(e = !1) {
      if (
        (super.destroy(e),
          (this._anchor = null),
          (this._tileTransform = null),
          (this._bounds = null),
          typeof e == "boolean" ? e : e?.texture)
      ) {
        const a = typeof e == "boolean" ? e : e?.textureSource;
        this._texture.destroy(a);
      }
      this._texture = null;
    }
  };
  ap.defaultOptions = {
    texture: te.EMPTY,
    anchor: { x: 0, y: 0 },
    tilePosition: { x: 0, y: 0 },
    tileScale: { x: 1, y: 1 },
    tileRotation: 0,
    applyAnchorToTexture: !1,
  };
  let uv = ap;
  class fv extends Qa {
    constructor(e, t) {
      const {
        text: a,
        resolution: l,
        style: o,
        anchor: h,
        width: c,
        height: u,
        roundPixels: d,
        ...f
      } = e;
      super({ ...f }),
        (this.batched = !0),
        (this._resolution = null),
        (this._autoResolution = !0),
        (this._didTextUpdate = !0),
        (this._styleClass = t),
        (this.text = a ?? ""),
        (this.style = o),
        (this.resolution = l ?? null),
        (this.allowChildren = !1),
        (this._anchor = new Tt({
          _onUpdate: () => {
            this.onViewUpdate();
          },
        })),
        h && (this.anchor = h),
        (this.roundPixels = d ?? !1),
        c !== void 0 && (this.width = c),
        u !== void 0 && (this.height = u);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(e) {
      typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
    }
    set text(e) {
      (e = e.toString()),
        this._text !== e && ((this._text = e), this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(e) {
      (this._autoResolution = e === null),
        (this._resolution = e),
        this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(e) {
      e || (e = {}),
        this._style?.off("update", this.onViewUpdate, this),
        e instanceof this._styleClass
          ? (this._style = e)
          : (this._style = new this._styleClass(e)),
        this._style.on("update", this.onViewUpdate, this),
        this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(e) {
      this._setWidth(e, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(e) {
      this._setHeight(e, this.bounds.height);
    }
    getSize(e) {
      return (
        e || (e = {}),
        (e.width = Math.abs(this.scale.x) * this.bounds.width),
        (e.height = Math.abs(this.scale.y) * this.bounds.height),
        e
      );
    }
    setSize(e, t) {
      typeof e == "object"
        ? ((t = e.height ?? e.width), (e = e.width))
        : t ?? (t = e),
        e !== void 0 && this._setWidth(e, this.bounds.width),
        t !== void 0 && this._setHeight(t, this.bounds.height);
    }
    containsPoint(e) {
      const t = this.bounds.width,
        a = this.bounds.height,
        l = -t * this.anchor.x;
      let o = 0;
      return (
        e.x >= l &&
        e.x <= l + t &&
        ((o = -a * this.anchor.y), e.y >= o && e.y <= o + a)
      );
    }
    onViewUpdate() {
      this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
    }
    destroy(e = !1) {
      super.destroy(e),
        (this.owner = null),
        (this._bounds = null),
        (this._anchor = null),
        (typeof e == "boolean" ? e : e?.style) && this._style.destroy(e),
        (this._style = null),
        (this._text = null);
    }
    get styleKey() {
      return `${this._text}:${this._style.styleKey}:${this._resolution}`;
    }
  }
  function pv(r, e) {
    let t = r[0] ?? {};
    return (
      (typeof t == "string" || r[1]) &&
      (me(Ie, `use new ${e}({ text: "hi!", style }) instead`),
        (t = { text: t, style: r[1] })),
      t
    );
  }
  let Or = null,
    Qi = null;
  function gv(r, e) {
    Or ||
      ((Or = xe.get().createCanvas(256, 128)),
        (Qi = Or.getContext("2d", { willReadFrequently: !0 })),
        (Qi.globalCompositeOperation = "copy"),
        (Qi.globalAlpha = 1)),
      (Or.width < r || Or.height < e) &&
      ((Or.width = $r(r)), (Or.height = $r(e)));
  }
  function op(r, e, t) {
    for (let a = 0, l = 4 * t * e; a < e; ++a, l += 4)
      if (r[l + 3] !== 0) return !1;
    return !0;
  }
  function lp(r, e, t, a, l) {
    const o = 4 * e;
    for (let h = a, c = a * o + 4 * t; h <= l; ++h, c += o)
      if (r[c + 3] !== 0) return !1;
    return !0;
  }
  function mv(...r) {
    let e = r[0];
    e.canvas || (e = { canvas: r[0], resolution: r[1] });
    const { canvas: t } = e,
      a = Math.min(e.resolution ?? 1, 1),
      l = e.width ?? t.width,
      o = e.height ?? t.height;
    let h = e.output;
    if ((gv(l, o), !Qi)) throw new TypeError("Failed to get canvas 2D context");
    Qi.drawImage(t, 0, 0, l, o, 0, 0, l * a, o * a);
    const u = Qi.getImageData(0, 0, l, o).data;
    let d = 0,
      f = 0,
      p = l - 1,
      g = o - 1;
    for (; f < o && op(u, l, f);) ++f;
    if (f === o) return Le.EMPTY;
    for (; op(u, l, g);) --g;
    for (; lp(u, l, d, f, g);) ++d;
    for (; lp(u, l, p, f, g);) --p;
    return (
      ++p,
      ++g,
      (Qi.globalCompositeOperation = "source-over"),
      Qi.strokeRect(d, f, p - d, g - f),
      (Qi.globalCompositeOperation = "copy"),
      h ?? (h = new Le()),
      h.set(d / a, f / a, (p - d) / a, (g - f) / a),
      h
    );
  }
  const hp = new Le();
  class _v {
    getCanvasAndContext(e) {
      const { text: t, style: a, resolution: l = 1 } = e,
        o = a._getFinalPadding(),
        h = _i.measureText(t || " ", a),
        c = Math.ceil(Math.ceil(Math.max(1, h.width) + o * 2) * l),
        u = Math.ceil(Math.ceil(Math.max(1, h.height) + o * 2) * l),
        d = Ki.getOptimalCanvasAndContext(c, u);
      this._renderTextToCanvas(t, a, o, l, d);
      const f = a.trim
        ? mv({
          canvas: d.canvas,
          width: c,
          height: u,
          resolution: 1,
          output: hp,
        })
        : hp.set(0, 0, c, u);
      return { canvasAndContext: d, frame: f };
    }
    returnCanvasAndContext(e) {
      Ki.returnCanvasAndContext(e);
    }
    _renderTextToCanvas(e, t, a, l, o) {
      const { canvas: h, context: c } = o,
        u = co(t),
        d = _i.measureText(e || " ", t),
        f = d.lines,
        p = d.lineHeight,
        g = d.lineWidths,
        _ = d.maxLineWidth,
        m = d.fontProperties,
        w = h.height;
      if (
        (c.resetTransform(),
          c.scale(l, l),
          (c.textBaseline = t.textBaseline),
          t._stroke?.width)
      ) {
        const T = t._stroke;
        (c.lineWidth = T.width),
          (c.miterLimit = T.miterLimit),
          (c.lineJoin = T.join),
          (c.lineCap = T.cap);
      }
      c.font = u;
      let x, M;
      const b = t.dropShadow ? 2 : 1;
      for (let T = 0; T < b; ++T) {
        const C = t.dropShadow && T === 0,
          A = C ? Math.ceil(Math.max(1, w) + a * 2) : 0,
          R = A * l;
        if (C) {
          (c.fillStyle = "black"), (c.strokeStyle = "black");
          const D = t.dropShadow,
            I = D.color,
            y = D.alpha;
          c.shadowColor = mt.shared.setValue(I).setAlpha(y).toRgbaString();
          const Z = D.blur * l,
            V = D.distance * l;
          (c.shadowBlur = Z),
            (c.shadowOffsetX = Math.cos(D.angle) * V),
            (c.shadowOffsetY = Math.sin(D.angle) * V + R);
        } else {
          if (
            ((c.fillStyle = t._fill ? yo(t._fill, c, d, a * 2) : null),
              t._stroke?.width)
          ) {
            const D = t._stroke.width * 0.5 + a * 2;
            c.strokeStyle = yo(t._stroke, c, d, D);
          }
          c.shadowColor = "black";
        }
        let k = (p - m.fontSize) / 2;
        p - m.fontSize < 0 && (k = 0);
        const W = t._stroke?.width ?? 0;
        for (let D = 0; D < f.length; D++)
          (x = W / 2),
            (M = W / 2 + D * p + m.ascent + k),
            t.align === "right"
              ? (x += _ - g[D])
              : t.align === "center" && (x += (_ - g[D]) / 2),
            t._stroke?.width &&
            this._drawLetterSpacing(f[D], t, o, x + a, M + a - A, !0),
            t._fill !== void 0 &&
            this._drawLetterSpacing(f[D], t, o, x + a, M + a - A);
      }
    }
    _drawLetterSpacing(e, t, a, l, o, h = !1) {
      const { context: c } = a,
        u = t.letterSpacing;
      let d = !1;
      if (
        (_i.experimentalLetterSpacingSupported &&
          (_i.experimentalLetterSpacing
            ? ((c.letterSpacing = `${u}px`),
              (c.textLetterSpacing = `${u}px`),
              (d = !0))
            : ((c.letterSpacing = "0px"), (c.textLetterSpacing = "0px"))),
          u === 0 || d)
      ) {
        h ? c.strokeText(e, l, o) : c.fillText(e, l, o);
        return;
      }
      let f = l;
      const p = _i.graphemeSegmenter(e);
      let g = c.measureText(e).width,
        _ = 0;
      for (let m = 0; m < p.length; ++m) {
        const w = p[m];
        h ? c.strokeText(w, f, o) : c.fillText(w, f, o);
        let x = "";
        for (let M = m + 1; M < p.length; ++M) x += p[M];
        (_ = c.measureText(x).width), (f += g - _ + u), (g = _);
      }
    }
  }
  const ia = new _v();
  class yv extends fv {
    constructor(...e) {
      const t = pv(e, "Text");
      super(t, Dr),
        (this.renderPipeId = "text"),
        t.textureStyle &&
        (this.textureStyle =
          t.textureStyle instanceof Pi
            ? t.textureStyle
            : new Pi(t.textureStyle));
    }
    updateBounds() {
      const e = this._bounds,
        t = this._anchor;
      let a = 0,
        l = 0;
      if (this._style.trim) {
        const { frame: o, canvasAndContext: h } = ia.getCanvasAndContext({
          text: this.text,
          style: this._style,
          resolution: 1,
        });
        ia.returnCanvasAndContext(h), (a = o.width), (l = o.height);
      } else {
        const o = _i.measureText(this._text, this._style);
        (a = o.width), (l = o.height);
      }
      (e.minX = -t._x * a),
        (e.maxX = e.minX + a),
        (e.minY = -t._y * l),
        (e.maxY = e.minY + l);
    }
  }
  const cp = "http://www.w3.org/2000/svg",
    dp = "http://www.w3.org/1999/xhtml";
  class up {
    constructor() {
      (this.svgRoot = document.createElementNS(cp, "svg")),
        (this.foreignObject = document.createElementNS(cp, "foreignObject")),
        (this.domElement = document.createElementNS(dp, "div")),
        (this.styleElement = document.createElementNS(dp, "style"));
      const {
        foreignObject: e,
        svgRoot: t,
        styleElement: a,
        domElement: l,
      } = this;
      e.setAttribute("width", "10000"),
        e.setAttribute("height", "10000"),
        (e.style.overflow = "hidden"),
        t.appendChild(e),
        e.appendChild(a),
        e.appendChild(l),
        (this.image = xe.get().createImage());
    }
    destroy() {
      this.svgRoot.remove(),
        this.foreignObject.remove(),
        this.styleElement.remove(),
        this.domElement.remove(),
        (this.image.src = ""),
        this.image.remove(),
        (this.svgRoot = null),
        (this.foreignObject = null),
        (this.styleElement = null),
        (this.domElement = null),
        (this.image = null),
        (this.canvasAndContext = null);
    }
  }
  let fp;
  function xv(r, e, t, a) {
    a || (a = fp || (fp = new up()));
    const { domElement: l, styleElement: o, svgRoot: h } = a;
    (l.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${r}</div>`),
      l.setAttribute(
        "style",
        "transform-origin: top left; display: inline-block"
      ),
      t && (o.textContent = t),
      document.body.appendChild(h);
    const c = l.getBoundingClientRect();
    h.remove();
    const u = e.padding * 2;
    return { width: c.width - u, height: c.height - u };
  }
  class pp {
    constructor() {
      (this._tempState = gi.for2d()), (this._didUploadHash = {});
    }
    init(e) {
      e.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._didUploadHash = {};
    }
    start(e, t, a) {
      const l = e.renderer,
        o = this._didUploadHash[a.uid];
      l.shader.bind(a, o),
        o || (this._didUploadHash[a.uid] = !0),
        l.shader.updateUniformGroup(l.globalUniforms.uniformGroup),
        l.geometry.bind(t, a.glProgram);
    }
    execute(e, t) {
      const a = e.renderer;
      (this._tempState.blendMode = t.blendMode), a.state.set(this._tempState);
      const l = t.textures.textures;
      for (let o = 0; o < t.textures.count; o++) a.texture.bind(l[o], o);
      a.geometry.draw(t.topology, t.size, t.start);
    }
  }
  pp.extension = { type: [P.WebGLPipesAdaptor], name: "batch" };
  const So = gi.for2d();
  class gp {
    start(e, t, a) {
      const l = e.renderer,
        o = l.encoder,
        h = a.gpuProgram;
      (this._shader = a),
        (this._geometry = t),
        o.setGeometry(t, h),
        (So.blendMode = "normal"),
        l.pipeline.getPipeline(t, h, So);
      const c = l.globalUniforms.bindGroup;
      o.resetBindGroup(1), o.setBindGroup(0, c, h);
    }
    execute(e, t) {
      const a = this._shader.gpuProgram,
        l = e.renderer,
        o = l.encoder;
      if (!t.bindGroup) {
        const u = t.textures;
        t.bindGroup = xh(u.textures, u.count, l.limits.maxBatchableTextures);
      }
      So.blendMode = t.blendMode;
      const h = l.bindGroup.getBindGroup(t.bindGroup, a, 1),
        c = l.pipeline.getPipeline(this._geometry, a, So, t.topology);
      t.bindGroup._touch(l.textureGC.count),
        o.setPipeline(c),
        o.renderPassEncoder.setBindGroup(1, h),
        o.renderPassEncoder.drawIndexed(t.size, 1, t.start);
    }
  }
  gp.extension = { type: [P.WebGPUPipesAdaptor], name: "batch" };
  const Kh = class n1 {
    constructor(e, t) {
      (this.state = gi.for2d()),
        (this._batchersByInstructionSet = Object.create(null)),
        (this._activeBatches = Object.create(null)),
        (this.renderer = e),
        (this._adaptor = t),
        this._adaptor.init?.(this);
    }
    static getBatcher(e) {
      return new this._availableBatchers[e]();
    }
    buildStart(e) {
      let t = this._batchersByInstructionSet[e.uid];
      t ||
        ((t = this._batchersByInstructionSet[e.uid] = Object.create(null)),
          t.default ||
          (t.default = new kh({
            maxTextures: this.renderer.limits.maxBatchableTextures,
          }))),
        (this._activeBatches = t),
        (this._activeBatch = this._activeBatches.default);
      for (const a in this._activeBatches) this._activeBatches[a].begin();
    }
    addToBatch(e, t) {
      if (this._activeBatch.name !== e.batcherName) {
        this._activeBatch.break(t);
        let a = this._activeBatches[e.batcherName];
        a ||
          ((a = this._activeBatches[e.batcherName] =
            n1.getBatcher(e.batcherName)),
            a.begin()),
          (this._activeBatch = a);
      }
      this._activeBatch.add(e);
    }
    break(e) {
      this._activeBatch.break(e);
    }
    buildEnd(e) {
      this._activeBatch.break(e);
      const t = this._activeBatches;
      for (const a in t) {
        const l = t[a],
          o = l.geometry;
        o.indexBuffer.setDataWithSize(l.indexBuffer, l.indexSize, !0),
          o.buffers[0].setDataWithSize(
            l.attributeBuffer.float32View,
            l.attributeSize,
            !1
          );
      }
    }
    upload(e) {
      const t = this._batchersByInstructionSet[e.uid];
      for (const a in t) {
        const l = t[a],
          o = l.geometry;
        l.dirty && ((l.dirty = !1), o.buffers[0].update(l.attributeSize * 4));
      }
    }
    execute(e) {
      if (e.action === "startBatch") {
        const t = e.batcher,
          a = t.geometry,
          l = t.shader;
        this._adaptor.start(this, a, l);
      }
      this._adaptor.execute(this, e);
    }
    destroy() {
      (this.state = null), (this.renderer = null), (this._adaptor = null);
      for (const e in this._activeBatches) this._activeBatches[e].destroy();
      this._activeBatches = null;
    }
  };
  (Kh.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "batch",
  }),
    (Kh._availableBatchers = Object.create(null));
  let mp = Kh;
  ge.handleByMap(P.Batcher, mp._availableBatchers), ge.add(kh);
  const ra = {
    name: "local-uniform-bit",
    vertex: {
      header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
    },
  },
    vv = {
      ...ra,
      vertex: {
        ...ra.vertex,
        header: ra.vertex.header.replace("group(1)", "group(2)"),
      },
    },
    Zh = {
      name: "local-uniform-bit",
      vertex: {
        header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
        main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
        end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
      },
    },
    bv = {
      name: "texture-bit",
      vertex: {
        header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
        main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
      },
      fragment: {
        header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
        main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `,
      },
    },
    wv = {
      name: "texture-bit",
      vertex: {
        header: `
            uniform mat3 uTextureMatrix;
        `,
        main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `,
      },
      fragment: {
        header: `
        uniform sampler2D uTexture;


        `,
        main: `
            outColor = texture(uTexture, vUV);
        `,
      },
    },
    Sv = new cs();
  class Mv extends Xa {
    constructor() {
      super(),
        (this.filters = [
          new cv({
            sprite: new Ke(te.EMPTY),
            inverse: !1,
            resolution: "inherit",
            antialias: "inherit",
          }),
        ]);
    }
    get sprite() {
      return this.filters[0].sprite;
    }
    set sprite(e) {
      this.filters[0].sprite = e;
    }
    get inverse() {
      return this.filters[0].inverse;
    }
    set inverse(e) {
      this.filters[0].inverse = e;
    }
  }
  class _p {
    constructor(e) {
      (this._activeMaskStage = []), (this._renderer = e);
    }
    push(e, t, a) {
      const l = this._renderer;
      if (
        (l.renderPipes.batch.break(a),
          a.add({
            renderPipeId: "alphaMask",
            action: "pushMaskBegin",
            mask: e,
            inverse: t._maskOptions.inverse,
            canBundle: !1,
            maskedContainer: t,
          }),
          (e.inverse = t._maskOptions.inverse),
          e.renderMaskToTexture)
      ) {
        const o = e.mask;
        (o.includeInBuild = !0),
          o.collectRenderables(a, l, null),
          (o.includeInBuild = !1);
      }
      l.renderPipes.batch.break(a),
        a.add({
          renderPipeId: "alphaMask",
          action: "pushMaskEnd",
          mask: e,
          maskedContainer: t,
          inverse: t._maskOptions.inverse,
          canBundle: !1,
        });
    }
    pop(e, t, a) {
      this._renderer.renderPipes.batch.break(a),
        a.add({
          renderPipeId: "alphaMask",
          action: "popMaskEnd",
          mask: e,
          inverse: t._maskOptions.inverse,
          canBundle: !1,
        });
    }
    execute(e) {
      const t = this._renderer,
        a = e.mask.renderMaskToTexture;
      if (e.action === "pushMaskBegin") {
        const l = Ot.get(Mv);
        if (((l.inverse = e.inverse), a)) {
          e.mask.mask.measurable = !0;
          const o = Ol(e.mask.mask, !0, Sv);
          (e.mask.mask.measurable = !1), o.ceil();
          const h = t.renderTarget.renderTarget.colorTexture.source,
            c = ss.getOptimalTexture(
              o.width,
              o.height,
              h._resolution,
              h.antialias
            );
          t.renderTarget.push(c, !0),
            t.globalUniforms.push({ offset: o, worldColor: 4294967295 });
          const u = l.sprite;
          (u.texture = c),
            (u.worldTransform.tx = o.minX),
            (u.worldTransform.ty = o.minY),
            this._activeMaskStage.push({
              filterEffect: l,
              maskedContainer: e.maskedContainer,
              filterTexture: c,
            });
        } else
          (l.sprite = e.mask.mask),
            this._activeMaskStage.push({
              filterEffect: l,
              maskedContainer: e.maskedContainer,
            });
      } else if (e.action === "pushMaskEnd") {
        const l = this._activeMaskStage[this._activeMaskStage.length - 1];
        a &&
          (t.type === pi.WEBGL && t.renderTarget.finishRenderPass(),
            t.renderTarget.pop(),
            t.globalUniforms.pop()),
          t.filter.push({
            renderPipeId: "filter",
            action: "pushFilter",
            container: l.maskedContainer,
            filterEffect: l.filterEffect,
            canBundle: !1,
          });
      } else if (e.action === "popMaskEnd") {
        t.filter.pop();
        const l = this._activeMaskStage.pop();
        a && ss.returnTexture(l.filterTexture), Ot.return(l.filterEffect);
      }
    }
    destroy() {
      (this._renderer = null), (this._activeMaskStage = null);
    }
  }
  _p.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "alphaMask",
  };
  class yp {
    constructor(e) {
      (this._colorStack = []),
        (this._colorStackIndex = 0),
        (this._currentColor = 0),
        (this._renderer = e);
    }
    buildStart() {
      (this._colorStack[0] = 15),
        (this._colorStackIndex = 1),
        (this._currentColor = 15);
    }
    push(e, t, a) {
      this._renderer.renderPipes.batch.break(a);
      const o = this._colorStack;
      o[this._colorStackIndex] = o[this._colorStackIndex - 1] & e.mask;
      const h = this._colorStack[this._colorStackIndex];
      h !== this._currentColor &&
        ((this._currentColor = h),
          a.add({ renderPipeId: "colorMask", colorMask: h, canBundle: !1 })),
        this._colorStackIndex++;
    }
    pop(e, t, a) {
      this._renderer.renderPipes.batch.break(a);
      const o = this._colorStack;
      this._colorStackIndex--;
      const h = o[this._colorStackIndex - 1];
      h !== this._currentColor &&
        ((this._currentColor = h),
          a.add({ renderPipeId: "colorMask", colorMask: h, canBundle: !1 }));
    }
    execute(e) {
      this._renderer.colorMask.setMask(e.colorMask);
    }
    destroy() {
      (this._renderer = null), (this._colorStack = null);
    }
  }
  yp.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "colorMask",
  };
  class xp {
    constructor(e) {
      (this._maskStackHash = {}),
        (this._maskHash = new WeakMap()),
        (this._renderer = e);
    }
    push(e, t, a) {
      var l;
      const o = e,
        h = this._renderer;
      h.renderPipes.batch.break(a),
        h.renderPipes.blendMode.setBlendMode(o.mask, "none", a),
        a.add({
          renderPipeId: "stencilMask",
          action: "pushMaskBegin",
          mask: e,
          inverse: t._maskOptions.inverse,
          canBundle: !1,
        });
      const c = o.mask;
      (c.includeInBuild = !0),
        this._maskHash.has(o) ||
        this._maskHash.set(o, {
          instructionsStart: 0,
          instructionsLength: 0,
        });
      const u = this._maskHash.get(o);
      (u.instructionsStart = a.instructionSize),
        c.collectRenderables(a, h, null),
        (c.includeInBuild = !1),
        h.renderPipes.batch.break(a),
        a.add({
          renderPipeId: "stencilMask",
          action: "pushMaskEnd",
          mask: e,
          inverse: t._maskOptions.inverse,
          canBundle: !1,
        });
      const d = a.instructionSize - u.instructionsStart - 1;
      u.instructionsLength = d;
      const f = h.renderTarget.renderTarget.uid;
      (l = this._maskStackHash)[f] ?? (l[f] = 0);
    }
    pop(e, t, a) {
      const l = e,
        o = this._renderer;
      o.renderPipes.batch.break(a),
        o.renderPipes.blendMode.setBlendMode(l.mask, "none", a),
        a.add({
          renderPipeId: "stencilMask",
          action: "popMaskBegin",
          inverse: t._maskOptions.inverse,
          canBundle: !1,
        });
      const h = this._maskHash.get(e);
      for (let c = 0; c < h.instructionsLength; c++)
        a.instructions[a.instructionSize++] =
          a.instructions[h.instructionsStart++];
      a.add({
        renderPipeId: "stencilMask",
        action: "popMaskEnd",
        canBundle: !1,
      });
    }
    execute(e) {
      var t;
      const a = this._renderer,
        l = a.renderTarget.renderTarget.uid;
      let o = (t = this._maskStackHash)[l] ?? (t[l] = 0);
      e.action === "pushMaskBegin"
        ? (a.renderTarget.ensureDepthStencil(),
          a.stencil.setStencilMode(Ft.RENDERING_MASK_ADD, o),
          o++,
          a.colorMask.setMask(0))
        : e.action === "pushMaskEnd"
          ? (e.inverse
            ? a.stencil.setStencilMode(Ft.INVERSE_MASK_ACTIVE, o)
            : a.stencil.setStencilMode(Ft.MASK_ACTIVE, o),
            a.colorMask.setMask(15))
          : e.action === "popMaskBegin"
            ? (a.colorMask.setMask(0),
              o !== 0
                ? a.stencil.setStencilMode(Ft.RENDERING_MASK_REMOVE, o)
                : (a.renderTarget.clear(null, Ns.STENCIL),
                  a.stencil.setStencilMode(Ft.DISABLED, o)),
              o--)
            : e.action === "popMaskEnd" &&
            (e.inverse
              ? a.stencil.setStencilMode(Ft.INVERSE_MASK_ACTIVE, o)
              : a.stencil.setStencilMode(Ft.MASK_ACTIVE, o),
              a.colorMask.setMask(15)),
        (this._maskStackHash[l] = o);
    }
    destroy() {
      (this._renderer = null),
        (this._maskStackHash = null),
        (this._maskHash = null);
    }
  }
  xp.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "stencilMask",
  };
  var Mo = ((r) => (
    (r[(r.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
    (r[(r.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
    (r[(r.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER"),
    r
  ))(Mo || {});
  class Tv {
    constructor(e, t) {
      (this._lastBindBaseLocation = -1),
        (this._lastBindCallId = -1),
        (this.buffer = e || null),
        (this.updateID = -1),
        (this.byteLength = -1),
        (this.type = t);
    }
  }
  class vp {
    constructor(e) {
      (this._gpuBuffers = Object.create(null)),
        (this._boundBufferBases = Object.create(null)),
        (this._minBaseLocation = 0),
        (this._nextBindBaseIndex = this._minBaseLocation),
        (this._bindCallId = 0),
        (this._renderer = e),
        this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
    }
    destroy() {
      (this._renderer = null),
        (this._gl = null),
        (this._gpuBuffers = null),
        (this._boundBufferBases = null);
    }
    contextChange() {
      (this._gl = this._renderer.gl),
        (this._gpuBuffers = Object.create(null)),
        (this._maxBindings = this._renderer.limits.maxUniformBindings);
    }
    getGlBuffer(e) {
      return this._gpuBuffers[e.uid] || this.createGLBuffer(e);
    }
    bind(e) {
      const { _gl: t } = this,
        a = this.getGlBuffer(e);
      t.bindBuffer(a.type, a.buffer);
    }
    bindBufferBase(e, t) {
      const { _gl: a } = this;
      this._boundBufferBases[t] !== e &&
        ((this._boundBufferBases[t] = e),
          (e._lastBindBaseLocation = t),
          a.bindBufferBase(a.UNIFORM_BUFFER, t, e.buffer));
    }
    nextBindBase(e) {
      this._bindCallId++,
        (this._minBaseLocation = 0),
        e &&
        ((this._boundBufferBases[0] = null),
          (this._minBaseLocation = 1),
          this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1));
    }
    freeLocationForBufferBase(e) {
      let t = this.getLastBindBaseLocation(e);
      if (t >= this._minBaseLocation)
        return (e._lastBindCallId = this._bindCallId), t;
      let a = 0,
        l = this._nextBindBaseIndex;
      for (; a < 2;) {
        l >= this._maxBindings && ((l = this._minBaseLocation), a++);
        const o = this._boundBufferBases[l];
        if (o && o._lastBindCallId === this._bindCallId) {
          l++;
          continue;
        }
        break;
      }
      return (
        (t = l),
        (this._nextBindBaseIndex = l + 1),
        a >= 2
          ? -1
          : ((e._lastBindCallId = this._bindCallId),
            (this._boundBufferBases[t] = null),
            t)
      );
    }
    getLastBindBaseLocation(e) {
      const t = e._lastBindBaseLocation;
      return this._boundBufferBases[t] === e ? t : -1;
    }
    bindBufferRange(e, t, a, l) {
      const { _gl: o } = this;
      a || (a = 0),
        t || (t = 0),
        (this._boundBufferBases[t] = null),
        o.bindBufferRange(
          o.UNIFORM_BUFFER,
          t || 0,
          e.buffer,
          a * 256,
          l || 256
        );
    }
    updateBuffer(e) {
      const { _gl: t } = this,
        a = this.getGlBuffer(e);
      if (e._updateID === a.updateID) return a;
      (a.updateID = e._updateID), t.bindBuffer(a.type, a.buffer);
      const l = e.data,
        o = e.descriptor.usage & Fe.STATIC ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
      return (
        l
          ? a.byteLength >= l.byteLength
            ? t.bufferSubData(
              a.type,
              0,
              l,
              0,
              e._updateSize / l.BYTES_PER_ELEMENT
            )
            : ((a.byteLength = l.byteLength), t.bufferData(a.type, l, o))
          : ((a.byteLength = e.descriptor.size),
            t.bufferData(a.type, a.byteLength, o)),
        a
      );
    }
    destroyAll() {
      const e = this._gl;
      for (const t in this._gpuBuffers)
        e.deleteBuffer(this._gpuBuffers[t].buffer);
      this._gpuBuffers = Object.create(null);
    }
    onBufferDestroy(e, t) {
      const a = this._gpuBuffers[e.uid],
        l = this._gl;
      t || l.deleteBuffer(a.buffer), (this._gpuBuffers[e.uid] = null);
    }
    createGLBuffer(e) {
      const { _gl: t } = this;
      let a = Mo.ARRAY_BUFFER;
      e.descriptor.usage & Fe.INDEX
        ? (a = Mo.ELEMENT_ARRAY_BUFFER)
        : e.descriptor.usage & Fe.UNIFORM && (a = Mo.UNIFORM_BUFFER);
      const l = new Tv(t.createBuffer(), a);
      return (
        (this._gpuBuffers[e.uid] = l),
        e.on("destroy", this.onBufferDestroy, this),
        l
      );
    }
    resetState() {
      this._boundBufferBases = Object.create(null);
    }
  }
  vp.extension = { type: [P.WebGLSystem], name: "buffer" };
  const Qh = class a1 {
    constructor(e) {
      (this.supports = {
        uint32Indices: !0,
        uniformBufferObject: !0,
        vertexArrayObject: !0,
        srgbTextures: !0,
        nonPowOf2wrapping: !0,
        msaa: !0,
        nonPowOf2mipmaps: !0,
      }),
        (this._renderer = e),
        (this.extensions = Object.create(null)),
        (this.handleContextLost = this.handleContextLost.bind(this)),
        (this.handleContextRestored = this.handleContextRestored.bind(this));
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(e) {
      (this.gl = e), (this._renderer.gl = e);
    }
    init(e) {
      e = { ...a1.defaultOptions, ...e };
      let t = (this.multiView = e.multiView);
      if (
        (e.context &&
          t &&
          (pe(
            "Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."
          ),
            (t = !1)),
          t
            ? (this.canvas = xe
              .get()
              .createCanvas(
                this._renderer.canvas.width,
                this._renderer.canvas.height
              ))
            : (this.canvas = this._renderer.view.canvas),
          e.context)
      )
        this.initFromContext(e.context);
      else {
        const a = this._renderer.background.alpha < 1,
          l = e.premultipliedAlpha ?? !0,
          o = e.antialias && !this._renderer.backBuffer.useBackBuffer;
        this.createContext(e.preferWebGLVersion, {
          alpha: a,
          premultipliedAlpha: l,
          antialias: o,
          stencil: !0,
          preserveDrawingBuffer: e.preserveDrawingBuffer,
          powerPreference: e.powerPreference ?? "default",
        });
      }
    }
    ensureCanvasSize(e) {
      if (!this.multiView) {
        e !== this.canvas &&
          pe("multiView is disabled, but targetCanvas is not the main canvas");
        return;
      }
      const { canvas: t } = this;
      (t.width < e.width || t.height < e.height) &&
        ((t.width = Math.max(e.width, e.width)),
          (t.height = Math.max(e.height, e.height)));
    }
    initFromContext(e) {
      (this.gl = e),
        (this.webGLVersion =
          e instanceof xe.get().getWebGLRenderingContext() ? 1 : 2),
        this.getExtensions(),
        this.validateContext(e),
        this._renderer.runners.contextChange.emit(e);
      const t = this._renderer.view.canvas;
      t.addEventListener("webglcontextlost", this.handleContextLost, !1),
        t.addEventListener(
          "webglcontextrestored",
          this.handleContextRestored,
          !1
        );
    }
    createContext(e, t) {
      let a;
      const l = this.canvas;
      if (
        (e === 2 && (a = l.getContext("webgl2", t)),
          !a && ((a = l.getContext("webgl", t)), !a))
      )
        throw new Error(
          "This browser does not support WebGL. Try using the canvas renderer"
        );
      (this.gl = a), this.initFromContext(this.gl);
    }
    getExtensions() {
      const { gl: e } = this,
        t = {
          anisotropicFiltering: e.getExtension(
            "EXT_texture_filter_anisotropic"
          ),
          floatTextureLinear: e.getExtension("OES_texture_float_linear"),
          s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
          s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
          etc: e.getExtension("WEBGL_compressed_texture_etc"),
          etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
          pvrtc:
            e.getExtension("WEBGL_compressed_texture_pvrtc") ||
            e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          atc: e.getExtension("WEBGL_compressed_texture_atc"),
          astc: e.getExtension("WEBGL_compressed_texture_astc"),
          bptc: e.getExtension("EXT_texture_compression_bptc"),
          rgtc: e.getExtension("EXT_texture_compression_rgtc"),
          loseContext: e.getExtension("WEBGL_lose_context"),
        };
      if (this.webGLVersion === 1)
        this.extensions = {
          ...t,
          drawBuffers: e.getExtension("WEBGL_draw_buffers"),
          depthTexture: e.getExtension("WEBGL_depth_texture"),
          vertexArrayObject:
            e.getExtension("OES_vertex_array_object") ||
            e.getExtension("MOZ_OES_vertex_array_object") ||
            e.getExtension("WEBKIT_OES_vertex_array_object"),
          uint32ElementIndex: e.getExtension("OES_element_index_uint"),
          floatTexture: e.getExtension("OES_texture_float"),
          floatTextureLinear: e.getExtension("OES_texture_float_linear"),
          textureHalfFloat: e.getExtension("OES_texture_half_float"),
          textureHalfFloatLinear: e.getExtension(
            "OES_texture_half_float_linear"
          ),
          vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
          srgb: e.getExtension("EXT_sRGB"),
        };
      else {
        this.extensions = {
          ...t,
          colorBufferFloat: e.getExtension("EXT_color_buffer_float"),
        };
        const a = e.getExtension("WEBGL_provoking_vertex");
        a && a.provokingVertexWEBGL(a.FIRST_VERTEX_CONVENTION_WEBGL);
      }
    }
    handleContextLost(e) {
      e.preventDefault(),
        this._contextLossForced &&
        ((this._contextLossForced = !1),
          setTimeout(() => {
            this.gl.isContextLost() &&
              this.extensions.loseContext?.restoreContext();
          }, 0));
    }
    handleContextRestored() {
      this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      const e = this._renderer.view.canvas;
      (this._renderer = null),
        e.removeEventListener("webglcontextlost", this.handleContextLost),
        e.removeEventListener(
          "webglcontextrestored",
          this.handleContextRestored
        ),
        this.gl.useProgram(null),
        this.extensions.loseContext?.loseContext();
    }
    forceContextLoss() {
      this.extensions.loseContext?.loseContext(),
        (this._contextLossForced = !0);
    }
    validateContext(e) {
      const t = e.getContextAttributes();
      t &&
        !t.stencil &&
        pe(
          "Provided WebGL context does not have a stencil buffer, masks may not render correctly"
        );
      const a = this.supports,
        l = this.webGLVersion === 2,
        o = this.extensions;
      (a.uint32Indices = l || !!o.uint32ElementIndex),
        (a.uniformBufferObject = l),
        (a.vertexArrayObject = l || !!o.vertexArrayObject),
        (a.srgbTextures = l || !!o.srgb),
        (a.nonPowOf2wrapping = l),
        (a.nonPowOf2mipmaps = l),
        (a.msaa = l),
        a.uint32Indices ||
        pe(
          "Provided WebGL context does not support 32 index buffer, large scenes may not render correctly"
        );
    }
  };
  (Qh.extension = { type: [P.WebGLSystem], name: "context" }),
    (Qh.defaultOptions = {
      context: null,
      premultipliedAlpha: !0,
      preserveDrawingBuffer: !1,
      powerPreference: void 0,
      preferWebGLVersion: 2,
      multiView: !1,
    });
  let Cv = Qh;
  function bp(r, e) {
    for (const t in r.attributes) {
      const a = r.attributes[t],
        l = e[t];
      l
        ? (a.format ?? (a.format = l.format),
          a.offset ?? (a.offset = l.offset),
          a.instance ?? (a.instance = l.instance))
        : pe(
          `Attribute ${t} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`
        );
    }
    Av(r);
  }
  function Av(r) {
    const { buffers: e, attributes: t } = r,
      a = {},
      l = {};
    for (const o in e) {
      const h = e[o];
      (a[h.uid] = 0), (l[h.uid] = 0);
    }
    for (const o in t) {
      const h = t[o];
      a[h.buffer.uid] += lr(h.format).stride;
    }
    for (const o in t) {
      const h = t[o];
      h.stride ?? (h.stride = a[h.buffer.uid]),
        h.start ?? (h.start = l[h.buffer.uid]),
        (l[h.buffer.uid] += lr(h.format).stride);
    }
  }
  var Jh = ((r) => (
    (r[(r.RGBA = 6408)] = "RGBA"),
    (r[(r.RGB = 6407)] = "RGB"),
    (r[(r.RG = 33319)] = "RG"),
    (r[(r.RED = 6403)] = "RED"),
    (r[(r.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
    (r[(r.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
    (r[(r.RG_INTEGER = 33320)] = "RG_INTEGER"),
    (r[(r.RED_INTEGER = 36244)] = "RED_INTEGER"),
    (r[(r.ALPHA = 6406)] = "ALPHA"),
    (r[(r.LUMINANCE = 6409)] = "LUMINANCE"),
    (r[(r.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
    (r[(r.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
    (r[(r.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
    r
  ))(Jh || {}),
    wp = ((r) => (
      (r[(r.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
      (r[(r.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
      (r[(r.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
      (r[(r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
        "TEXTURE_CUBE_MAP_POSITIVE_X"),
      (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
        "TEXTURE_CUBE_MAP_NEGATIVE_X"),
      (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
        "TEXTURE_CUBE_MAP_POSITIVE_Y"),
      (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
        "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
      (r[(r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
        "TEXTURE_CUBE_MAP_POSITIVE_Z"),
      (r[(r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
        "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
      r
    ))(wp || {}),
    Oe = ((r) => (
      (r[(r.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
      (r[(r.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
      (r[(r.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
      (r[(r.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
      (r[(r.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
      (r[(r.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
      (r[(r.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
        "UNSIGNED_INT_10F_11F_11F_REV"),
      (r[(r.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
        "UNSIGNED_INT_2_10_10_10_REV"),
      (r[(r.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
      (r[(r.UNSIGNED_INT_5_9_9_9_REV = 35902)] = "UNSIGNED_INT_5_9_9_9_REV"),
      (r[(r.BYTE = 5120)] = "BYTE"),
      (r[(r.SHORT = 5122)] = "SHORT"),
      (r[(r.INT = 5124)] = "INT"),
      (r[(r.FLOAT = 5126)] = "FLOAT"),
      (r[(r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
        "FLOAT_32_UNSIGNED_INT_24_8_REV"),
      (r[(r.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
      r
    ))(Oe || {});
  const Sp = {
    uint8x2: Oe.UNSIGNED_BYTE,
    uint8x4: Oe.UNSIGNED_BYTE,
    sint8x2: Oe.BYTE,
    sint8x4: Oe.BYTE,
    unorm8x2: Oe.UNSIGNED_BYTE,
    unorm8x4: Oe.UNSIGNED_BYTE,
    snorm8x2: Oe.BYTE,
    snorm8x4: Oe.BYTE,
    uint16x2: Oe.UNSIGNED_SHORT,
    uint16x4: Oe.UNSIGNED_SHORT,
    sint16x2: Oe.SHORT,
    sint16x4: Oe.SHORT,
    unorm16x2: Oe.UNSIGNED_SHORT,
    unorm16x4: Oe.UNSIGNED_SHORT,
    snorm16x2: Oe.SHORT,
    snorm16x4: Oe.SHORT,
    float16x2: Oe.HALF_FLOAT,
    float16x4: Oe.HALF_FLOAT,
    float32: Oe.FLOAT,
    float32x2: Oe.FLOAT,
    float32x3: Oe.FLOAT,
    float32x4: Oe.FLOAT,
    uint32: Oe.UNSIGNED_INT,
    uint32x2: Oe.UNSIGNED_INT,
    uint32x3: Oe.UNSIGNED_INT,
    uint32x4: Oe.UNSIGNED_INT,
    sint32: Oe.INT,
    sint32x2: Oe.INT,
    sint32x3: Oe.INT,
    sint32x4: Oe.INT,
  };
  function Pv(r) {
    return Sp[r] ?? Sp.float32;
  }
  const Ev = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5,
  };
  class Mp {
    constructor(e) {
      (this._geometryVaoHash = Object.create(null)),
        (this._renderer = e),
        (this._activeGeometry = null),
        (this._activeVao = null),
        (this.hasVao = !0),
        (this.hasInstance = !0),
        this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash");
    }
    contextChange() {
      const e = (this.gl = this._renderer.gl);
      if (!this._renderer.context.supports.vertexArrayObject)
        throw new Error(
          "[PixiJS] Vertex Array Objects are not supported on this device"
        );
      const t = this._renderer.context.extensions.vertexArrayObject;
      t &&
        ((e.createVertexArray = () => t.createVertexArrayOES()),
          (e.bindVertexArray = (l) => t.bindVertexArrayOES(l)),
          (e.deleteVertexArray = (l) => t.deleteVertexArrayOES(l)));
      const a = this._renderer.context.extensions.vertexAttribDivisorANGLE;
      a &&
        ((e.drawArraysInstanced = (l, o, h, c) => {
          a.drawArraysInstancedANGLE(l, o, h, c);
        }),
          (e.drawElementsInstanced = (l, o, h, c, u) => {
            a.drawElementsInstancedANGLE(l, o, h, c, u);
          }),
          (e.vertexAttribDivisor = (l, o) => a.vertexAttribDivisorANGLE(l, o))),
        (this._activeGeometry = null),
        (this._activeVao = null),
        (this._geometryVaoHash = Object.create(null));
    }
    bind(e, t) {
      const a = this.gl;
      this._activeGeometry = e;
      const l = this.getVao(e, t);
      this._activeVao !== l && ((this._activeVao = l), a.bindVertexArray(l)),
        this.updateBuffers();
    }
    resetState() {
      this.unbind();
    }
    updateBuffers() {
      const e = this._activeGeometry,
        t = this._renderer.buffer;
      for (let a = 0; a < e.buffers.length; a++) {
        const l = e.buffers[a];
        t.updateBuffer(l);
      }
    }
    checkCompatibility(e, t) {
      const a = e.attributes,
        l = t._attributeData;
      for (const o in l)
        if (!a[o])
          throw new Error(
            `shader and geometry incompatible, geometry missing the "${o}" attribute`
          );
    }
    getSignature(e, t) {
      const a = e.attributes,
        l = t._attributeData,
        o = ["g", e.uid];
      for (const h in a) l[h] && o.push(h, l[h].location);
      return o.join("-");
    }
    getVao(e, t) {
      return (
        this._geometryVaoHash[e.uid]?.[t._key] || this.initGeometryVao(e, t)
      );
    }
    initGeometryVao(e, t, a = !0) {
      const l = this._renderer.gl,
        o = this._renderer.buffer;
      this._renderer.shader._getProgramData(t), this.checkCompatibility(e, t);
      const h = this.getSignature(e, t);
      this._geometryVaoHash[e.uid] ||
        ((this._geometryVaoHash[e.uid] = Object.create(null)),
          e.on("destroy", this.onGeometryDestroy, this));
      const c = this._geometryVaoHash[e.uid];
      let u = c[h];
      if (u) return (c[t._key] = u), u;
      bp(e, t._attributeData);
      const d = e.buffers;
      (u = l.createVertexArray()), l.bindVertexArray(u);
      for (let f = 0; f < d.length; f++) {
        const p = d[f];
        o.bind(p);
      }
      return (
        this.activateVao(e, t),
        (c[t._key] = u),
        (c[h] = u),
        l.bindVertexArray(null),
        u
      );
    }
    onGeometryDestroy(e, t) {
      const a = this._geometryVaoHash[e.uid],
        l = this.gl;
      if (a) {
        if (t)
          for (const o in a)
            this._activeVao !== a[o] && this.unbind(),
              l.deleteVertexArray(a[o]);
        this._geometryVaoHash[e.uid] = null;
      }
    }
    destroyAll(e = !1) {
      const t = this.gl;
      for (const a in this._geometryVaoHash) {
        if (e)
          for (const l in this._geometryVaoHash[a]) {
            const o = this._geometryVaoHash[a];
            this._activeVao !== o && this.unbind(), t.deleteVertexArray(o[l]);
          }
        this._geometryVaoHash[a] = null;
      }
    }
    activateVao(e, t) {
      const a = this._renderer.gl,
        l = this._renderer.buffer,
        o = e.attributes;
      e.indexBuffer && l.bind(e.indexBuffer);
      let h = null;
      for (const c in o) {
        const u = o[c],
          d = u.buffer,
          f = l.getGlBuffer(d),
          p = t._attributeData[c];
        if (p) {
          h !== f && (l.bind(d), (h = f));
          const g = p.location;
          a.enableVertexAttribArray(g);
          const _ = lr(u.format),
            m = Pv(u.format);
          if (
            (p.format?.substring(1, 4) === "int"
              ? a.vertexAttribIPointer(g, _.size, m, u.stride, u.offset)
              : a.vertexAttribPointer(
                g,
                _.size,
                m,
                _.normalised,
                u.stride,
                u.offset
              ),
              u.instance)
          )
            if (this.hasInstance) {
              const w = u.divisor ?? 1;
              a.vertexAttribDivisor(g, w);
            } else
              throw new Error(
                "geometry error, GPU Instancing is not supported on this device"
              );
        }
      }
    }
    draw(e, t, a, l) {
      const { gl: o } = this._renderer,
        h = this._activeGeometry,
        c = Ev[e || h.topology];
      if ((l ?? (l = h.instanceCount), h.indexBuffer)) {
        const u = h.indexBuffer.data.BYTES_PER_ELEMENT,
          d = u === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT;
        l > 1
          ? o.drawElementsInstanced(
            c,
            t || h.indexBuffer.data.length,
            d,
            (a || 0) * u,
            l
          )
          : o.drawElements(c, t || h.indexBuffer.data.length, d, (a || 0) * u);
      } else
        l > 1
          ? o.drawArraysInstanced(c, a || 0, t || h.getSize(), l)
          : o.drawArrays(c, a || 0, t || h.getSize());
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null),
        (this._activeVao = null),
        (this._activeGeometry = null);
    }
    destroy() {
      (this._renderer = null),
        (this.gl = null),
        (this._activeVao = null),
        (this._activeGeometry = null),
        (this._geometryVaoHash = null);
    }
  }
  Mp.extension = { type: [P.WebGLSystem], name: "geometry" };
  const kv = new Yn({ attributes: { aPosition: [-1, -1, 3, -1, -1, 3] } }),
    ec = class o1 {
      constructor(e) {
        (this.useBackBuffer = !1),
          (this._useBackBufferThisRender = !1),
          (this._renderer = e);
      }
      init(e = {}) {
        const { useBackBuffer: t, antialias: a } = {
          ...o1.defaultOptions,
          ...e,
        };
        (this.useBackBuffer = t),
          (this._antialias = a),
          this._renderer.context.supports.msaa ||
          (pe("antialiasing, is not supported on when using the back buffer"),
            (this._antialias = !1)),
          (this._state = gi.for2d());
        const l = new tn({
          vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
          fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
          name: "big-triangle",
        });
        this._bigTriangleShader = new ei({
          glProgram: l,
          resources: { uTexture: te.WHITE.source },
        });
      }
      renderStart(e) {
        const t = this._renderer.renderTarget.getRenderTarget(e.target);
        if (
          ((this._useBackBufferThisRender = this.useBackBuffer && !!t.isRoot),
            this._useBackBufferThisRender)
        ) {
          const a = this._renderer.renderTarget.getRenderTarget(e.target);
          (this._targetTexture = a.colorTexture),
            (e.target = this._getBackBufferTexture(a.colorTexture));
        }
      }
      renderEnd() {
        this._presentBackBuffer();
      }
      _presentBackBuffer() {
        const e = this._renderer;
        e.renderTarget.finishRenderPass(),
          this._useBackBufferThisRender &&
          (e.renderTarget.bind(this._targetTexture, !1),
            (this._bigTriangleShader.resources.uTexture =
              this._backBufferTexture.source),
            e.encoder.draw({
              geometry: kv,
              shader: this._bigTriangleShader,
              state: this._state,
            }));
      }
      _getBackBufferTexture(e) {
        return (
          (this._backBufferTexture =
            this._backBufferTexture ||
            new te({
              source: new zt({
                width: e.width,
                height: e.height,
                resolution: e._resolution,
                antialias: this._antialias,
              }),
            })),
          this._backBufferTexture.source.resize(
            e.width,
            e.height,
            e._resolution
          ),
          this._backBufferTexture
        );
      }
      destroy() {
        this._backBufferTexture &&
          (this._backBufferTexture.destroy(), (this._backBufferTexture = null));
      }
    };
  (ec.extension = { type: [P.WebGLSystem], name: "backBuffer", priority: 1 }),
    (ec.defaultOptions = { useBackBuffer: !1 });
  let Rv = ec;
  class Tp {
    constructor(e) {
      (this._colorMaskCache = 15), (this._renderer = e);
    }
    setMask(e) {
      this._colorMaskCache !== e &&
        ((this._colorMaskCache = e),
          this._renderer.gl.colorMask(
            !!(e & 8),
            !!(e & 4),
            !!(e & 2),
            !!(e & 1)
          ));
    }
  }
  Tp.extension = { type: [P.WebGLSystem], name: "colorMask" };
  class Cp {
    constructor(e) {
      (this.commandFinished = Promise.resolve()), (this._renderer = e);
    }
    setGeometry(e, t) {
      this._renderer.geometry.bind(e, t.glProgram);
    }
    finishRenderPass() { }
    draw(e) {
      const t = this._renderer,
        {
          geometry: a,
          shader: l,
          state: o,
          skipSync: h,
          topology: c,
          size: u,
          start: d,
          instanceCount: f,
        } = e;
      t.shader.bind(l, h),
        t.geometry.bind(a, t.shader._activeProgram),
        o && t.state.set(o),
        t.geometry.draw(c, u, d, f ?? a.instanceCount);
    }
    destroy() {
      this._renderer = null;
    }
  }
  Cp.extension = { type: [P.WebGLSystem], name: "encoder" };
  class Ap {
    constructor(e) {
      this._renderer = e;
    }
    contextChange() {
      const e = this._renderer.gl;
      (this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)),
        (this.maxBatchableTextures = sf(this.maxTextures, e));
      const t = this._renderer.context.webGLVersion === 2;
      this.maxUniformBindings = t
        ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS)
        : 0;
    }
    destroy() { }
  }
  Ap.extension = { type: [P.WebGLSystem], name: "limits" };
  class Iv {
    constructor() {
      (this.width = -1),
        (this.height = -1),
        (this.msaa = !1),
        (this.msaaRenderBuffer = []);
    }
  }
  const cr = [];
  (cr[Ft.NONE] = void 0),
    (cr[Ft.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }),
    (cr[Ft.RENDERING_MASK_ADD] = {
      stencilFront: { compare: "equal", passOp: "increment-clamp" },
      stencilBack: { compare: "equal", passOp: "increment-clamp" },
    }),
    (cr[Ft.RENDERING_MASK_REMOVE] = {
      stencilFront: { compare: "equal", passOp: "decrement-clamp" },
      stencilBack: { compare: "equal", passOp: "decrement-clamp" },
    }),
    (cr[Ft.MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: { compare: "equal", passOp: "keep" },
      stencilBack: { compare: "equal", passOp: "keep" },
    }),
    (cr[Ft.INVERSE_MASK_ACTIVE] = {
      stencilWriteMask: 0,
      stencilFront: { compare: "not-equal", passOp: "keep" },
      stencilBack: { compare: "not-equal", passOp: "keep" },
    });
  class Pp {
    constructor(e) {
      (this._stencilCache = {
        enabled: !1,
        stencilReference: 0,
        stencilMode: Ft.NONE,
      }),
        (this._renderTargetStencilState = Object.create(null)),
        e.renderTarget.onRenderTargetChange.add(this);
    }
    contextChange(e) {
      (this._gl = e),
        (this._comparisonFuncMapping = {
          always: e.ALWAYS,
          never: e.NEVER,
          equal: e.EQUAL,
          "not-equal": e.NOTEQUAL,
          less: e.LESS,
          "less-equal": e.LEQUAL,
          greater: e.GREATER,
          "greater-equal": e.GEQUAL,
        }),
        (this._stencilOpsMapping = {
          keep: e.KEEP,
          zero: e.ZERO,
          replace: e.REPLACE,
          invert: e.INVERT,
          "increment-clamp": e.INCR,
          "decrement-clamp": e.DECR,
          "increment-wrap": e.INCR_WRAP,
          "decrement-wrap": e.DECR_WRAP,
        }),
        this.resetState();
    }
    onRenderTargetChange(e) {
      if (this._activeRenderTarget === e) return;
      this._activeRenderTarget = e;
      let t = this._renderTargetStencilState[e.uid];
      t ||
        (t = this._renderTargetStencilState[e.uid] =
          { stencilMode: Ft.DISABLED, stencilReference: 0 }),
        this.setStencilMode(t.stencilMode, t.stencilReference);
    }
    resetState() {
      (this._stencilCache.enabled = !1),
        (this._stencilCache.stencilMode = Ft.NONE),
        (this._stencilCache.stencilReference = 0);
    }
    setStencilMode(e, t) {
      const a = this._renderTargetStencilState[this._activeRenderTarget.uid],
        l = this._gl,
        o = cr[e],
        h = this._stencilCache;
      if (((a.stencilMode = e), (a.stencilReference = t), e === Ft.DISABLED)) {
        this._stencilCache.enabled &&
          ((this._stencilCache.enabled = !1), l.disable(l.STENCIL_TEST));
        return;
      }
      this._stencilCache.enabled ||
        ((this._stencilCache.enabled = !0), l.enable(l.STENCIL_TEST)),
        (e !== h.stencilMode || h.stencilReference !== t) &&
        ((h.stencilMode = e),
          (h.stencilReference = t),
          l.stencilFunc(
            this._comparisonFuncMapping[o.stencilBack.compare],
            t,
            255
          ),
          l.stencilOp(
            l.KEEP,
            l.KEEP,
            this._stencilOpsMapping[o.stencilBack.passOp]
          ));
    }
  }
  Pp.extension = { type: [P.WebGLSystem], name: "stencil" };
  class Ep {
    constructor(e) {
      (this._syncFunctionHash = Object.create(null)),
        (this._adaptor = e),
        this._systemCheck();
    }
    _systemCheck() {
      if (!Iu())
        throw new Error(
          "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support."
        );
    }
    ensureUniformGroup(e) {
      const t = this.getUniformGroupData(e);
      e.buffer ||
        (e.buffer = new Hs({
          data: new Float32Array(t.layout.size / 4),
          usage: Fe.UNIFORM | Fe.COPY_DST,
        }));
    }
    getUniformGroupData(e) {
      return this._syncFunctionHash[e._signature] || this._initUniformGroup(e);
    }
    _initUniformGroup(e) {
      const t = e._signature;
      let a = this._syncFunctionHash[t];
      if (!a) {
        const l = Object.keys(e.uniformStructures).map(
          (c) => e.uniformStructures[c]
        ),
          o = this._adaptor.createUboElements(l),
          h = this._generateUboSync(o.uboElements);
        a = this._syncFunctionHash[t] = { layout: o, syncFunction: h };
      }
      return this._syncFunctionHash[t];
    }
    _generateUboSync(e) {
      return this._adaptor.generateUboSync(e);
    }
    syncUniformGroup(e, t, a) {
      const l = this.getUniformGroupData(e);
      e.buffer ||
        (e.buffer = new Hs({
          data: new Float32Array(l.layout.size / 4),
          usage: Fe.UNIFORM | Fe.COPY_DST,
        }));
      let o = null;
      return (
        t || ((t = e.buffer.data), (o = e.buffer.dataInt32)),
        a || (a = 0),
        l.syncFunction(e.uniforms, t, o, a),
        !0
      );
    }
    updateUniformGroup(e) {
      if (e.isStatic && !e._dirtyId) return !1;
      e._dirtyId = 0;
      const t = this.syncUniformGroup(e);
      return e.buffer.update(), t;
    }
    destroy() {
      this._syncFunctionHash = null;
    }
  }
  const kp = {
    f32: 4,
    i32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    "vec2<i32>": 8,
    "vec3<i32>": 12,
    "vec4<i32>": 16,
    "mat2x2<f32>": 32,
    "mat3x3<f32>": 48,
    "mat4x4<f32>": 64,
  };
  function Bv(r) {
    const e = r.map((o) => ({ data: o, offset: 0, size: 0 })),
      t = 16;
    let a = 0,
      l = 0;
    for (let o = 0; o < e.length; o++) {
      const h = e[o];
      if (((a = kp[h.data.type]), !a))
        throw new Error(`Unknown type ${h.data.type}`);
      h.data.size > 1 && (a = Math.max(a, t) * h.data.size);
      const c = a === 12 ? 16 : a;
      h.size = a;
      const u = l % t;
      u > 0 && t - u < c ? (l += (t - u) % 16) : (l += (a - (u % a)) % a),
        (h.offset = l),
        (l += a);
    }
    return (l = Math.ceil(l / 16) * 16), { uboElements: e, size: l };
  }
  const Lr = [
    {
      type: "mat3x3<f32>",
      test: (r) => r.value.a !== void 0,
      ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
      uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `,
    },
    {
      type: "vec4<f32>",
      test: (r) =>
        r.type === "vec4<f32>" && r.size === 1 && r.value.width !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `,
    },
    {
      type: "vec2<f32>",
      test: (r) =>
        r.type === "vec2<f32>" && r.size === 1 && r.value.x !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `,
    },
    {
      type: "vec4<f32>",
      test: (r) =>
        r.type === "vec4<f32>" && r.size === 1 && r.value.red !== void 0,
      ubo: `
            v = uv[name];            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `,
    },
    {
      type: "vec3<f32>",
      test: (r) =>
        r.type === "vec3<f32>" && r.size === 1 && r.value.red !== void 0,
      ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
      uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `,
    },
  ];
  function Rp(r, e, t, a) {
    const l = [
      `
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `,
    ];
    let o = 0;
    for (let c = 0; c < r.length; c++) {
      const u = r[c],
        d = u.data.name;
      let f = !1,
        p = 0;
      for (let g = 0; g < Lr.length; g++)
        if (Lr[g].test(u.data)) {
          (p = u.offset / 4),
            l.push(
              `name = "${d}";`,
              `offset += ${p - o};`,
              Lr[g][e] || Lr[g].ubo
            ),
            (f = !0);
          break;
        }
      if (!f)
        if (u.data.size > 1) (p = u.offset / 4), l.push(t(u, p - o));
        else {
          const g = a[u.data.type];
          (p = u.offset / 4),
            l.push(`
                    v = uv.${d};
                    offset += ${p - o};
                    ${g};
                `);
        }
      o = p;
    }
    const h = l.join(`
`);
    return new Function("uv", "data", "dataInt32", "offset", h);
  }
  function dn(r, e) {
    return `
        for (let i = 0; i < ${r * e}; i++) {
            data[offset + (((i / ${r})|0) * 4) + (i % ${r})] = v[i];
        }
    `;
  }
  const Ip = {
    f32: `
        data[offset] = v;`,
    i32: `
        dataInt32[offset] = v;`,
    "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
    "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
    "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
    "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
    "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
    "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
    "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
    "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
    "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
    "mat3x2<f32>": dn(3, 2),
    "mat4x2<f32>": dn(4, 2),
    "mat2x3<f32>": dn(2, 3),
    "mat4x3<f32>": dn(4, 3),
    "mat2x4<f32>": dn(2, 4),
    "mat3x4<f32>": dn(3, 4),
  },
    Fv = {
      ...Ip,
      "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `,
    };
  function Gv(r, e) {
    const t = Math.max(kp[r.data.type] / 16, 1),
      a = r.data.value.length / r.data.size,
      l = (4 - (a % 4)) % 4,
      o = r.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
        v = uv.${r.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${r.data.size * t}; i++)
        {
            for(var j = 0; j < ${a}; j++)
            {
                ${o}[arrayOffset++] = v[t++];
            }
            ${l !== 0 ? `arrayOffset += ${l};` : ""}        }
    `;
  }
  function Dv(r) {
    return Rp(r, "uboStd40", Gv, Ip);
  }
  class Bp extends Ep {
    constructor() {
      super({ createUboElements: Bv, generateUboSync: Dv });
    }
  }
  Bp.extension = { type: [P.WebGLSystem], name: "ubo" };
  class Uv {
    constructor() {
      (this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new Le());
    }
    init(e, t) {
      (this._renderer = e),
        (this._renderTargetSystem = t),
        e.runners.contextChange.add(this);
    }
    contextChange() {
      (this._clearColorCache = [0, 0, 0, 0]), (this._viewPortCache = new Le());
    }
    copyToTexture(e, t, a, l, o) {
      const h = this._renderTargetSystem,
        c = this._renderer,
        u = h.getGpuRenderTarget(e),
        d = c.gl;
      return (
        this.finishRenderPass(e),
        d.bindFramebuffer(d.FRAMEBUFFER, u.resolveTargetFramebuffer),
        c.texture.bind(t, 0),
        d.copyTexSubImage2D(
          d.TEXTURE_2D,
          0,
          o.x,
          o.y,
          a.x,
          a.y,
          l.width,
          l.height
        ),
        t
      );
    }
    startRenderPass(e, t = !0, a, l) {
      const o = this._renderTargetSystem,
        h = e.colorTexture,
        c = o.getGpuRenderTarget(e);
      let u = l.y;
      e.isRoot && (u = h.pixelHeight - l.height),
        e.colorTextures.forEach((p) => {
          this._renderer.texture.unbind(p);
        });
      const d = this._renderer.gl;
      d.bindFramebuffer(d.FRAMEBUFFER, c.framebuffer);
      const f = this._viewPortCache;
      (f.x !== l.x ||
        f.y !== u ||
        f.width !== l.width ||
        f.height !== l.height) &&
        ((f.x = l.x),
          (f.y = u),
          (f.width = l.width),
          (f.height = l.height),
          d.viewport(l.x, u, l.width, l.height)),
        !c.depthStencilRenderBuffer &&
        (e.stencil || e.depth) &&
        this._initStencil(c),
        this.clear(e, t, a);
    }
    finishRenderPass(e) {
      const a = this._renderTargetSystem.getGpuRenderTarget(e);
      if (!a.msaa) return;
      const l = this._renderer.gl;
      l.bindFramebuffer(l.FRAMEBUFFER, a.resolveTargetFramebuffer),
        l.bindFramebuffer(l.READ_FRAMEBUFFER, a.framebuffer),
        l.blitFramebuffer(
          0,
          0,
          a.width,
          a.height,
          0,
          0,
          a.width,
          a.height,
          l.COLOR_BUFFER_BIT,
          l.NEAREST
        ),
        l.bindFramebuffer(l.FRAMEBUFFER, a.framebuffer);
    }
    initGpuRenderTarget(e) {
      const a = this._renderer.gl,
        l = new Iv();
      return e.colorTexture instanceof ji
        ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource),
          (l.framebuffer = null),
          l)
        : (this._initColor(e, l), a.bindFramebuffer(a.FRAMEBUFFER, null), l);
    }
    destroyGpuRenderTarget(e) {
      const t = this._renderer.gl;
      e.framebuffer &&
        (t.deleteFramebuffer(e.framebuffer), (e.framebuffer = null)),
        e.resolveTargetFramebuffer &&
        (t.deleteFramebuffer(e.resolveTargetFramebuffer),
          (e.resolveTargetFramebuffer = null)),
        e.depthStencilRenderBuffer &&
        (t.deleteRenderbuffer(e.depthStencilRenderBuffer),
          (e.depthStencilRenderBuffer = null)),
        e.msaaRenderBuffer.forEach((a) => {
          t.deleteRenderbuffer(a);
        }),
        (e.msaaRenderBuffer = null);
    }
    clear(e, t, a) {
      if (!t) return;
      const l = this._renderTargetSystem;
      typeof t == "boolean" && (t = t ? Ns.ALL : Ns.NONE);
      const o = this._renderer.gl;
      if (t & Ns.COLOR) {
        a ?? (a = l.defaultClearColor);
        const h = this._clearColorCache,
          c = a;
        (h[0] !== c[0] || h[1] !== c[1] || h[2] !== c[2] || h[3] !== c[3]) &&
          ((h[0] = c[0]),
            (h[1] = c[1]),
            (h[2] = c[2]),
            (h[3] = c[3]),
            o.clearColor(c[0], c[1], c[2], c[3]));
      }
      o.clear(t);
    }
    resizeGpuRenderTarget(e) {
      if (e.isRoot) return;
      const a = this._renderTargetSystem.getGpuRenderTarget(e);
      this._resizeColor(e, a), (e.stencil || e.depth) && this._resizeStencil(a);
    }
    _initColor(e, t) {
      const a = this._renderer,
        l = a.gl,
        o = l.createFramebuffer();
      if (
        ((t.resolveTargetFramebuffer = o),
          l.bindFramebuffer(l.FRAMEBUFFER, o),
          (t.width = e.colorTexture.source.pixelWidth),
          (t.height = e.colorTexture.source.pixelHeight),
          e.colorTextures.forEach((h, c) => {
            const u = h.source;
            u.antialias &&
              (a.context.supports.msaa
                ? (t.msaa = !0)
                : pe(
                  "[RenderTexture] Antialiasing on textures is not supported in WebGL1"
                )),
              a.texture.bindSource(u, 0);
            const f = a.texture.getGlSource(u).texture;
            l.framebufferTexture2D(
              l.FRAMEBUFFER,
              l.COLOR_ATTACHMENT0 + c,
              3553,
              f,
              0
            );
          }),
          t.msaa)
      ) {
        const h = l.createFramebuffer();
        (t.framebuffer = h),
          l.bindFramebuffer(l.FRAMEBUFFER, h),
          e.colorTextures.forEach((c, u) => {
            const d = l.createRenderbuffer();
            t.msaaRenderBuffer[u] = d;
          });
      } else t.framebuffer = o;
      this._resizeColor(e, t);
    }
    _resizeColor(e, t) {
      const a = e.colorTexture.source;
      if (
        ((t.width = a.pixelWidth),
          (t.height = a.pixelHeight),
          e.colorTextures.forEach((l, o) => {
            o !== 0 && l.source.resize(a.width, a.height, a._resolution);
          }),
          t.msaa)
      ) {
        const l = this._renderer,
          o = l.gl,
          h = t.framebuffer;
        o.bindFramebuffer(o.FRAMEBUFFER, h),
          e.colorTextures.forEach((c, u) => {
            const d = c.source;
            l.texture.bindSource(d, 0);
            const p = l.texture.getGlSource(d).internalFormat,
              g = t.msaaRenderBuffer[u];
            o.bindRenderbuffer(o.RENDERBUFFER, g),
              o.renderbufferStorageMultisample(
                o.RENDERBUFFER,
                4,
                p,
                d.pixelWidth,
                d.pixelHeight
              ),
              o.framebufferRenderbuffer(
                o.FRAMEBUFFER,
                o.COLOR_ATTACHMENT0 + u,
                o.RENDERBUFFER,
                g
              );
          });
      }
    }
    _initStencil(e) {
      if (e.framebuffer === null) return;
      const t = this._renderer.gl,
        a = t.createRenderbuffer();
      (e.depthStencilRenderBuffer = a),
        t.bindRenderbuffer(t.RENDERBUFFER, a),
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_STENCIL_ATTACHMENT,
          t.RENDERBUFFER,
          a
        ),
        this._resizeStencil(e);
    }
    _resizeStencil(e) {
      const t = this._renderer.gl;
      t.bindRenderbuffer(t.RENDERBUFFER, e.depthStencilRenderBuffer),
        e.msaa
          ? t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            4,
            t.DEPTH24_STENCIL8,
            e.width,
            e.height
          )
          : t.renderbufferStorage(
            t.RENDERBUFFER,
            this._renderer.context.webGLVersion === 2
              ? t.DEPTH24_STENCIL8
              : t.DEPTH_STENCIL,
            e.width,
            e.height
          );
    }
    prerender(e) {
      const t = e.colorTexture.resource;
      this._renderer.context.multiView &&
        ji.test(t) &&
        this._renderer.context.ensureCanvasSize(t);
    }
    postrender(e) {
      if (
        this._renderer.context.multiView &&
        ji.test(e.colorTexture.resource)
      ) {
        const t = this._renderer.context.canvas,
          a = e.colorTexture;
        a.context2D.drawImage(t, 0, a.pixelHeight - t.height);
      }
    }
  }
  function Ov(r, e, t, a, l, o) {
    const h = o ? 1 : -1;
    return (
      r.identity(),
      (r.a = (1 / a) * 2),
      (r.d = h * ((1 / l) * 2)),
      (r.tx = -1 - e * r.a),
      (r.ty = -h - t * r.d),
      r
    );
  }
  const un = new Map();
  Zr.register(un);
  function Fp(r, e) {
    if (!un.has(r)) {
      const t = new te({ source: new ji({ resource: r, ...e }) }),
        a = () => {
          un.get(r) === t && un.delete(r);
        };
      t.once("destroy", a), t.source.once("destroy", a), un.set(r, t);
    }
    return un.get(r);
  }
  function Lv(r) {
    const e = r.colorTexture.source.resource;
    return (
      globalThis.HTMLCanvasElement &&
      e instanceof HTMLCanvasElement &&
      document.body.contains(e)
    );
  }
  const Gp = class l1 {
    constructor(e = {}) {
      if (
        ((this.uid = et("renderTarget")),
          (this.colorTextures = []),
          (this.dirtyId = 0),
          (this.isRoot = !1),
          (this._size = new Float32Array(2)),
          (this._managedColorTextures = !1),
          (e = { ...l1.defaultOptions, ...e }),
          (this.stencil = e.stencil),
          (this.depth = e.depth),
          (this.isRoot = e.isRoot),
          typeof e.colorTextures == "number")
      ) {
        this._managedColorTextures = !0;
        for (let t = 0; t < e.colorTextures; t++)
          this.colorTextures.push(
            new zt({
              width: e.width,
              height: e.height,
              resolution: e.resolution,
              antialias: e.antialias,
            })
          );
      } else {
        this.colorTextures = [...e.colorTextures.map((a) => a.source)];
        const t = this.colorTexture.source;
        this.resize(t.width, t.height, t._resolution);
      }
      this.colorTexture.source.on("resize", this.onSourceResize, this),
        (e.depthStencilTexture || this.stencil) &&
        (e.depthStencilTexture instanceof te ||
          e.depthStencilTexture instanceof zt
          ? (this.depthStencilTexture = e.depthStencilTexture.source)
          : this.ensureDepthStencilTexture());
    }
    get size() {
      const e = this._size;
      return (e[0] = this.pixelWidth), (e[1] = this.pixelHeight), e;
    }
    get width() {
      return this.colorTexture.source.width;
    }
    get height() {
      return this.colorTexture.source.height;
    }
    get pixelWidth() {
      return this.colorTexture.source.pixelWidth;
    }
    get pixelHeight() {
      return this.colorTexture.source.pixelHeight;
    }
    get resolution() {
      return this.colorTexture.source._resolution;
    }
    get colorTexture() {
      return this.colorTextures[0];
    }
    onSourceResize(e) {
      this.resize(e.width, e.height, e._resolution, !0);
    }
    ensureDepthStencilTexture() {
      this.depthStencilTexture ||
        (this.depthStencilTexture = new zt({
          width: this.width,
          height: this.height,
          resolution: this.resolution,
          format: "depth24plus-stencil8",
          autoGenerateMipmaps: !1,
          antialias: !1,
          mipLevelCount: 1,
        }));
    }
    resize(e, t, a = this.resolution, l = !1) {
      this.dirtyId++,
        this.colorTextures.forEach((o, h) => {
          (l && h === 0) || o.source.resize(e, t, a);
        }),
        this.depthStencilTexture &&
        this.depthStencilTexture.source.resize(e, t, a);
    }
    destroy() {
      this.colorTexture.source.off("resize", this.onSourceResize, this),
        this._managedColorTextures &&
        this.colorTextures.forEach((e) => {
          e.destroy();
        }),
        this.depthStencilTexture &&
        (this.depthStencilTexture.destroy(), delete this.depthStencilTexture);
    }
  };
  Gp.defaultOptions = {
    width: 0,
    height: 0,
    resolution: 1,
    colorTextures: 1,
    stencil: !1,
    depth: !1,
    antialias: !1,
    isRoot: !1,
  };
  let tc = Gp;
  class Dp {
    constructor(e) {
      (this.rootViewPort = new Le()),
        (this.viewport = new Le()),
        (this.onRenderTargetChange = new Lu("onRenderTargetChange")),
        (this.projectionMatrix = new ae()),
        (this.defaultClearColor = [0, 0, 0, 0]),
        (this._renderSurfaceToRenderTargetHash = new Map()),
        (this._gpuRenderTargetHash = Object.create(null)),
        (this._renderTargetStack = []),
        (this._renderer = e),
        e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
    }
    finishRenderPass() {
      this.adaptor.finishRenderPass(this.renderTarget);
    }
    renderStart({ target: e, clear: t, clearColor: a, frame: l }) {
      (this._renderTargetStack.length = 0),
        this.push(e, t, a, l),
        this.rootViewPort.copyFrom(this.viewport),
        (this.rootRenderTarget = this.renderTarget),
        (this.renderingToScreen = Lv(this.rootRenderTarget)),
        this.adaptor.prerender?.(this.rootRenderTarget);
    }
    postrender() {
      this.adaptor.postrender?.(this.rootRenderTarget);
    }
    bind(e, t = !0, a, l) {
      const o = this.getRenderTarget(e),
        h = this.renderTarget !== o;
      (this.renderTarget = o), (this.renderSurface = e);
      const c = this.getGpuRenderTarget(o);
      (o.pixelWidth !== c.width || o.pixelHeight !== c.height) &&
        (this.adaptor.resizeGpuRenderTarget(o),
          (c.width = o.pixelWidth),
          (c.height = o.pixelHeight));
      const u = o.colorTexture,
        d = this.viewport,
        f = u.pixelWidth,
        p = u.pixelHeight;
      if ((!l && e instanceof te && (l = e.frame), l)) {
        const g = u._resolution;
        (d.x = (l.x * g + 0.5) | 0),
          (d.y = (l.y * g + 0.5) | 0),
          (d.width = (l.width * g + 0.5) | 0),
          (d.height = (l.height * g + 0.5) | 0);
      } else (d.x = 0), (d.y = 0), (d.width = f), (d.height = p);
      return (
        Ov(
          this.projectionMatrix,
          0,
          0,
          d.width / u.resolution,
          d.height / u.resolution,
          !o.isRoot
        ),
        this.adaptor.startRenderPass(o, t, a, d),
        h && this.onRenderTargetChange.emit(o),
        o
      );
    }
    clear(e, t = Ns.ALL, a) {
      t &&
        (e && (e = this.getRenderTarget(e)),
          this.adaptor.clear(e || this.renderTarget, t, a, this.viewport));
    }
    contextChange() {
      this._gpuRenderTargetHash = Object.create(null);
    }
    push(e, t = Ns.ALL, a, l) {
      const o = this.bind(e, t, a, l);
      return this._renderTargetStack.push({ renderTarget: o, frame: l }), o;
    }
    pop() {
      this._renderTargetStack.pop();
      const e = this._renderTargetStack[this._renderTargetStack.length - 1];
      this.bind(e.renderTarget, !1, null, e.frame);
    }
    getRenderTarget(e) {
      return (
        e.isTexture && (e = e.source),
        this._renderSurfaceToRenderTargetHash.get(e) ??
        this._initRenderTarget(e)
      );
    }
    copyToTexture(e, t, a, l, o) {
      a.x < 0 && ((l.width += a.x), (o.x -= a.x), (a.x = 0)),
        a.y < 0 && ((l.height += a.y), (o.y -= a.y), (a.y = 0));
      const { pixelWidth: h, pixelHeight: c } = e;
      return (
        (l.width = Math.min(l.width, h - a.x)),
        (l.height = Math.min(l.height, c - a.y)),
        this.adaptor.copyToTexture(e, t, a, l, o)
      );
    }
    ensureDepthStencil() {
      this.renderTarget.stencil ||
        ((this.renderTarget.stencil = !0),
          this.adaptor.startRenderPass(
            this.renderTarget,
            !1,
            null,
            this.viewport
          ));
    }
    destroy() {
      (this._renderer = null),
        this._renderSurfaceToRenderTargetHash.forEach((e, t) => {
          e !== t && e.destroy();
        }),
        this._renderSurfaceToRenderTargetHash.clear(),
        (this._gpuRenderTargetHash = Object.create(null));
    }
    _initRenderTarget(e) {
      let t = null;
      return (
        ji.test(e) && (e = Fp(e).source),
        e instanceof tc
          ? (t = e)
          : e instanceof zt &&
          ((t = new tc({ colorTextures: [e] })),
            e.source instanceof ji && (t.isRoot = !0),
            e.once("destroy", () => {
              t.destroy(), this._renderSurfaceToRenderTargetHash.delete(e);
              const a = this._gpuRenderTargetHash[t.uid];
              a &&
                ((this._gpuRenderTargetHash[t.uid] = null),
                  this.adaptor.destroyGpuRenderTarget(a));
            })),
        this._renderSurfaceToRenderTargetHash.set(e, t),
        t
      );
    }
    getGpuRenderTarget(e) {
      return (
        this._gpuRenderTargetHash[e.uid] ||
        (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e))
      );
    }
    resetState() {
      (this.renderTarget = null), (this.renderSurface = null);
    }
  }
  class Up extends Dp {
    constructor(e) {
      super(e), (this.adaptor = new Uv()), this.adaptor.init(e, this);
    }
  }
  Up.extension = { type: [P.WebGLSystem], name: "renderTarget" };
  class sc extends Os {
    constructor({ buffer: e, offset: t, size: a }) {
      super(),
        (this.uid = et("buffer")),
        (this._resourceType = "bufferResource"),
        (this._touched = 0),
        (this._resourceId = et("resource")),
        (this._bufferResource = !0),
        (this.destroyed = !1),
        (this.buffer = e),
        (this.offset = t | 0),
        (this.size = a),
        this.buffer.on("change", this.onBufferChange, this);
    }
    onBufferChange() {
      (this._resourceId = et("resource")), this.emit("change", this);
    }
    destroy(e = !1) {
      (this.destroyed = !0),
        e && this.buffer.destroy(),
        this.emit("change", this),
        (this.buffer = null);
    }
  }
  function Nv(r, e) {
    const t = [],
      a = [
        `
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `,
      ];
    let l = !1,
      o = 0;
    const h = e._getProgramData(r.glProgram);
    for (const u in r.groups) {
      const d = r.groups[u];
      t.push(`
            resources = g[${u}].resources;
        `);
      for (const f in d.resources) {
        const p = d.resources[f];
        if (p instanceof ys)
          if (p.ubo) {
            const g = r._uniformBindMap[u][Number(f)];
            t.push(`
                        sS.bindUniformBlock(
                            resources[${f}],
                            '${g}',
                            ${r.glProgram._uniformBlockData[g].index}
                        );
                    `);
          } else
            t.push(`
                        ugS.updateUniformGroup(resources[${f}], p, sD);
                    `);
        else if (p instanceof sc) {
          const g = r._uniformBindMap[u][Number(f)];
          t.push(`
                    sS.bindUniformBlock(
                        resources[${f}],
                        '${g}',
                        ${r.glProgram._uniformBlockData[g].index}
                    );
                `);
        } else if (p instanceof zt) {
          const g = r._uniformBindMap[u][f],
            _ = h.uniformData[g];
          _ &&
            (l ||
              ((l = !0),
                a.push(`
                        var tS = r.texture;
                        `)),
              e._gl.uniform1i(_.location, o),
              t.push(`
                        tS.bind(resources[${f}], ${o});
                    `),
              o++);
        }
      }
    }
    const c = [...a, ...t].join(`
`);
    return new Function("r", "s", "sD", c);
  }
  class Hv {
    constructor(e, t) {
      (this.program = e),
        (this.uniformData = t),
        (this.uniformGroups = {}),
        (this.uniformDirtyGroups = {}),
        (this.uniformBlockBindings = {});
    }
    destroy() {
      (this.uniformData = null),
        (this.uniformGroups = null),
        (this.uniformDirtyGroups = null),
        (this.uniformBlockBindings = null),
        (this.program = null);
    }
  }
  function Op(r, e, t) {
    const a = r.createShader(e);
    return r.shaderSource(a, t), r.compileShader(a), a;
  }
  function ic(r) {
    const e = new Array(r);
    for (let t = 0; t < e.length; t++) e[t] = !1;
    return e;
  }
  function Lp(r, e) {
    switch (r) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * e);
      case "vec3":
        return new Float32Array(3 * e);
      case "vec4":
        return new Float32Array(4 * e);
      case "int":
      case "uint":
      case "sampler2D":
      case "sampler2DArray":
        return 0;
      case "ivec2":
        return new Int32Array(2 * e);
      case "ivec3":
        return new Int32Array(3 * e);
      case "ivec4":
        return new Int32Array(4 * e);
      case "uvec2":
        return new Uint32Array(2 * e);
      case "uvec3":
        return new Uint32Array(3 * e);
      case "uvec4":
        return new Uint32Array(4 * e);
      case "bool":
        return !1;
      case "bvec2":
        return ic(2 * e);
      case "bvec3":
        return ic(3 * e);
      case "bvec4":
        return ic(4 * e);
      case "mat2":
        return new Float32Array([1, 0, 0, 1]);
      case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      case "mat4":
        return new Float32Array([
          1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
        ]);
    }
    return null;
  }
  let To = null;
  const Np = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  },
    zv = {
      float: "float32",
      vec2: "float32x2",
      vec3: "float32x3",
      vec4: "float32x4",
      int: "sint32",
      ivec2: "sint32x2",
      ivec3: "sint32x3",
      ivec4: "sint32x4",
      uint: "uint32",
      uvec2: "uint32x2",
      uvec3: "uint32x3",
      uvec4: "uint32x4",
      bool: "uint32",
      bvec2: "uint32x2",
      bvec3: "uint32x3",
      bvec4: "uint32x4",
    };
  function Hp(r, e) {
    if (!To) {
      const t = Object.keys(Np);
      To = {};
      for (let a = 0; a < t.length; ++a) {
        const l = t[a];
        To[r[l]] = Np[l];
      }
    }
    return To[e];
  }
  function Wv(r, e) {
    const t = Hp(r, e);
    return zv[t] || "float32";
  }
  function Vv(r, e, t = !1) {
    const a = {},
      l = e.getProgramParameter(r, e.ACTIVE_ATTRIBUTES);
    for (let h = 0; h < l; h++) {
      const c = e.getActiveAttrib(r, h);
      if (c.name.startsWith("gl_")) continue;
      const u = Wv(e, c.type);
      a[c.name] = {
        location: 0,
        format: u,
        stride: lr(u).stride,
        offset: 0,
        instance: !1,
        start: 0,
      };
    }
    const o = Object.keys(a);
    if (t) {
      o.sort((h, c) => (h > c ? 1 : -1));
      for (let h = 0; h < o.length; h++)
        (a[o[h]].location = h), e.bindAttribLocation(r, h, o[h]);
      e.linkProgram(r);
    } else
      for (let h = 0; h < o.length; h++)
        a[o[h]].location = e.getAttribLocation(r, o[h]);
    return a;
  }
  function jv(r, e) {
    if (!e.ACTIVE_UNIFORM_BLOCKS) return {};
    const t = {},
      a = e.getProgramParameter(r, e.ACTIVE_UNIFORM_BLOCKS);
    for (let l = 0; l < a; l++) {
      const o = e.getActiveUniformBlockName(r, l),
        h = e.getUniformBlockIndex(r, o),
        c = e.getActiveUniformBlockParameter(r, l, e.UNIFORM_BLOCK_DATA_SIZE);
      t[o] = { name: o, index: h, size: c };
    }
    return t;
  }
  function Xv(r, e) {
    const t = {},
      a = e.getProgramParameter(r, e.ACTIVE_UNIFORMS);
    for (let l = 0; l < a; l++) {
      const o = e.getActiveUniform(r, l),
        h = o.name.replace(/\[.*?\]$/, ""),
        c = !!o.name.match(/\[.*?\]$/),
        u = Hp(e, o.type);
      t[h] = {
        name: h,
        index: l,
        type: u,
        size: o.size,
        isArray: c,
        value: Lp(u, o.size),
      };
    }
    return t;
  }
  function zp(r, e) {
    const t = r
      .getShaderSource(e)
      .split(
        `
`
      )
      .map((d, f) => `${f}: ${d}`),
      a = r.getShaderInfoLog(e),
      l = a.split(`
`),
      o = {},
      h = l
        .map((d) => parseFloat(d.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))
        .filter((d) => (d && !o[d] ? ((o[d] = !0), !0) : !1)),
      c = [""];
    h.forEach((d) => {
      (t[d - 1] = `%c${t[d - 1]}%c`),
        c.push(
          "background: #FF0000; color:#fff; font-size: 10px",
          "font-size: 10px"
        );
    });
    const u = t.join(`
`);
    c[0] = u;
  }
  function qv(r, e, t, a) {
    r.getProgramParameter(e, r.LINK_STATUS) ||
      (r.getShaderParameter(t, r.COMPILE_STATUS) || zp(r, t),
        r.getShaderParameter(a, r.COMPILE_STATUS) || zp(r, a));
  }
  function Yv(r, e) {
    const t = Op(r, r.VERTEX_SHADER, e.vertex),
      a = Op(r, r.FRAGMENT_SHADER, e.fragment),
      l = r.createProgram();
    r.attachShader(l, t), r.attachShader(l, a);
    const o = e.transformFeedbackVaryings;
    o &&
      (typeof r.transformFeedbackVaryings != "function"
        ? pe(
          "TransformFeedback is not supported but TransformFeedbackVaryings are given."
        )
        : r.transformFeedbackVaryings(
          l,
          o.names,
          o.bufferMode === "separate"
            ? r.SEPARATE_ATTRIBS
            : r.INTERLEAVED_ATTRIBS
        )),
      r.linkProgram(l),
      r.getProgramParameter(l, r.LINK_STATUS) || qv(r, l, t, a),
      (e._attributeData = Vv(
        l,
        r,
        !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)
      )),
      (e._uniformData = Xv(l, r)),
      (e._uniformBlockData = jv(l, r)),
      r.deleteShader(t),
      r.deleteShader(a);
    const h = {};
    for (const u in e._uniformData) {
      const d = e._uniformData[u];
      h[u] = {
        location: r.getUniformLocation(l, u),
        value: Lp(d.type, d.size),
      };
    }
    return new Hv(l, h);
  }
  const Co = { textureCount: 0, blockIndex: 0 };
  class Wp {
    constructor(e) {
      (this._activeProgram = null),
        (this._programDataHash = Object.create(null)),
        (this._shaderSyncFunctions = Object.create(null)),
        (this._renderer = e),
        this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
    }
    contextChange(e) {
      (this._gl = e),
        (this._programDataHash = Object.create(null)),
        (this._shaderSyncFunctions = Object.create(null)),
        (this._activeProgram = null);
    }
    bind(e, t) {
      if ((this._setProgram(e.glProgram), t)) return;
      (Co.textureCount = 0), (Co.blockIndex = 0);
      let a = this._shaderSyncFunctions[e.glProgram._key];
      a ||
        (a = this._shaderSyncFunctions[e.glProgram._key] =
          this._generateShaderSync(e, this)),
        this._renderer.buffer.nextBindBase(
          !!e.glProgram.transformFeedbackVaryings
        ),
        a(this._renderer, e, Co);
    }
    updateUniformGroup(e) {
      this._renderer.uniformGroup.updateUniformGroup(
        e,
        this._activeProgram,
        Co
      );
    }
    bindUniformBlock(e, t, a = 0) {
      const l = this._renderer.buffer,
        o = this._getProgramData(this._activeProgram),
        h = e._bufferResource;
      h || this._renderer.ubo.updateUniformGroup(e);
      const c = e.buffer,
        u = l.updateBuffer(c),
        d = l.freeLocationForBufferBase(u);
      if (h) {
        const { offset: p, size: g } = e;
        p === 0 && g === c.data.byteLength
          ? l.bindBufferBase(u, d)
          : l.bindBufferRange(u, d, p);
      } else l.getLastBindBaseLocation(u) !== d && l.bindBufferBase(u, d);
      const f = this._activeProgram._uniformBlockData[t].index;
      o.uniformBlockBindings[a] !== d &&
        ((o.uniformBlockBindings[a] = d),
          this._renderer.gl.uniformBlockBinding(o.program, f, d));
    }
    _setProgram(e) {
      if (this._activeProgram === e) return;
      this._activeProgram = e;
      const t = this._getProgramData(e);
      this._gl.useProgram(t.program);
    }
    _getProgramData(e) {
      return this._programDataHash[e._key] || this._createProgramData(e);
    }
    _createProgramData(e) {
      const t = e._key;
      return (
        (this._programDataHash[t] = Yv(this._gl, e)), this._programDataHash[t]
      );
    }
    destroy() {
      for (const e of Object.keys(this._programDataHash))
        this._programDataHash[e].destroy(), (this._programDataHash[e] = null);
      (this._programDataHash = null),
        (this._shaderSyncFunctions = null),
        (this._activeProgram = null),
        (this._renderer = null),
        (this._gl = null);
    }
    _generateShaderSync(e, t) {
      return Nv(e, t);
    }
    resetState() {
      this._activeProgram = null;
    }
  }
  Wp.extension = { type: [P.WebGLSystem], name: "shader" };
  const $v = {
    f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
    "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
    "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
    "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
    i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
    "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
    "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
    "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
    bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
    "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
    "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
    "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
    "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
    "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
    "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
  },
    Kv = {
      f32: "gl.uniform1fv(location, v);",
      "vec2<f32>": "gl.uniform2fv(location, v);",
      "vec3<f32>": "gl.uniform3fv(location, v);",
      "vec4<f32>": "gl.uniform4fv(location, v);",
      "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
      "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
      "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
      i32: "gl.uniform1iv(location, v);",
      "vec2<i32>": "gl.uniform2iv(location, v);",
      "vec3<i32>": "gl.uniform3iv(location, v);",
      "vec4<i32>": "gl.uniform4iv(location, v);",
      u32: "gl.uniform1iv(location, v);",
      "vec2<u32>": "gl.uniform2iv(location, v);",
      "vec3<u32>": "gl.uniform3iv(location, v);",
      "vec4<u32>": "gl.uniform4iv(location, v);",
      bool: "gl.uniform1iv(location, v);",
      "vec2<bool>": "gl.uniform2iv(location, v);",
      "vec3<bool>": "gl.uniform3iv(location, v);",
      "vec4<bool>": "gl.uniform4iv(location, v);",
    };
  function Zv(r, e) {
    const t = [
      `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `,
    ];
    for (const a in r.uniforms) {
      if (!e[a]) {
        r.uniforms[a] instanceof ys
          ? r.uniforms[a].ubo
            ? t.push(`
                        renderer.shader.bindUniformBlock(uv.${a}, "${a}");
                    `)
            : t.push(`
                        renderer.shader.updateUniformGroup(uv.${a});
                    `)
          : r.uniforms[a] instanceof sc &&
          t.push(`
                        renderer.shader.bindBufferResource(uv.${a}, "${a}");
                    `);
        continue;
      }
      const l = r.uniformStructures[a];
      let o = !1;
      for (let h = 0; h < Lr.length; h++) {
        const c = Lr[h];
        if (l.type === c.type && c.test(l)) {
          t.push(`name = "${a}";`, Lr[h].uniform), (o = !0);
          break;
        }
      }
      if (!o) {
        const c = (l.size === 1 ? $v : Kv)[l.type].replace(
          "location",
          `ud["${a}"].location`
        );
        t.push(`
            cu = ud["${a}"];
            cv = cu.value;
            v = uv["${a}"];
            ${c};`);
      }
    }
    return new Function(
      "ud",
      "uv",
      "renderer",
      "syncData",
      t.join(`
`)
    );
  }
  class Vp {
    constructor(e) {
      (this._cache = {}),
        (this._uniformGroupSyncHash = {}),
        (this._renderer = e),
        (this.gl = null),
        (this._cache = {});
    }
    contextChange(e) {
      this.gl = e;
    }
    updateUniformGroup(e, t, a) {
      const l = this._renderer.shader._getProgramData(t);
      (!e.isStatic || e._dirtyId !== l.uniformDirtyGroups[e.uid]) &&
        ((l.uniformDirtyGroups[e.uid] = e._dirtyId),
          this._getUniformSyncFunction(e, t)(
            l.uniformData,
            e.uniforms,
            this._renderer,
            a
          ));
    }
    _getUniformSyncFunction(e, t) {
      return (
        this._uniformGroupSyncHash[e._signature]?.[t._key] ||
        this._createUniformSyncFunction(e, t)
      );
    }
    _createUniformSyncFunction(e, t) {
      const a =
        this._uniformGroupSyncHash[e._signature] ||
        (this._uniformGroupSyncHash[e._signature] = {}),
        l = this._getSignature(e, t._uniformData, "u");
      return (
        this._cache[l] ||
        (this._cache[l] = this._generateUniformsSync(e, t._uniformData)),
        (a[t._key] = this._cache[l]),
        a[t._key]
      );
    }
    _generateUniformsSync(e, t) {
      return Zv(e, t);
    }
    _getSignature(e, t, a) {
      const l = e.uniforms,
        o = [`${a}-`];
      for (const h in l) o.push(h), t[h] && o.push(t[h].type);
      return o.join("-");
    }
    destroy() {
      (this._renderer = null), (this._cache = null);
    }
  }
  Vp.extension = { type: [P.WebGLSystem], name: "uniformGroup" };
  function Qv(r) {
    const e = {};
    if (
      ((e.normal = [r.ONE, r.ONE_MINUS_SRC_ALPHA]),
        (e.add = [r.ONE, r.ONE]),
        (e.multiply = [
          r.DST_COLOR,
          r.ONE_MINUS_SRC_ALPHA,
          r.ONE,
          r.ONE_MINUS_SRC_ALPHA,
        ]),
        (e.screen = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA]),
        (e.none = [0, 0]),
        (e["normal-npm"] = [
          r.SRC_ALPHA,
          r.ONE_MINUS_SRC_ALPHA,
          r.ONE,
          r.ONE_MINUS_SRC_ALPHA,
        ]),
        (e["add-npm"] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE]),
        (e["screen-npm"] = [
          r.SRC_ALPHA,
          r.ONE_MINUS_SRC_COLOR,
          r.ONE,
          r.ONE_MINUS_SRC_ALPHA,
        ]),
        (e.erase = [r.ZERO, r.ONE_MINUS_SRC_ALPHA]),
        !(r instanceof xe.get().getWebGLRenderingContext()))
    )
      (e.min = [r.ONE, r.ONE, r.ONE, r.ONE, r.MIN, r.MIN]),
        (e.max = [r.ONE, r.ONE, r.ONE, r.ONE, r.MAX, r.MAX]);
    else {
      const a = r.getExtension("EXT_blend_minmax");
      a &&
        ((e.min = [r.ONE, r.ONE, r.ONE, r.ONE, a.MIN_EXT, a.MIN_EXT]),
          (e.max = [r.ONE, r.ONE, r.ONE, r.ONE, a.MAX_EXT, a.MAX_EXT]));
    }
    return e;
  }
  const Jv = 0,
    eb = 1,
    tb = 2,
    sb = 3,
    ib = 4,
    rb = 5,
    jp = class ud {
      constructor(e) {
        (this._invertFrontFace = !1),
          (this.gl = null),
          (this.stateId = 0),
          (this.polygonOffset = 0),
          (this.blendMode = "none"),
          (this._blendEq = !1),
          (this.map = []),
          (this.map[Jv] = this.setBlend),
          (this.map[eb] = this.setOffset),
          (this.map[tb] = this.setCullFace),
          (this.map[sb] = this.setDepthTest),
          (this.map[ib] = this.setFrontFace),
          (this.map[rb] = this.setDepthMask),
          (this.checks = []),
          (this.defaultState = gi.for2d()),
          e.renderTarget.onRenderTargetChange.add(this);
      }
      onRenderTargetChange(e) {
        (this._invertFrontFace = !e.isRoot),
          this._cullFace
            ? this.setFrontFace(this._frontFace)
            : (this._frontFaceDirty = !0);
      }
      contextChange(e) {
        (this.gl = e), (this.blendModesMap = Qv(e)), this.resetState();
      }
      set(e) {
        if ((e || (e = this.defaultState), this.stateId !== e.data)) {
          let t = this.stateId ^ e.data,
            a = 0;
          for (; t;)
            t & 1 && this.map[a].call(this, !!(e.data & (1 << a))),
              (t >>= 1),
              a++;
          this.stateId = e.data;
        }
        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
      }
      forceState(e) {
        e || (e = this.defaultState);
        for (let t = 0; t < this.map.length; t++)
          this.map[t].call(this, !!(e.data & (1 << t)));
        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
        this.stateId = e.data;
      }
      setBlend(e) {
        this._updateCheck(ud._checkBlendMode, e),
          this.gl[e ? "enable" : "disable"](this.gl.BLEND);
      }
      setOffset(e) {
        this._updateCheck(ud._checkPolygonOffset, e),
          this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
      }
      setDepthTest(e) {
        this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
      }
      setDepthMask(e) {
        this.gl.depthMask(e);
      }
      setCullFace(e) {
        (this._cullFace = e),
          this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE),
          this._cullFace &&
          this._frontFaceDirty &&
          this.setFrontFace(this._frontFace);
      }
      setFrontFace(e) {
        (this._frontFace = e), (this._frontFaceDirty = !1);
        const t = this._invertFrontFace ? !e : e;
        this._glFrontFace !== t &&
          ((this._glFrontFace = t),
            this.gl.frontFace(this.gl[t ? "CW" : "CCW"]));
      }
      setBlendMode(e) {
        if ((this.blendModesMap[e] || (e = "normal"), e === this.blendMode))
          return;
        this.blendMode = e;
        const t = this.blendModesMap[e],
          a = this.gl;
        t.length === 2
          ? a.blendFunc(t[0], t[1])
          : a.blendFuncSeparate(t[0], t[1], t[2], t[3]),
          t.length === 6
            ? ((this._blendEq = !0), a.blendEquationSeparate(t[4], t[5]))
            : this._blendEq &&
            ((this._blendEq = !1),
              a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD));
      }
      setPolygonOffset(e, t) {
        this.gl.polygonOffset(e, t);
      }
      resetState() {
        (this._glFrontFace = !1),
          (this._frontFace = !1),
          (this._cullFace = !1),
          (this._frontFaceDirty = !1),
          (this._invertFrontFace = !1),
          this.gl.frontFace(this.gl.CCW),
          this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
          this.forceState(this.defaultState),
          (this._blendEq = !0),
          (this.blendMode = ""),
          this.setBlendMode("normal");
      }
      _updateCheck(e, t) {
        const a = this.checks.indexOf(e);
        t && a === -1
          ? this.checks.push(e)
          : !t && a !== -1 && this.checks.splice(a, 1);
      }
      static _checkBlendMode(e, t) {
        e.setBlendMode(t.blendMode);
      }
      static _checkPolygonOffset(e, t) {
        e.setPolygonOffset(1, t.polygonOffset);
      }
      destroy() {
        (this.gl = null), (this.checks.length = 0);
      }
    };
  jp.extension = { type: [P.WebGLSystem], name: "state" };
  let nb = jp;
  class ab {
    constructor(e) {
      (this.target = wp.TEXTURE_2D),
        (this.texture = e),
        (this.width = -1),
        (this.height = -1),
        (this.type = Oe.UNSIGNED_BYTE),
        (this.internalFormat = Jh.RGBA),
        (this.format = Jh.RGBA),
        (this.samplerType = 0);
    }
  }
  const ob = {
    id: "buffer",
    upload(r, e, t) {
      e.width === r.width || e.height === r.height
        ? t.texSubImage2D(
          t.TEXTURE_2D,
          0,
          0,
          0,
          r.width,
          r.height,
          e.format,
          e.type,
          r.resource
        )
        : t.texImage2D(
          e.target,
          0,
          e.internalFormat,
          r.width,
          r.height,
          0,
          e.format,
          e.type,
          r.resource
        ),
        (e.width = r.width),
        (e.height = r.height);
    },
  },
    lb = {
      "bc1-rgba-unorm": !0,
      "bc1-rgba-unorm-srgb": !0,
      "bc2-rgba-unorm": !0,
      "bc2-rgba-unorm-srgb": !0,
      "bc3-rgba-unorm": !0,
      "bc3-rgba-unorm-srgb": !0,
      "bc4-r-unorm": !0,
      "bc4-r-snorm": !0,
      "bc5-rg-unorm": !0,
      "bc5-rg-snorm": !0,
      "bc6h-rgb-ufloat": !0,
      "bc6h-rgb-float": !0,
      "bc7-rgba-unorm": !0,
      "bc7-rgba-unorm-srgb": !0,
      "etc2-rgb8unorm": !0,
      "etc2-rgb8unorm-srgb": !0,
      "etc2-rgb8a1unorm": !0,
      "etc2-rgb8a1unorm-srgb": !0,
      "etc2-rgba8unorm": !0,
      "etc2-rgba8unorm-srgb": !0,
      "eac-r11unorm": !0,
      "eac-r11snorm": !0,
      "eac-rg11unorm": !0,
      "eac-rg11snorm": !0,
      "astc-4x4-unorm": !0,
      "astc-4x4-unorm-srgb": !0,
      "astc-5x4-unorm": !0,
      "astc-5x4-unorm-srgb": !0,
      "astc-5x5-unorm": !0,
      "astc-5x5-unorm-srgb": !0,
      "astc-6x5-unorm": !0,
      "astc-6x5-unorm-srgb": !0,
      "astc-6x6-unorm": !0,
      "astc-6x6-unorm-srgb": !0,
      "astc-8x5-unorm": !0,
      "astc-8x5-unorm-srgb": !0,
      "astc-8x6-unorm": !0,
      "astc-8x6-unorm-srgb": !0,
      "astc-8x8-unorm": !0,
      "astc-8x8-unorm-srgb": !0,
      "astc-10x5-unorm": !0,
      "astc-10x5-unorm-srgb": !0,
      "astc-10x6-unorm": !0,
      "astc-10x6-unorm-srgb": !0,
      "astc-10x8-unorm": !0,
      "astc-10x8-unorm-srgb": !0,
      "astc-10x10-unorm": !0,
      "astc-10x10-unorm-srgb": !0,
      "astc-12x10-unorm": !0,
      "astc-12x10-unorm-srgb": !0,
      "astc-12x12-unorm": !0,
      "astc-12x12-unorm-srgb": !0,
    },
    hb = {
      id: "compressed",
      upload(r, e, t) {
        t.pixelStorei(t.UNPACK_ALIGNMENT, 4);
        let a = r.pixelWidth,
          l = r.pixelHeight;
        const o = !!lb[r.format];
        for (let h = 0; h < r.resource.length; h++) {
          const c = r.resource[h];
          o
            ? t.compressedTexImage2D(
              t.TEXTURE_2D,
              h,
              e.internalFormat,
              a,
              l,
              0,
              c
            )
            : t.texImage2D(
              t.TEXTURE_2D,
              h,
              e.internalFormat,
              a,
              l,
              0,
              e.format,
              e.type,
              c
            ),
            (a = Math.max(a >> 1, 1)),
            (l = Math.max(l >> 1, 1));
        }
      },
    },
    Xp = {
      id: "image",
      upload(r, e, t, a) {
        const l = e.width,
          o = e.height,
          h = r.pixelWidth,
          c = r.pixelHeight,
          u = r.resourceWidth,
          d = r.resourceHeight;
        u < h || d < c
          ? ((l !== h || o !== c) &&
            t.texImage2D(
              e.target,
              0,
              e.internalFormat,
              h,
              c,
              0,
              e.format,
              e.type,
              null
            ),
            a === 2
              ? t.texSubImage2D(
                t.TEXTURE_2D,
                0,
                0,
                0,
                u,
                d,
                e.format,
                e.type,
                r.resource
              )
              : t.texSubImage2D(
                t.TEXTURE_2D,
                0,
                0,
                0,
                e.format,
                e.type,
                r.resource
              ))
          : l === h && o === c
            ? t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, e.format, e.type, r.resource)
            : a === 2
              ? t.texImage2D(
                e.target,
                0,
                e.internalFormat,
                h,
                c,
                0,
                e.format,
                e.type,
                r.resource
              )
              : t.texImage2D(
                e.target,
                0,
                e.internalFormat,
                e.format,
                e.type,
                r.resource
              ),
          (e.width = h),
          (e.height = c);
      },
    },
    cb = {
      id: "video",
      upload(r, e, t, a) {
        if (!r.isValid) {
          t.texImage2D(
            e.target,
            0,
            e.internalFormat,
            1,
            1,
            0,
            e.format,
            e.type,
            null
          );
          return;
        }
        Xp.upload(r, e, t, a);
      },
    },
    qp = { linear: 9729, nearest: 9728 },
    db = {
      linear: { linear: 9987, nearest: 9985 },
      nearest: { linear: 9986, nearest: 9984 },
    },
    rc = { "clamp-to-edge": 33071, repeat: 10497, "mirror-repeat": 33648 },
    ub = {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519,
    };
  function Yp(r, e, t, a, l, o, h, c) {
    const u = o;
    if (
      !c ||
      r.addressModeU !== "repeat" ||
      r.addressModeV !== "repeat" ||
      r.addressModeW !== "repeat"
    ) {
      const d = rc[h ? "clamp-to-edge" : r.addressModeU],
        f = rc[h ? "clamp-to-edge" : r.addressModeV],
        p = rc[h ? "clamp-to-edge" : r.addressModeW];
      e[l](u, e.TEXTURE_WRAP_S, d),
        e[l](u, e.TEXTURE_WRAP_T, f),
        e.TEXTURE_WRAP_R && e[l](u, e.TEXTURE_WRAP_R, p);
    }
    if (
      ((!c || r.magFilter !== "linear") &&
        e[l](u, e.TEXTURE_MAG_FILTER, qp[r.magFilter]),
        t)
    ) {
      if (!c || r.mipmapFilter !== "linear") {
        const d = db[r.minFilter][r.mipmapFilter];
        e[l](u, e.TEXTURE_MIN_FILTER, d);
      }
    } else e[l](u, e.TEXTURE_MIN_FILTER, qp[r.minFilter]);
    if (a && r.maxAnisotropy > 1) {
      const d = Math.min(
        r.maxAnisotropy,
        e.getParameter(a.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
      );
      e[l](u, a.TEXTURE_MAX_ANISOTROPY_EXT, d);
    }
    r.compare && e[l](u, e.TEXTURE_COMPARE_FUNC, ub[r.compare]);
  }
  function fb(r) {
    return {
      r8unorm: r.RED,
      r8snorm: r.RED,
      r8uint: r.RED,
      r8sint: r.RED,
      r16uint: r.RED,
      r16sint: r.RED,
      r16float: r.RED,
      rg8unorm: r.RG,
      rg8snorm: r.RG,
      rg8uint: r.RG,
      rg8sint: r.RG,
      r32uint: r.RED,
      r32sint: r.RED,
      r32float: r.RED,
      rg16uint: r.RG,
      rg16sint: r.RG,
      rg16float: r.RG,
      rgba8unorm: r.RGBA,
      "rgba8unorm-srgb": r.RGBA,
      rgba8snorm: r.RGBA,
      rgba8uint: r.RGBA,
      rgba8sint: r.RGBA,
      bgra8unorm: r.RGBA,
      "bgra8unorm-srgb": r.RGBA,
      rgb9e5ufloat: r.RGB,
      rgb10a2unorm: r.RGBA,
      rg11b10ufloat: r.RGB,
      rg32uint: r.RG,
      rg32sint: r.RG,
      rg32float: r.RG,
      rgba16uint: r.RGBA,
      rgba16sint: r.RGBA,
      rgba16float: r.RGBA,
      rgba32uint: r.RGBA,
      rgba32sint: r.RGBA,
      rgba32float: r.RGBA,
      stencil8: r.STENCIL_INDEX8,
      depth16unorm: r.DEPTH_COMPONENT,
      depth24plus: r.DEPTH_COMPONENT,
      "depth24plus-stencil8": r.DEPTH_STENCIL,
      depth32float: r.DEPTH_COMPONENT,
      "depth32float-stencil8": r.DEPTH_STENCIL,
    };
  }
  function pb(r, e) {
    let t = {},
      a = r.RGBA;
    return (
      r instanceof xe.get().getWebGLRenderingContext()
        ? e.srgb &&
        (t = {
          "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
          "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
        })
        : ((t = {
          "rgba8unorm-srgb": r.SRGB8_ALPHA8,
          "bgra8unorm-srgb": r.SRGB8_ALPHA8,
        }),
          (a = r.RGBA8)),
      {
        r8unorm: r.R8,
        r8snorm: r.R8_SNORM,
        r8uint: r.R8UI,
        r8sint: r.R8I,
        r16uint: r.R16UI,
        r16sint: r.R16I,
        r16float: r.R16F,
        rg8unorm: r.RG8,
        rg8snorm: r.RG8_SNORM,
        rg8uint: r.RG8UI,
        rg8sint: r.RG8I,
        r32uint: r.R32UI,
        r32sint: r.R32I,
        r32float: r.R32F,
        rg16uint: r.RG16UI,
        rg16sint: r.RG16I,
        rg16float: r.RG16F,
        rgba8unorm: r.RGBA,
        ...t,
        rgba8snorm: r.RGBA8_SNORM,
        rgba8uint: r.RGBA8UI,
        rgba8sint: r.RGBA8I,
        bgra8unorm: a,
        rgb9e5ufloat: r.RGB9_E5,
        rgb10a2unorm: r.RGB10_A2,
        rg11b10ufloat: r.R11F_G11F_B10F,
        rg32uint: r.RG32UI,
        rg32sint: r.RG32I,
        rg32float: r.RG32F,
        rgba16uint: r.RGBA16UI,
        rgba16sint: r.RGBA16I,
        rgba16float: r.RGBA16F,
        rgba32uint: r.RGBA32UI,
        rgba32sint: r.RGBA32I,
        rgba32float: r.RGBA32F,
        stencil8: r.STENCIL_INDEX8,
        depth16unorm: r.DEPTH_COMPONENT16,
        depth24plus: r.DEPTH_COMPONENT24,
        "depth24plus-stencil8": r.DEPTH24_STENCIL8,
        depth32float: r.DEPTH_COMPONENT32F,
        "depth32float-stencil8": r.DEPTH32F_STENCIL8,
        ...(e.s3tc
          ? {
            "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,
          }
          : {}),
        ...(e.s3tc_sRGB
          ? {
            "bc1-rgba-unorm-srgb":
              e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm-srgb":
              e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm-srgb":
              e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
          }
          : {}),
        ...(e.rgtc
          ? {
            "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
            "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
            "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
            "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
          }
          : {}),
        ...(e.bptc
          ? {
            "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
            "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
            "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
            "bc7-rgba-unorm-srgb":
              e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,
          }
          : {}),
        ...(e.etc
          ? {
            "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
            "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
            "etc2-rgb8a1unorm":
              e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgb8a1unorm-srgb":
              e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
            "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
            "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
            "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC,
          }
          : {}),
        ...(e.astc
          ? {
            "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
            "astc-4x4-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
            "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
            "astc-5x4-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
            "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
            "astc-5x5-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
            "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
            "astc-6x5-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
            "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
            "astc-6x6-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
            "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
            "astc-8x5-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
            "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
            "astc-8x6-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
            "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
            "astc-8x8-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
            "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
            "astc-10x5-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
            "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
            "astc-10x6-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
            "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
            "astc-10x8-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
            "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
            "astc-10x10-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
            "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
            "astc-12x10-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
            "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
            "astc-12x12-unorm-srgb":
              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
          }
          : {}),
      }
    );
  }
  function gb(r) {
    return {
      r8unorm: r.UNSIGNED_BYTE,
      r8snorm: r.BYTE,
      r8uint: r.UNSIGNED_BYTE,
      r8sint: r.BYTE,
      r16uint: r.UNSIGNED_SHORT,
      r16sint: r.SHORT,
      r16float: r.HALF_FLOAT,
      rg8unorm: r.UNSIGNED_BYTE,
      rg8snorm: r.BYTE,
      rg8uint: r.UNSIGNED_BYTE,
      rg8sint: r.BYTE,
      r32uint: r.UNSIGNED_INT,
      r32sint: r.INT,
      r32float: r.FLOAT,
      rg16uint: r.UNSIGNED_SHORT,
      rg16sint: r.SHORT,
      rg16float: r.HALF_FLOAT,
      rgba8unorm: r.UNSIGNED_BYTE,
      "rgba8unorm-srgb": r.UNSIGNED_BYTE,
      rgba8snorm: r.BYTE,
      rgba8uint: r.UNSIGNED_BYTE,
      rgba8sint: r.BYTE,
      bgra8unorm: r.UNSIGNED_BYTE,
      "bgra8unorm-srgb": r.UNSIGNED_BYTE,
      rgb9e5ufloat: r.UNSIGNED_INT_5_9_9_9_REV,
      rgb10a2unorm: r.UNSIGNED_INT_2_10_10_10_REV,
      rg11b10ufloat: r.UNSIGNED_INT_10F_11F_11F_REV,
      rg32uint: r.UNSIGNED_INT,
      rg32sint: r.INT,
      rg32float: r.FLOAT,
      rgba16uint: r.UNSIGNED_SHORT,
      rgba16sint: r.SHORT,
      rgba16float: r.HALF_FLOAT,
      rgba32uint: r.UNSIGNED_INT,
      rgba32sint: r.INT,
      rgba32float: r.FLOAT,
      stencil8: r.UNSIGNED_BYTE,
      depth16unorm: r.UNSIGNED_SHORT,
      depth24plus: r.UNSIGNED_INT,
      "depth24plus-stencil8": r.UNSIGNED_INT_24_8,
      depth32float: r.FLOAT,
      "depth32float-stencil8": r.FLOAT_32_UNSIGNED_INT_24_8_REV,
    };
  }
  const mb = 4;
  class $p {
    constructor(e) {
      (this.managedTextures = []),
        (this._glTextures = Object.create(null)),
        (this._glSamplers = Object.create(null)),
        (this._boundTextures = []),
        (this._activeTextureLocation = -1),
        (this._boundSamplers = Object.create(null)),
        (this._uploads = { image: Xp, buffer: ob, video: cb, compressed: hb }),
        (this._premultiplyAlpha = !1),
        (this._useSeparateSamplers = !1),
        (this._renderer = e),
        this._renderer.renderableGC.addManagedHash(this, "_glTextures"),
        this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
    }
    contextChange(e) {
      (this._gl = e),
        this._mapFormatToInternalFormat ||
        ((this._mapFormatToInternalFormat = pb(
          e,
          this._renderer.context.extensions
        )),
          (this._mapFormatToType = gb(e)),
          (this._mapFormatToFormat = fb(e))),
        (this._glTextures = Object.create(null)),
        (this._glSamplers = Object.create(null)),
        (this._boundSamplers = Object.create(null)),
        (this._premultiplyAlpha = !1);
      for (let t = 0; t < 16; t++) this.bind(te.EMPTY, t);
    }
    initSource(e) {
      this.bind(e);
    }
    bind(e, t = 0) {
      const a = e.source;
      e
        ? (this.bindSource(a, t),
          this._useSeparateSamplers && this._bindSampler(a.style, t))
        : (this.bindSource(null, t),
          this._useSeparateSamplers && this._bindSampler(null, t));
    }
    bindSource(e, t = 0) {
      const a = this._gl;
      if (
        ((e._touched = this._renderer.textureGC.count),
          this._boundTextures[t] !== e)
      ) {
        (this._boundTextures[t] = e),
          this._activateLocation(t),
          e || (e = te.EMPTY.source);
        const l = this.getGlSource(e);
        a.bindTexture(l.target, l.texture);
      }
    }
    _bindSampler(e, t = 0) {
      const a = this._gl;
      if (!e) {
        (this._boundSamplers[t] = null), a.bindSampler(t, null);
        return;
      }
      const l = this._getGlSampler(e);
      this._boundSamplers[t] !== l &&
        ((this._boundSamplers[t] = l), a.bindSampler(t, l));
    }
    unbind(e) {
      const t = e.source,
        a = this._boundTextures,
        l = this._gl;
      for (let o = 0; o < a.length; o++)
        if (a[o] === t) {
          this._activateLocation(o);
          const h = this.getGlSource(t);
          l.bindTexture(h.target, null), (a[o] = null);
        }
    }
    _activateLocation(e) {
      this._activeTextureLocation !== e &&
        ((this._activeTextureLocation = e),
          this._gl.activeTexture(this._gl.TEXTURE0 + e));
    }
    _initSource(e) {
      const t = this._gl,
        a = new ab(t.createTexture());
      if (
        ((a.type = this._mapFormatToType[e.format]),
          (a.internalFormat = this._mapFormatToInternalFormat[e.format]),
          (a.format = this._mapFormatToFormat[e.format]),
          e.autoGenerateMipmaps &&
          (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo))
      ) {
        const l = Math.max(e.width, e.height);
        e.mipLevelCount = Math.floor(Math.log2(l)) + 1;
      }
      return (
        (this._glTextures[e.uid] = a),
        this.managedTextures.includes(e) ||
        (e.on("update", this.onSourceUpdate, this),
          e.on("resize", this.onSourceUpdate, this),
          e.on("styleChange", this.onStyleChange, this),
          e.on("destroy", this.onSourceDestroy, this),
          e.on("unload", this.onSourceUnload, this),
          e.on("updateMipmaps", this.onUpdateMipmaps, this),
          this.managedTextures.push(e)),
        this.onSourceUpdate(e),
        this.updateStyle(e, !1),
        a
      );
    }
    onStyleChange(e) {
      this.updateStyle(e, !1);
    }
    updateStyle(e, t) {
      const a = this._gl,
        l = this.getGlSource(e);
      a.bindTexture(a.TEXTURE_2D, l.texture),
        (this._boundTextures[this._activeTextureLocation] = e),
        Yp(
          e.style,
          a,
          e.mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "texParameteri",
          a.TEXTURE_2D,
          !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo,
          t
        );
    }
    onSourceUnload(e) {
      const t = this._glTextures[e.uid];
      t &&
        (this.unbind(e),
          (this._glTextures[e.uid] = null),
          this._gl.deleteTexture(t.texture));
    }
    onSourceUpdate(e) {
      const t = this._gl,
        a = this.getGlSource(e);
      t.bindTexture(t.TEXTURE_2D, a.texture),
        (this._boundTextures[this._activeTextureLocation] = e);
      const l = e.alphaMode === "premultiply-alpha-on-upload";
      this._premultiplyAlpha !== l &&
        ((this._premultiplyAlpha = l),
          t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, l)),
        this._uploads[e.uploadMethodId]
          ? this._uploads[e.uploadMethodId].upload(
            e,
            a,
            t,
            this._renderer.context.webGLVersion
          )
          : t.texImage2D(
            t.TEXTURE_2D,
            0,
            t.RGBA,
            e.pixelWidth,
            e.pixelHeight,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            null
          ),
        e.autoGenerateMipmaps &&
        e.mipLevelCount > 1 &&
        this.onUpdateMipmaps(e, !1);
    }
    onUpdateMipmaps(e, t = !0) {
      t && this.bindSource(e, 0);
      const a = this.getGlSource(e);
      this._gl.generateMipmap(a.target);
    }
    onSourceDestroy(e) {
      e.off("destroy", this.onSourceDestroy, this),
        e.off("update", this.onSourceUpdate, this),
        e.off("resize", this.onSourceUpdate, this),
        e.off("unload", this.onSourceUnload, this),
        e.off("styleChange", this.onStyleChange, this),
        e.off("updateMipmaps", this.onUpdateMipmaps, this),
        this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
        this.onSourceUnload(e);
    }
    _initSampler(e) {
      const t = this._gl,
        a = this._gl.createSampler();
      return (
        (this._glSamplers[e._resourceId] = a),
        Yp(
          e,
          t,
          this._boundTextures[this._activeTextureLocation].mipLevelCount > 1,
          this._renderer.context.extensions.anisotropicFiltering,
          "samplerParameteri",
          a,
          !1,
          !0
        ),
        this._glSamplers[e._resourceId]
      );
    }
    _getGlSampler(e) {
      return this._glSamplers[e._resourceId] || this._initSampler(e);
    }
    getGlSource(e) {
      return this._glTextures[e.uid] || this._initSource(e);
    }
    generateCanvas(e) {
      const { pixels: t, width: a, height: l } = this.getPixels(e),
        o = xe.get().createCanvas();
      (o.width = a), (o.height = l);
      const h = o.getContext("2d");
      if (h) {
        const c = h.createImageData(a, l);
        c.data.set(t), h.putImageData(c, 0, 0);
      }
      return o;
    }
    getPixels(e) {
      const t = e.source.resolution,
        a = e.frame,
        l = Math.max(Math.round(a.width * t), 1),
        o = Math.max(Math.round(a.height * t), 1),
        h = new Uint8Array(mb * l * o),
        c = this._renderer,
        u = c.renderTarget.getRenderTarget(e),
        d = c.renderTarget.getGpuRenderTarget(u),
        f = c.gl;
      return (
        f.bindFramebuffer(f.FRAMEBUFFER, d.resolveTargetFramebuffer),
        f.readPixels(
          Math.round(a.x * t),
          Math.round(a.y * t),
          l,
          o,
          f.RGBA,
          f.UNSIGNED_BYTE,
          h
        ),
        { pixels: new Uint8ClampedArray(h.buffer), width: l, height: o }
      );
    }
    destroy() {
      this.managedTextures.slice().forEach((e) => this.onSourceDestroy(e)),
        (this.managedTextures = null),
        (this._glTextures = null),
        (this._glSamplers = null),
        (this._boundTextures = null),
        (this._boundSamplers = null),
        (this._mapFormatToInternalFormat = null),
        (this._mapFormatToType = null),
        (this._mapFormatToFormat = null),
        (this._uploads = null),
        (this._renderer = null);
    }
    resetState() {
      (this._activeTextureLocation = -1),
        this._boundTextures.fill(te.EMPTY.source),
        (this._boundSamplers = Object.create(null));
      const e = this._gl;
      (this._premultiplyAlpha = !1),
        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
    }
  }
  $p.extension = { type: [P.WebGLSystem], name: "texture" };
  class Kp {
    contextChange(e) {
      const t = new ys({
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uTransformMatrix: { value: new ae(), type: "mat3x3<f32>" },
        uRound: { value: 0, type: "f32" },
      }),
        a = e.limits.maxBatchableTextures,
        l = Kn({ name: "graphics", bits: [Sh, Ah(a), Zh, Qn] });
      this.shader = new ei({
        glProgram: l,
        resources: { localUniforms: t, batchSamplers: Ph(a) },
      });
    }
    execute(e, t) {
      const a = t.context,
        l = a.customShader || this.shader,
        o = e.renderer,
        h = o.graphicsContext,
        { batcher: c, instructions: u } = h.getContextRenderData(a);
      (l.groups[0] = o.globalUniforms.bindGroup),
        o.state.set(e.state),
        o.shader.bind(l),
        o.geometry.bind(c.geometry, l.glProgram);
      const d = u.instructions;
      for (let f = 0; f < u.instructionSize; f++) {
        const p = d[f];
        if (p.size) {
          for (let g = 0; g < p.textures.count; g++)
            o.texture.bind(p.textures.textures[g], g);
          o.geometry.draw(p.topology, p.size, p.start);
        }
      }
    }
    destroy() {
      this.shader.destroy(!0), (this.shader = null);
    }
  }
  Kp.extension = { type: [P.WebGLPipesAdaptor], name: "graphics" };
  class Zp {
    init() {
      const e = Kn({ name: "mesh", bits: [Zh, wv, Qn] });
      this._shader = new ei({
        glProgram: e,
        resources: {
          uTexture: te.EMPTY.source,
          textureUniforms: {
            uTextureMatrix: { type: "mat3x3<f32>", value: new ae() },
          },
        },
      });
    }
    execute(e, t) {
      const a = e.renderer;
      let l = t._shader;
      if (l) {
        if (!l.glProgram) {
          pe("Mesh shader has no glProgram", t.shader);
          return;
        }
      } else {
        l = this._shader;
        const o = t.texture,
          h = o.source;
        (l.resources.uTexture = h),
          (l.resources.uSampler = h.style),
          (l.resources.textureUniforms.uniforms.uTextureMatrix =
            o.textureMatrix.mapCoord);
      }
      (l.groups[100] = a.globalUniforms.bindGroup),
        (l.groups[101] = e.localUniformsBindGroup),
        a.encoder.draw({ geometry: t._geometry, shader: l, state: t.state });
    }
    destroy() {
      this._shader.destroy(!0), (this._shader = null);
    }
  }
  Zp.extension = { type: [P.WebGLPipesAdaptor], name: "mesh" };
  class Qp {
    constructor(e) {
      this._renderer = e;
    }
    updateRenderable() { }
    destroyRenderable() { }
    validateRenderable() {
      return !1;
    }
    addRenderable(e, t) {
      this._renderer.renderPipes.batch.break(t), t.add(e);
    }
    execute(e) {
      e.isRenderable && e.render(this._renderer);
    }
    destroy() {
      this._renderer = null;
    }
  }
  Qp.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "customRender",
  };
  class Ao {
    constructor() {
      (this.batcherName = "default"),
        (this.topology = "triangle-list"),
        (this.attributeSize = 4),
        (this.indexSize = 6),
        (this.packAsQuad = !0),
        (this.roundPixels = 0),
        (this._attributeStart = 0),
        (this._batcher = null),
        (this._batch = null);
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    get color() {
      return this.renderable.groupColorAlpha;
    }
    reset() {
      (this.renderable = null),
        (this.texture = null),
        (this._batcher = null),
        (this._batch = null),
        (this.bounds = null);
    }
    destroy() { }
  }
  function nc(r, e) {
    const t = r.instructionSet,
      a = t.instructions;
    for (let l = 0; l < t.instructionSize; l++) {
      const o = a[l];
      e[o.renderPipeId].execute(o);
    }
  }
  const _b = new ae();
  class Jp {
    constructor(e) {
      this._renderer = e;
    }
    addRenderGroup(e, t) {
      e.isCachedAsTexture
        ? this._addRenderableCacheAsTexture(e, t)
        : this._addRenderableDirect(e, t);
    }
    execute(e) {
      e.isRenderable &&
        (e.isCachedAsTexture
          ? this._executeCacheAsTexture(e)
          : this._executeDirect(e));
    }
    destroy() {
      this._renderer = null;
    }
    _addRenderableDirect(e, t) {
      this._renderer.renderPipes.batch.break(t),
        e._batchableRenderGroup &&
        (Ot.return(e._batchableRenderGroup),
          (e._batchableRenderGroup = null)),
        t.add(e);
    }
    _addRenderableCacheAsTexture(e, t) {
      const a =
        e._batchableRenderGroup ?? (e._batchableRenderGroup = Ot.get(Ao));
      (a.renderable = e.root),
        (a.transform = e.root.relativeGroupTransform),
        (a.texture = e.texture),
        (a.bounds = e._textureBounds),
        t.add(e),
        this._renderer.renderPipes.blendMode.pushBlendMode(
          e,
          e.root.groupBlendMode,
          t
        ),
        this._renderer.renderPipes.batch.addToBatch(a, t),
        this._renderer.renderPipes.blendMode.popBlendMode(t);
    }
    _executeCacheAsTexture(e) {
      if (e.textureNeedsUpdate) {
        e.textureNeedsUpdate = !1;
        const t = _b
          .identity()
          .translate(-e._textureBounds.x, -e._textureBounds.y);
        this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame),
          this._renderer.globalUniforms.push({
            worldTransformMatrix: t,
            worldColor: 4294967295,
            offset: { x: 0, y: 0 },
          }),
          nc(e, this._renderer.renderPipes),
          this._renderer.renderTarget.finishRenderPass(),
          this._renderer.renderTarget.pop(),
          this._renderer.globalUniforms.pop();
      }
      e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup),
        e._batchableRenderGroup._batcher.geometry.buffers[0].update();
    }
    _executeDirect(e) {
      this._renderer.globalUniforms.push({
        worldTransformMatrix: e.inverseParentTextureTransform,
        worldColor: e.worldColorAlpha,
      }),
        nc(e, this._renderer.renderPipes),
        this._renderer.globalUniforms.pop();
    }
  }
  Jp.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "renderGroup",
  };
  function ac(r, e) {
    e || (e = 0);
    for (let t = e; t < r.length && r[t]; t++) r[t] = null;
  }
  const yb = new Ne(),
    eg = Rn | Za | Vl;
  function tg(r, e = !1) {
    xb(r);
    const t = r.childrenToUpdate,
      a = r.updateTick++;
    for (const l in t) {
      const o = Number(l),
        h = t[l],
        c = h.list,
        u = h.index;
      for (let d = 0; d < u; d++) {
        const f = c[d];
        f.parentRenderGroup === r &&
          f.relativeRenderGroupDepth === o &&
          sg(f, a, 0);
      }
      ac(c, u), (h.index = 0);
    }
    if (e)
      for (let l = 0; l < r.renderGroupChildren.length; l++)
        tg(r.renderGroupChildren[l], e);
  }
  function xb(r) {
    const e = r.root;
    let t;
    if (r.renderGroupParent) {
      const a = r.renderGroupParent;
      r.worldTransform.appendFrom(e.relativeGroupTransform, a.worldTransform),
        (r.worldColor = qa(e.groupColor, a.worldColor)),
        (t = e.groupAlpha * a.worldAlpha);
    } else
      r.worldTransform.copyFrom(e.localTransform),
        (r.worldColor = e.localColor),
        (t = e.localAlpha);
    (t = t < 0 ? 0 : t > 1 ? 1 : t),
      (r.worldAlpha = t),
      (r.worldColorAlpha = r.worldColor + (((t * 255) | 0) << 24));
  }
  function sg(r, e, t) {
    if (e === r.updateTick) return;
    (r.updateTick = e), (r.didChange = !1);
    const a = r.localTransform;
    r.updateLocalTransform();
    const l = r.parent;
    if (
      (l && !l.renderGroup
        ? ((t |= r._updateFlags),
          r.relativeGroupTransform.appendFrom(a, l.relativeGroupTransform),
          t & eg && ig(r, l, t))
        : ((t = r._updateFlags),
          r.relativeGroupTransform.copyFrom(a),
          t & eg && ig(r, yb, t)),
        !r.renderGroup)
    ) {
      const o = r.children,
        h = o.length;
      for (let d = 0; d < h; d++) sg(o[d], e, t);
      const c = r.parentRenderGroup,
        u = r;
      u.renderPipeId && !c.structureDidChange && c.updateRenderable(u);
    }
  }
  function ig(r, e, t) {
    if (t & Za) {
      r.groupColor = qa(r.localColor, e.groupColor);
      let a = r.localAlpha * e.groupAlpha;
      (a = a < 0 ? 0 : a > 1 ? 1 : a),
        (r.groupAlpha = a),
        (r.groupColorAlpha = r.groupColor + (((a * 255) | 0) << 24));
    }
    t & Vl &&
      (r.groupBlendMode =
        r.localBlendMode === "inherit" ? e.groupBlendMode : r.localBlendMode),
      t & Rn &&
      (r.globalDisplayStatus = r.localDisplayStatus & e.globalDisplayStatus),
      (r._updateFlags = 0);
  }
  function vb(r, e) {
    const { list: t, index: a } = r.childrenRenderablesToUpdate;
    let l = !1;
    for (let o = 0; o < a; o++) {
      const h = t[o];
      if (((l = e[h.renderPipeId].validateRenderable(h)), l)) break;
    }
    return (r.structureDidChange = l), l;
  }
  const bb = new ae();
  class rg {
    constructor(e) {
      this._renderer = e;
    }
    render({ container: e, transform: t }) {
      const a = e.parent,
        l = e.renderGroup.renderGroupParent;
      (e.parent = null), (e.renderGroup.renderGroupParent = null);
      const o = this._renderer,
        h = bb;
      t &&
        (h.copyFrom(e.renderGroup.localTransform),
          e.renderGroup.localTransform.copyFrom(t));
      const c = o.renderPipes;
      this._updateCachedRenderGroups(e.renderGroup, null),
        this._updateRenderGroups(e.renderGroup),
        o.globalUniforms.start({
          worldTransformMatrix: t
            ? e.renderGroup.localTransform
            : e.renderGroup.worldTransform,
          worldColor: e.renderGroup.worldColorAlpha,
        }),
        nc(e.renderGroup, c),
        c.uniformBatch && c.uniformBatch.renderEnd(),
        t && e.renderGroup.localTransform.copyFrom(h),
        (e.parent = a),
        (e.renderGroup.renderGroupParent = l);
    }
    destroy() {
      this._renderer = null;
    }
    _updateCachedRenderGroups(e, t) {
      if (((e._parentCacheAsTextureRenderGroup = t), e.isCachedAsTexture)) {
        if (!e.textureNeedsUpdate) return;
        t = e;
      }
      for (let a = e.renderGroupChildren.length - 1; a >= 0; a--)
        this._updateCachedRenderGroups(e.renderGroupChildren[a], t);
      if ((e.invalidateMatrices(), e.isCachedAsTexture)) {
        if (e.textureNeedsUpdate) {
          const a = e.root.getLocalBounds();
          a.ceil();
          const l = e.texture;
          e.texture && ss.returnTexture(e.texture, !0);
          const o = this._renderer,
            h = e.textureOptions.resolution || o.view.resolution,
            c = e.textureOptions.antialias ?? o.view.antialias,
            u = e.textureOptions.scaleMode ?? "linear",
            d = ss.getOptimalTexture(a.width, a.height, h, c);
          (d._source.style = new Pi({ scaleMode: u })),
            (e.texture = d),
            e._textureBounds || (e._textureBounds = new cs()),
            e._textureBounds.copyFrom(a),
            l !== e.texture &&
            e.renderGroupParent &&
            (e.renderGroupParent.structureDidChange = !0);
        }
      } else e.texture && (ss.returnTexture(e.texture, !0), (e.texture = null));
    }
    _updateRenderGroups(e) {
      const t = this._renderer,
        a = t.renderPipes;
      if (
        (e.runOnRender(t),
          (e.instructionSet.renderPipes = a),
          e.structureDidChange
            ? ac(e.childrenRenderablesToUpdate.list, 0)
            : vb(e, a),
          tg(e),
          e.structureDidChange
            ? ((e.structureDidChange = !1), this._buildInstructions(e, t))
            : this._updateRenderables(e),
          (e.childrenRenderablesToUpdate.index = 0),
          t.renderPipes.batch.upload(e.instructionSet),
          !(e.isCachedAsTexture && !e.textureNeedsUpdate))
      )
        for (let l = 0; l < e.renderGroupChildren.length; l++)
          this._updateRenderGroups(e.renderGroupChildren[l]);
    }
    _updateRenderables(e) {
      const { list: t, index: a } = e.childrenRenderablesToUpdate;
      for (let l = 0; l < a; l++) {
        const o = t[l];
        o.didViewUpdate && e.updateRenderable(o);
      }
      ac(t, a);
    }
    _buildInstructions(e, t) {
      const a = e.root,
        l = e.instructionSet;
      l.reset();
      const o = t.renderPipes ? t : t.batch.renderer,
        h = o.renderPipes;
      h.batch.buildStart(l),
        h.blendMode.buildStart(),
        h.colorMask.buildStart(),
        a.sortableChildren && a.sortChildren(),
        a.collectRenderablesWithEffects(l, o, null),
        h.batch.buildEnd(l),
        h.blendMode.buildEnd(l);
    }
  }
  rg.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "renderGroup",
  };
  class ng {
    constructor(e) {
      this._renderer = e;
    }
    addRenderable(e, t) {
      const a = this._getGpuSprite(e);
      e.didViewUpdate && this._updateBatchableSprite(e, a),
        this._renderer.renderPipes.batch.addToBatch(a, t);
    }
    updateRenderable(e) {
      const t = this._getGpuSprite(e);
      e.didViewUpdate && this._updateBatchableSprite(e, t),
        t._batcher.updateElement(t);
    }
    validateRenderable(e) {
      const t = this._getGpuSprite(e);
      return !t._batcher.checkAndUpdateTexture(t, e._texture);
    }
    _updateBatchableSprite(e, t) {
      (t.bounds = e.visualBounds), (t.texture = e._texture);
    }
    _getGpuSprite(e) {
      return e._gpuData[this._renderer.uid] || this._initGPUSprite(e);
    }
    _initGPUSprite(e) {
      const t = new Ao();
      return (
        (t.renderable = e),
        (t.transform = e.groupTransform),
        (t.texture = e._texture),
        (t.bounds = e.visualBounds),
        (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
        (e._gpuData[this._renderer.uid] = t),
        t
      );
    }
    destroy() {
      this._renderer = null;
    }
  }
  ng.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "sprite",
  };
  const oc = class h1 {
    constructor() {
      (this.clearBeforeRender = !0),
        (this._backgroundColor = new mt(0)),
        (this.color = this._backgroundColor),
        (this.alpha = 1);
    }
    init(e) {
      (e = { ...h1.defaultOptions, ...e }),
        (this.clearBeforeRender = e.clearBeforeRender),
        (this.color =
          e.background || e.backgroundColor || this._backgroundColor),
        (this.alpha = e.backgroundAlpha),
        this._backgroundColor.setAlpha(e.backgroundAlpha);
    }
    get color() {
      return this._backgroundColor;
    }
    set color(e) {
      mt.shared.setValue(e).alpha < 1 &&
        this._backgroundColor.alpha === 1 &&
        pe(
          "Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."
        ),
        this._backgroundColor.setValue(e);
    }
    get alpha() {
      return this._backgroundColor.alpha;
    }
    set alpha(e) {
      this._backgroundColor.setAlpha(e);
    }
    get colorRgba() {
      return this._backgroundColor.toArray();
    }
    destroy() { }
  };
  (oc.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "background",
    priority: 0,
  }),
    (oc.defaultOptions = {
      backgroundAlpha: 1,
      backgroundColor: 0,
      clearBeforeRender: !0,
    });
  let wb = oc;
  const na = {};
  ge.handle(
    P.BlendMode,
    (r) => {
      if (!r.name)
        throw new Error("BlendMode extension must have a name property");
      na[r.name] = r.ref;
    },
    (r) => {
      delete na[r.name];
    }
  );
  class ag {
    constructor(e) {
      (this._blendModeStack = []),
        (this._isAdvanced = !1),
        (this._filterHash = Object.create(null)),
        (this._renderer = e),
        this._renderer.runners.prerender.add(this);
    }
    prerender() {
      (this._activeBlendMode = "normal"), (this._isAdvanced = !1);
    }
    pushBlendMode(e, t, a) {
      this._blendModeStack.push(t), this.setBlendMode(e, t, a);
    }
    popBlendMode(e) {
      this._blendModeStack.pop();
      const t =
        this._blendModeStack[this._activeBlendMode.length - 1] ?? "normal";
      this.setBlendMode(null, t, e);
    }
    setBlendMode(e, t, a) {
      const l = e instanceof Hl;
      if (this._activeBlendMode === t) {
        this._isAdvanced && e && !l && this._renderableList?.push(e);
        return;
      }
      this._isAdvanced && this._endAdvancedBlendMode(a),
        (this._activeBlendMode = t),
        e &&
        ((this._isAdvanced = !!na[t]),
          this._isAdvanced && this._beginAdvancedBlendMode(e, a));
    }
    _beginAdvancedBlendMode(e, t) {
      this._renderer.renderPipes.batch.break(t);
      const a = this._activeBlendMode;
      if (!na[a]) {
        pe(
          `Unable to assign BlendMode: '${a}'. You may want to include: import 'pixi.js/advanced-blend-modes'`
        );
        return;
      }
      const l = this._ensureFilterEffect(a),
        o = e instanceof Hl,
        h = {
          renderPipeId: "filter",
          action: "pushFilter",
          filterEffect: l,
          renderables: o ? null : [e],
          container: o ? e.root : null,
          canBundle: !1,
        };
      (this._renderableList = h.renderables), t.add(h);
    }
    _ensureFilterEffect(e) {
      let t = this._filterHash[e];
      return (
        t ||
        ((t = this._filterHash[e] = new Xa()), (t.filters = [new na[e]()])),
        t
      );
    }
    _endAdvancedBlendMode(e) {
      (this._isAdvanced = !1),
        (this._renderableList = null),
        this._renderer.renderPipes.batch.break(e),
        e.add({ renderPipeId: "filter", action: "popFilter", canBundle: !1 });
    }
    buildStart() {
      this._isAdvanced = !1;
    }
    buildEnd(e) {
      this._isAdvanced && this._endAdvancedBlendMode(e);
    }
    destroy() {
      (this._renderer = null), (this._renderableList = null);
      for (const e in this._filterHash) this._filterHash[e].destroy();
      this._filterHash = null;
    }
  }
  ag.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "blendMode",
  };
  const lc = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" },
    hc = class c1 {
      constructor(e) {
        this._renderer = e;
      }
      _normalizeOptions(e, t = {}) {
        return e instanceof Ne || e instanceof te
          ? { target: e, ...t }
          : { ...t, ...e };
      }
      async image(e) {
        const t = xe.get().createImage();
        return (t.src = await this.base64(e)), t;
      }
      async base64(e) {
        e = this._normalizeOptions(e, c1.defaultImageOptions);
        const { format: t, quality: a } = e,
          l = this.canvas(e);
        if (l.toBlob !== void 0)
          return new Promise((o, h) => {
            l.toBlob(
              (c) => {
                if (!c) {
                  h(new Error("ICanvas.toBlob failed!"));
                  return;
                }
                const u = new FileReader();
                (u.onload = () => o(u.result)),
                  (u.onerror = h),
                  u.readAsDataURL(c);
              },
              lc[t],
              a
            );
          });
        if (l.toDataURL !== void 0) return l.toDataURL(lc[t], a);
        if (l.convertToBlob !== void 0) {
          const o = await l.convertToBlob({ type: lc[t], quality: a });
          return new Promise((h, c) => {
            const u = new FileReader();
            (u.onload = () => h(u.result)), (u.onerror = c), u.readAsDataURL(o);
          });
        }
        throw new Error(
          "Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented"
        );
      }
      canvas(e) {
        e = this._normalizeOptions(e);
        const t = e.target,
          a = this._renderer;
        if (t instanceof te) return a.texture.generateCanvas(t);
        const l = a.textureGenerator.generateTexture(e),
          o = a.texture.generateCanvas(l);
        return l.destroy(!0), o;
      }
      pixels(e) {
        e = this._normalizeOptions(e);
        const t = e.target,
          a = this._renderer,
          l = t instanceof te ? t : a.textureGenerator.generateTexture(e),
          o = a.texture.getPixels(l);
        return t instanceof Ne && l.destroy(!0), o;
      }
      texture(e) {
        return (
          (e = this._normalizeOptions(e)),
          e.target instanceof te
            ? e.target
            : this._renderer.textureGenerator.generateTexture(e)
        );
      }
      download(e) {
        e = this._normalizeOptions(e);
        const t = this.canvas(e),
          a = document.createElement("a");
        (a.download = e.filename ?? "image.png"),
          (a.href = t.toDataURL("image/png")),
          document.body.appendChild(a),
          a.click(),
          document.body.removeChild(a);
      }
      log(e) {
      }
      destroy() {
        this._renderer = null;
      }
    };
  (hc.extension = { type: [P.WebGLSystem, P.WebGPUSystem], name: "extract" }),
    (hc.defaultImageOptions = { format: "png", quality: 1 });
  let Sb = hc;
  class cc extends te {
    static create(e) {
      return new cc({ source: new zt(e) });
    }
    resize(e, t, a) {
      return this.source.resize(e, t, a), this;
    }
  }
  const Mb = new Le(),
    Tb = new cs(),
    Cb = [0, 0, 0, 0];
  class og {
    constructor(e) {
      this._renderer = e;
    }
    generateTexture(e) {
      e instanceof Ne &&
        (e = {
          target: e,
          frame: void 0,
          textureSourceOptions: {},
          resolution: void 0,
        });
      const t = e.resolution || this._renderer.resolution,
        a = e.antialias || this._renderer.view.antialias,
        l = e.target;
      let o = e.clearColor;
      o
        ? (o =
          Array.isArray(o) && o.length === 4
            ? o
            : mt.shared.setValue(o).toArray())
        : (o = Cb);
      const h = e.frame?.copyTo(Mb) || Nl(l, Tb).rectangle;
      (h.width = Math.max(h.width, 1 / t) | 0),
        (h.height = Math.max(h.height, 1 / t) | 0);
      const c = cc.create({
        ...e.textureSourceOptions,
        width: h.width,
        height: h.height,
        resolution: t,
        antialias: a,
      }),
        u = ae.shared.translate(-h.x, -h.y);
      return (
        this._renderer.render({
          container: l,
          transform: u,
          target: c,
          clearColor: o,
        }),
        c.source.updateMipmaps(),
        c
      );
    }
    destroy() {
      this._renderer = null;
    }
  }
  og.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem],
    name: "textureGenerator",
  };
  function aa(r, e, t) {
    const a = ((r >> 24) & 255) / 255;
    (e[t++] = ((r & 255) / 255) * a),
      (e[t++] = (((r >> 8) & 255) / 255) * a),
      (e[t++] = (((r >> 16) & 255) / 255) * a),
      (e[t++] = a);
  }
  class lg {
    constructor(e) {
      (this._stackIndex = 0),
        (this._globalUniformDataStack = []),
        (this._uniformsPool = []),
        (this._activeUniforms = []),
        (this._bindGroupPool = []),
        (this._activeBindGroups = []),
        (this._renderer = e);
    }
    reset() {
      this._stackIndex = 0;
      for (let e = 0; e < this._activeUniforms.length; e++)
        this._uniformsPool.push(this._activeUniforms[e]);
      for (let e = 0; e < this._activeBindGroups.length; e++)
        this._bindGroupPool.push(this._activeBindGroups[e]);
      (this._activeUniforms.length = 0), (this._activeBindGroups.length = 0);
    }
    start(e) {
      this.reset(), this.push(e);
    }
    bind({
      size: e,
      projectionMatrix: t,
      worldTransformMatrix: a,
      worldColor: l,
      offset: o,
    }) {
      const h = this._renderer.renderTarget.renderTarget,
        c = this._stackIndex
          ? this._globalUniformDataStack[this._stackIndex - 1]
          : {
            worldTransformMatrix: new ae(),
            worldColor: 4294967295,
            offset: new Je(),
          },
        u = {
          projectionMatrix: t || this._renderer.renderTarget.projectionMatrix,
          resolution: e || h.size,
          worldTransformMatrix: a || c.worldTransformMatrix,
          worldColor: l || c.worldColor,
          offset: o || c.offset,
          bindGroup: null,
        },
        d = this._uniformsPool.pop() || this._createUniforms();
      this._activeUniforms.push(d);
      const f = d.uniforms;
      (f.uProjectionMatrix = u.projectionMatrix),
        (f.uResolution = u.resolution),
        f.uWorldTransformMatrix.copyFrom(u.worldTransformMatrix),
        (f.uWorldTransformMatrix.tx -= u.offset.x),
        (f.uWorldTransformMatrix.ty -= u.offset.y),
        aa(u.worldColor, f.uWorldColorAlpha, 0),
        d.update();
      let p;
      this._renderer.renderPipes.uniformBatch
        ? (p = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(
          d,
          !1
        ))
        : ((p = this._bindGroupPool.pop() || new qi()),
          this._activeBindGroups.push(p),
          p.setResource(d, 0)),
        (u.bindGroup = p),
        (this._currentGlobalUniformData = u);
    }
    push(e) {
      this.bind(e),
        (this._globalUniformDataStack[this._stackIndex++] =
          this._currentGlobalUniformData);
    }
    pop() {
      (this._currentGlobalUniformData =
        this._globalUniformDataStack[--this._stackIndex - 1]),
        this._renderer.type === pi.WEBGL &&
        this._currentGlobalUniformData.bindGroup.resources[0].update();
    }
    get bindGroup() {
      return this._currentGlobalUniformData.bindGroup;
    }
    get globalUniformData() {
      return this._currentGlobalUniformData;
    }
    get uniformGroup() {
      return this._currentGlobalUniformData.bindGroup.resources[0];
    }
    _createUniforms() {
      return new ys(
        {
          uProjectionMatrix: { value: new ae(), type: "mat3x3<f32>" },
          uWorldTransformMatrix: { value: new ae(), type: "mat3x3<f32>" },
          uWorldColorAlpha: { value: new Float32Array(4), type: "vec4<f32>" },
          uResolution: { value: [0, 0], type: "vec2<f32>" },
        },
        { isStatic: !0 }
      );
    }
    destroy() {
      (this._renderer = null),
        (this._globalUniformDataStack.length = 0),
        (this._uniformsPool.length = 0),
        (this._activeUniforms.length = 0),
        (this._bindGroupPool.length = 0),
        (this._activeBindGroups.length = 0),
        (this._currentGlobalUniformData = null);
    }
  }
  lg.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "globalUniforms",
  };
  let Ab = 1;
  class hg {
    constructor() {
      (this._tasks = []), (this._offset = 0);
    }
    init() {
      Js.system.add(this._update, this);
    }
    repeat(e, t, a = !0) {
      const l = Ab++;
      let o = 0;
      return (
        a && ((this._offset += 1e3), (o = this._offset)),
        this._tasks.push({
          func: e,
          duration: t,
          start: performance.now(),
          offset: o,
          last: performance.now(),
          repeat: !0,
          id: l,
        }),
        l
      );
    }
    cancel(e) {
      for (let t = 0; t < this._tasks.length; t++)
        if (this._tasks[t].id === e) {
          this._tasks.splice(t, 1);
          return;
        }
    }
    _update() {
      const e = performance.now();
      for (let t = 0; t < this._tasks.length; t++) {
        const a = this._tasks[t];
        if (e - a.offset - a.last >= a.duration) {
          const l = e - a.start;
          a.func(l), (a.last = e);
        }
      }
    }
    destroy() {
      Js.system.remove(this._update, this), (this._tasks.length = 0);
    }
  }
  hg.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "scheduler",
    priority: 0,
  };
  let cg = !1;
  function dg(r) {
    cg = !0;
  }
  class dc {
    constructor(e) {
      this._renderer = e;
    }
    init(e) {
      if (e.hello) {
        let t = this._renderer.name;
        this._renderer.type === pi.WEBGL &&
          (t += ` ${this._renderer.context.webGLVersion}`),
          dg(t);
      }
    }
  }
  (dc.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "hello",
    priority: -2,
  }),
    (dc.defaultOptions = { hello: !1 });
  function Pb(r) {
    let e = !1;
    for (const a in r)
      if (r[a] == null) {
        e = !0;
        break;
      }
    if (!e) return r;
    const t = Object.create(null);
    for (const a in r) {
      const l = r[a];
      l && (t[a] = l);
    }
    return t;
  }
  function Eb(r) {
    let e = 0;
    for (let t = 0; t < r.length; t++) r[t] == null ? e++ : (r[t - e] = r[t]);
    return (r.length -= e), r;
  }
  let kb = 0;
  const uc = class d1 {
    constructor(e) {
      (this._managedRenderables = []),
        (this._managedHashes = []),
        (this._managedArrays = []),
        (this._renderer = e);
    }
    init(e) {
      (e = { ...d1.defaultOptions, ...e }),
        (this.maxUnusedTime = e.renderableGCMaxUnusedTime),
        (this._frequency = e.renderableGCFrequency),
        (this.enabled = e.renderableGCActive);
    }
    get enabled() {
      return !!this._handler;
    }
    set enabled(e) {
      this.enabled !== e &&
        (e
          ? ((this._handler = this._renderer.scheduler.repeat(
            () => this.run(),
            this._frequency,
            !1
          )),
            (this._hashHandler = this._renderer.scheduler.repeat(() => {
              for (const t of this._managedHashes)
                t.context[t.hash] = Pb(t.context[t.hash]);
            }, this._frequency)),
            (this._arrayHandler = this._renderer.scheduler.repeat(() => {
              for (const t of this._managedArrays) Eb(t.context[t.hash]);
            }, this._frequency)))
          : (this._renderer.scheduler.cancel(this._handler),
            this._renderer.scheduler.cancel(this._hashHandler),
            this._renderer.scheduler.cancel(this._arrayHandler)));
    }
    addManagedHash(e, t) {
      this._managedHashes.push({ context: e, hash: t });
    }
    addManagedArray(e, t) {
      this._managedArrays.push({ context: e, hash: t });
    }
    prerender({ container: e }) {
      (this._now = performance.now()),
        (e.renderGroup.gcTick = kb++),
        this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick);
    }
    addRenderable(e) {
      this.enabled &&
        (e._lastUsed === -1 &&
          (this._managedRenderables.push(e),
            e.once("destroyed", this._removeRenderable, this)),
          (e._lastUsed = this._now));
    }
    run() {
      const e = this._now,
        t = this._managedRenderables,
        a = this._renderer.renderPipes;
      let l = 0;
      for (let o = 0; o < t.length; o++) {
        const h = t[o];
        if (h === null) {
          l++;
          continue;
        }
        const c = h.renderGroup ?? h.parentRenderGroup,
          u = c?.instructionSet?.gcTick ?? -1;
        if (
          ((c?.gcTick ?? 0) === u && (h._lastUsed = e),
            e - h._lastUsed > this.maxUnusedTime)
        ) {
          if (!h.destroyed) {
            const d = a;
            c && (c.structureDidChange = !0),
              d[h.renderPipeId].destroyRenderable(h);
          }
          (h._lastUsed = -1),
            l++,
            h.off("destroyed", this._removeRenderable, this);
        } else t[o - l] = h;
      }
      t.length -= l;
    }
    destroy() {
      (this.enabled = !1),
        (this._renderer = null),
        (this._managedRenderables.length = 0),
        (this._managedHashes.length = 0),
        (this._managedArrays.length = 0);
    }
    _removeRenderable(e) {
      const t = this._managedRenderables.indexOf(e);
      t >= 0 &&
        (e.off("destroyed", this._removeRenderable, this),
          (this._managedRenderables[t] = null));
    }
    _updateInstructionGCTick(e, t) {
      e.instructionSet.gcTick = t;
      for (const a of e.renderGroupChildren)
        this._updateInstructionGCTick(a, t);
    }
  };
  (uc.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem],
    name: "renderableGC",
    priority: 0,
  }),
    (uc.defaultOptions = {
      renderableGCActive: !0,
      renderableGCMaxUnusedTime: 6e4,
      renderableGCFrequency: 3e4,
    });
  let Rb = uc;
  const fc = class u1 {
    constructor(e) {
      (this._renderer = e), (this.count = 0), (this.checkCount = 0);
    }
    init(e) {
      (e = { ...u1.defaultOptions, ...e }),
        (this.checkCountMax = e.textureGCCheckCountMax),
        (this.maxIdle = e.textureGCAMaxIdle ?? e.textureGCMaxIdle),
        (this.active = e.textureGCActive);
    }
    postrender() {
      this._renderer.renderingToScreen &&
        (this.count++,
          this.active &&
          (this.checkCount++,
            this.checkCount > this.checkCountMax &&
            ((this.checkCount = 0), this.run())));
    }
    run() {
      const e = this._renderer.texture.managedTextures;
      for (let t = 0; t < e.length; t++) {
        const a = e[t];
        a.autoGarbageCollect &&
          a.resource &&
          a._touched > -1 &&
          this.count - a._touched > this.maxIdle &&
          ((a._touched = -1), a.unload());
      }
    }
    destroy() {
      this._renderer = null;
    }
  };
  (fc.extension = { type: [P.WebGLSystem, P.WebGPUSystem], name: "textureGC" }),
    (fc.defaultOptions = {
      textureGCActive: !0,
      textureGCAMaxIdle: null,
      textureGCMaxIdle: 3600,
      textureGCCheckCountMax: 600,
    });
  let Ib = fc;
  const pc = class f1 {
    get autoDensity() {
      return this.texture.source.autoDensity;
    }
    set autoDensity(e) {
      this.texture.source.autoDensity = e;
    }
    get resolution() {
      return this.texture.source._resolution;
    }
    set resolution(e) {
      this.texture.source.resize(
        this.texture.source.width,
        this.texture.source.height,
        e
      );
    }
    init(e) {
      (e = { ...f1.defaultOptions, ...e }),
        e.view &&
        (me(Ie, "ViewSystem.view has been renamed to ViewSystem.canvas"),
          (e.canvas = e.view)),
        (this.screen = new Le(0, 0, e.width, e.height)),
        (this.canvas = e.canvas || xe.get().createCanvas()),
        (this.antialias = !!e.antialias),
        (this.texture = Fp(this.canvas, e)),
        (this.renderTarget = new tc({
          colorTextures: [this.texture],
          depth: !!e.depth,
          isRoot: !0,
        })),
        (this.texture.source.transparent = e.backgroundAlpha < 1),
        (this.resolution = e.resolution);
    }
    resize(e, t, a) {
      this.texture.source.resize(e, t, a),
        (this.screen.width = this.texture.frame.width),
        (this.screen.height = this.texture.frame.height);
    }
    destroy(e = !1) {
      (typeof e == "boolean" ? e : !!e?.removeView) &&
        this.canvas.parentNode &&
        this.canvas.parentNode.removeChild(this.canvas),
        this.texture.destroy();
    }
  };
  (pc.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "view",
    priority: 0,
  }),
    (pc.defaultOptions = {
      width: 800,
      height: 600,
      autoDensity: !1,
      antialias: !1,
    });
  const ug = [wb, lg, dc, pc, rg, Ib, og, Sb, Wu, Rb, hg],
    fg = [ag, mp, ng, Jp, _p, xp, yp, Qp],
    Bb = [...ug, Bp, Rv, Cv, Ap, vp, $p, Up, Mp, Vp, Wp, Cp, nb, Pp, Tp],
    Fb = [...fg],
    Gb = [pp, Zp, Kp],
    pg = [],
    gg = [],
    mg = [];
  ge.handleByNamedList(P.WebGLSystem, pg),
    ge.handleByNamedList(P.WebGLPipes, gg),
    ge.handleByNamedList(P.WebGLPipesAdaptor, mg),
    ge.add(...Bb, ...Fb, ...Gb);
  class Db extends ao {
    constructor() {
      const e = {
        name: "webgl",
        type: pi.WEBGL,
        systems: pg,
        renderPipes: gg,
        renderPipeAdaptors: mg,
      };
      super(e);
    }
  }
  const Ub = Object.freeze(
    Object.defineProperty(
      { __proto__: null, WebGLRenderer: Db },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  class _g {
    constructor(e) {
      (this._hash = Object.create(null)),
        (this._renderer = e),
        this._renderer.renderableGC.addManagedHash(this, "_hash");
    }
    contextChange(e) {
      this._gpu = e;
    }
    getBindGroup(e, t, a) {
      return (
        e._updateKey(), this._hash[e._key] || this._createBindGroup(e, t, a)
      );
    }
    _createBindGroup(e, t, a) {
      const l = this._gpu.device,
        o = t.layout[a],
        h = [],
        c = this._renderer;
      for (const f in o) {
        const p = e.resources[f] ?? e.resources[o[f]];
        let g;
        if (p._resourceType === "uniformGroup") {
          const _ = p;
          c.ubo.updateUniformGroup(_);
          const m = _.buffer;
          g = {
            buffer: c.buffer.getGPUBuffer(m),
            offset: 0,
            size: m.descriptor.size,
          };
        } else if (p._resourceType === "buffer") {
          const _ = p;
          g = {
            buffer: c.buffer.getGPUBuffer(_),
            offset: 0,
            size: _.descriptor.size,
          };
        } else if (p._resourceType === "bufferResource") {
          const _ = p;
          g = {
            buffer: c.buffer.getGPUBuffer(_.buffer),
            offset: _.offset,
            size: _.size,
          };
        } else if (p._resourceType === "textureSampler") {
          const _ = p;
          g = c.texture.getGpuSampler(_);
        } else if (p._resourceType === "textureSource") {
          const _ = p;
          g = c.texture.getGpuSource(_).createView({});
        }
        h.push({ binding: o[f], resource: g });
      }
      const u = c.shader.getProgramData(t).bindGroups[a],
        d = l.createBindGroup({ layout: u, entries: h });
      return (this._hash[e._key] = d), d;
    }
    destroy() {
      for (const e of Object.keys(this._hash)) this._hash[e] = null;
      (this._hash = null), (this._renderer = null);
    }
  }
  _g.extension = { type: [P.WebGPUSystem], name: "bindGroup" };
  class yg {
    constructor(e) {
      (this._gpuBuffers = Object.create(null)),
        (this._managedBuffers = []),
        e.renderableGC.addManagedHash(this, "_gpuBuffers");
    }
    contextChange(e) {
      this._gpu = e;
    }
    getGPUBuffer(e) {
      return this._gpuBuffers[e.uid] || this.createGPUBuffer(e);
    }
    updateBuffer(e) {
      const t = this._gpuBuffers[e.uid] || this.createGPUBuffer(e),
        a = e.data;
      return (
        e._updateID &&
        a &&
        ((e._updateID = 0),
          this._gpu.device.queue.writeBuffer(
            t,
            0,
            a.buffer,
            0,
            ((e._updateSize || a.byteLength) + 3) & -4
          )),
        t
      );
    }
    destroyAll() {
      for (const e in this._gpuBuffers) this._gpuBuffers[e].destroy();
      this._gpuBuffers = {};
    }
    createGPUBuffer(e) {
      this._gpuBuffers[e.uid] ||
        (e.on("update", this.updateBuffer, this),
          e.on("change", this.onBufferChange, this),
          e.on("destroy", this.onBufferDestroy, this),
          this._managedBuffers.push(e));
      const t = this._gpu.device.createBuffer(e.descriptor);
      return (
        (e._updateID = 0),
        e.data && (vh(e.data.buffer, t.getMappedRange()), t.unmap()),
        (this._gpuBuffers[e.uid] = t),
        t
      );
    }
    onBufferChange(e) {
      this._gpuBuffers[e.uid].destroy(),
        (e._updateID = 0),
        (this._gpuBuffers[e.uid] = this.createGPUBuffer(e));
    }
    onBufferDestroy(e) {
      this._managedBuffers.splice(this._managedBuffers.indexOf(e), 1),
        this._destroyBuffer(e);
    }
    destroy() {
      this._managedBuffers.forEach((e) => this._destroyBuffer(e)),
        (this._managedBuffers = null),
        (this._gpuBuffers = null);
    }
    _destroyBuffer(e) {
      this._gpuBuffers[e.uid].destroy(),
        e.off("update", this.updateBuffer, this),
        e.off("change", this.onBufferChange, this),
        e.off("destroy", this.onBufferDestroy, this),
        (this._gpuBuffers[e.uid] = null);
    }
  }
  yg.extension = { type: [P.WebGPUSystem], name: "buffer" };
  class Ob {
    constructor({ minUniformOffsetAlignment: e }) {
      (this._minUniformOffsetAlignment = 256),
        (this.byteIndex = 0),
        (this._minUniformOffsetAlignment = e),
        (this.data = new Float32Array(65535));
    }
    clear() {
      this.byteIndex = 0;
    }
    addEmptyGroup(e) {
      if (e > this._minUniformOffsetAlignment / 4)
        throw new Error(`UniformBufferBatch: array is too large: ${e * 4}`);
      const t = this.byteIndex;
      let a = t + e * 4;
      if (
        ((a =
          Math.ceil(a / this._minUniformOffsetAlignment) *
          this._minUniformOffsetAlignment),
          a > this.data.length * 4)
      )
        throw new Error("UniformBufferBatch: ubo batch got too big");
      return (this.byteIndex = a), t;
    }
    addGroup(e) {
      const t = this.addEmptyGroup(e.length);
      for (let a = 0; a < e.length; a++) this.data[t / 4 + a] = e[a];
      return t;
    }
    destroy() {
      this.data = null;
    }
  }
  class xg {
    constructor(e) {
      (this._colorMaskCache = 15), (this._renderer = e);
    }
    setMask(e) {
      this._colorMaskCache !== e &&
        ((this._colorMaskCache = e), this._renderer.pipeline.setColorMask(e));
    }
    destroy() {
      (this._renderer = null), (this._colorMaskCache = null);
    }
  }
  xg.extension = { type: [P.WebGPUSystem], name: "colorMask" };
  class gc {
    constructor(e) {
      this._renderer = e;
    }
    async init(e) {
      return this._initPromise
        ? this._initPromise
        : ((this._initPromise = (
          e.gpu ? Promise.resolve(e.gpu) : this._createDeviceAndAdaptor(e)
        ).then((t) => {
          (this.gpu = t), this._renderer.runners.contextChange.emit(this.gpu);
        })),
          this._initPromise);
    }
    contextChange(e) {
      this._renderer.gpu = e;
    }
    async _createDeviceAndAdaptor(e) {
      const t = await xe
        .get()
        .getNavigator()
        .gpu.requestAdapter({
          powerPreference: e.powerPreference,
          forceFallbackAdapter: e.forceFallbackAdapter,
        }),
        a = [
          "texture-compression-bc",
          "texture-compression-astc",
          "texture-compression-etc2",
        ].filter((o) => t.features.has(o)),
        l = await t.requestDevice({ requiredFeatures: a });
      return { adapter: t, device: l };
    }
    destroy() {
      (this.gpu = null), (this._renderer = null);
    }
  }
  (gc.extension = { type: [P.WebGPUSystem], name: "device" }),
    (gc.defaultOptions = { powerPreference: void 0, forceFallbackAdapter: !1 });
  class vg {
    constructor(e) {
      (this._boundBindGroup = Object.create(null)),
        (this._boundVertexBuffer = Object.create(null)),
        (this._renderer = e);
    }
    renderStart() {
      (this.commandFinished = new Promise((e) => {
        this._resolveCommandFinished = e;
      })),
        (this.commandEncoder =
          this._renderer.gpu.device.createCommandEncoder());
    }
    beginRenderPass(e) {
      this.endRenderPass(),
        this._clearCache(),
        (this.renderPassEncoder = this.commandEncoder.beginRenderPass(
          e.descriptor
        ));
    }
    endRenderPass() {
      this.renderPassEncoder && this.renderPassEncoder.end(),
        (this.renderPassEncoder = null);
    }
    setViewport(e) {
      this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1);
    }
    setPipelineFromGeometryProgramAndState(e, t, a, l) {
      const o = this._renderer.pipeline.getPipeline(e, t, a, l);
      this.setPipeline(o);
    }
    setPipeline(e) {
      this._boundPipeline !== e &&
        ((this._boundPipeline = e), this.renderPassEncoder.setPipeline(e));
    }
    _setVertexBuffer(e, t) {
      this._boundVertexBuffer[e] !== t &&
        ((this._boundVertexBuffer[e] = t),
          this.renderPassEncoder.setVertexBuffer(
            e,
            this._renderer.buffer.updateBuffer(t)
          ));
    }
    _setIndexBuffer(e) {
      if (this._boundIndexBuffer === e) return;
      this._boundIndexBuffer = e;
      const t = e.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
      this.renderPassEncoder.setIndexBuffer(
        this._renderer.buffer.updateBuffer(e),
        t
      );
    }
    resetBindGroup(e) {
      this._boundBindGroup[e] = null;
    }
    setBindGroup(e, t, a) {
      if (this._boundBindGroup[e] === t) return;
      (this._boundBindGroup[e] = t), t._touch(this._renderer.textureGC.count);
      const l = this._renderer.bindGroup.getBindGroup(t, a, e);
      this.renderPassEncoder.setBindGroup(e, l);
    }
    setGeometry(e, t) {
      const a = this._renderer.pipeline.getBufferNamesToBind(e, t);
      for (const l in a)
        this._setVertexBuffer(parseInt(l, 10), e.attributes[a[l]].buffer);
      e.indexBuffer && this._setIndexBuffer(e.indexBuffer);
    }
    _setShaderBindGroups(e, t) {
      for (const a in e.groups) {
        const l = e.groups[a];
        t || this._syncBindGroup(l), this.setBindGroup(a, l, e.gpuProgram);
      }
    }
    _syncBindGroup(e) {
      for (const t in e.resources) {
        const a = e.resources[t];
        a.isUniformGroup && this._renderer.ubo.updateUniformGroup(a);
      }
    }
    draw(e) {
      const {
        geometry: t,
        shader: a,
        state: l,
        topology: o,
        size: h,
        start: c,
        instanceCount: u,
        skipSync: d,
      } = e;
      this.setPipelineFromGeometryProgramAndState(t, a.gpuProgram, l, o),
        this.setGeometry(t, a.gpuProgram),
        this._setShaderBindGroups(a, d),
        t.indexBuffer
          ? this.renderPassEncoder.drawIndexed(
            h || t.indexBuffer.data.length,
            u ?? t.instanceCount,
            c || 0
          )
          : this.renderPassEncoder.draw(
            h || t.getSize(),
            u ?? t.instanceCount,
            c || 0
          );
    }
    finishRenderPass() {
      this.renderPassEncoder &&
        (this.renderPassEncoder.end(), (this.renderPassEncoder = null));
    }
    postrender() {
      this.finishRenderPass(),
        this._gpu.device.queue.submit([this.commandEncoder.finish()]),
        this._resolveCommandFinished(),
        (this.commandEncoder = null);
    }
    restoreRenderPass() {
      const e = this._renderer.renderTarget.adaptor.getDescriptor(
        this._renderer.renderTarget.renderTarget,
        !1,
        [0, 0, 0, 1]
      );
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(e);
      const t = this._boundPipeline,
        a = { ...this._boundVertexBuffer },
        l = this._boundIndexBuffer,
        o = { ...this._boundBindGroup };
      this._clearCache();
      const h = this._renderer.renderTarget.viewport;
      this.renderPassEncoder.setViewport(h.x, h.y, h.width, h.height, 0, 1),
        this.setPipeline(t);
      for (const c in a) this._setVertexBuffer(c, a[c]);
      for (const c in o) this.setBindGroup(c, o[c], null);
      this._setIndexBuffer(l);
    }
    _clearCache() {
      for (let e = 0; e < 16; e++)
        (this._boundBindGroup[e] = null), (this._boundVertexBuffer[e] = null);
      (this._boundIndexBuffer = null), (this._boundPipeline = null);
    }
    destroy() {
      (this._renderer = null),
        (this._gpu = null),
        (this._boundBindGroup = null),
        (this._boundVertexBuffer = null),
        (this._boundIndexBuffer = null),
        (this._boundPipeline = null);
    }
    contextChange(e) {
      this._gpu = e;
    }
  }
  vg.extension = { type: [P.WebGPUSystem], name: "encoder", priority: 1 };
  class bg {
    constructor(e) {
      this._renderer = e;
    }
    contextChange() {
      (this.maxTextures =
        this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage),
        (this.maxBatchableTextures = this.maxTextures);
    }
    destroy() { }
  }
  bg.extension = { type: [P.WebGPUSystem], name: "limits" };
  class wg {
    constructor(e) {
      (this._renderTargetStencilState = Object.create(null)),
        (this._renderer = e),
        e.renderTarget.onRenderTargetChange.add(this);
    }
    onRenderTargetChange(e) {
      let t = this._renderTargetStencilState[e.uid];
      t ||
        (t = this._renderTargetStencilState[e.uid] =
          { stencilMode: Ft.DISABLED, stencilReference: 0 }),
        (this._activeRenderTarget = e),
        this.setStencilMode(t.stencilMode, t.stencilReference);
    }
    setStencilMode(e, t) {
      const a = this._renderTargetStencilState[this._activeRenderTarget.uid];
      (a.stencilMode = e), (a.stencilReference = t);
      const l = this._renderer;
      l.pipeline.setStencilMode(e),
        l.encoder.renderPassEncoder.setStencilReference(t);
    }
    destroy() {
      this._renderer.renderTarget.onRenderTargetChange.remove(this),
        (this._renderer = null),
        (this._activeRenderTarget = null),
        (this._renderTargetStencilState = null);
    }
  }
  wg.extension = { type: [P.WebGPUSystem], name: "stencil" };
  const Po = {
    i32: { align: 4, size: 4 },
    u32: { align: 4, size: 4 },
    f32: { align: 4, size: 4 },
    f16: { align: 2, size: 2 },
    "vec2<i32>": { align: 8, size: 8 },
    "vec2<u32>": { align: 8, size: 8 },
    "vec2<f32>": { align: 8, size: 8 },
    "vec2<f16>": { align: 4, size: 4 },
    "vec3<i32>": { align: 16, size: 12 },
    "vec3<u32>": { align: 16, size: 12 },
    "vec3<f32>": { align: 16, size: 12 },
    "vec3<f16>": { align: 8, size: 6 },
    "vec4<i32>": { align: 16, size: 16 },
    "vec4<u32>": { align: 16, size: 16 },
    "vec4<f32>": { align: 16, size: 16 },
    "vec4<f16>": { align: 8, size: 8 },
    "mat2x2<f32>": { align: 8, size: 16 },
    "mat2x2<f16>": { align: 4, size: 8 },
    "mat3x2<f32>": { align: 8, size: 24 },
    "mat3x2<f16>": { align: 4, size: 12 },
    "mat4x2<f32>": { align: 8, size: 32 },
    "mat4x2<f16>": { align: 4, size: 16 },
    "mat2x3<f32>": { align: 16, size: 32 },
    "mat2x3<f16>": { align: 8, size: 16 },
    "mat3x3<f32>": { align: 16, size: 48 },
    "mat3x3<f16>": { align: 8, size: 24 },
    "mat4x3<f32>": { align: 16, size: 64 },
    "mat4x3<f16>": { align: 8, size: 32 },
    "mat2x4<f32>": { align: 16, size: 32 },
    "mat2x4<f16>": { align: 8, size: 16 },
    "mat3x4<f32>": { align: 16, size: 48 },
    "mat3x4<f16>": { align: 8, size: 24 },
    "mat4x4<f32>": { align: 16, size: 64 },
    "mat4x4<f16>": { align: 8, size: 32 },
  };
  function Lb(r) {
    const e = r.map((a) => ({ data: a, offset: 0, size: 0 }));
    let t = 0;
    for (let a = 0; a < e.length; a++) {
      const l = e[a];
      let o = Po[l.data.type].size;
      const h = Po[l.data.type].align;
      if (!Po[l.data.type])
        throw new Error(
          `[Pixi.js] WebGPU UniformBuffer: Unknown type ${l.data.type}`
        );
      l.data.size > 1 && (o = Math.max(o, h) * l.data.size),
        (t = Math.ceil(t / h) * h),
        (l.size = o),
        (l.offset = t),
        (t += o);
    }
    return (t = Math.ceil(t / 16) * 16), { uboElements: e, size: t };
  }
  function Nb(r, e) {
    const { size: t, align: a } = Po[r.data.type],
      l = (a - t) / 4,
      o = r.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
         v = uv.${r.data.name};
         ${e !== 0 ? `offset += ${e};` : ""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${r.data.size * (t / 4)}; i++)
         {
             for(var j = 0; j < ${t / 4}; j++)
             {
                 ${o}[arrayOffset++] = v[t++];
             }
             ${l !== 0 ? `arrayOffset += ${l};` : ""}
         }
     `;
  }
  function Hb(r) {
    return Rp(r, "uboWgsl", Nb, Fv);
  }
  class Sg extends Ep {
    constructor() {
      super({ createUboElements: Lb, generateUboSync: Hb });
    }
  }
  Sg.extension = { type: [P.WebGPUSystem], name: "ubo" };
  const dr = 128;
  class Mg {
    constructor(e) {
      (this._bindGroupHash = Object.create(null)),
        (this._buffers = []),
        (this._bindGroups = []),
        (this._bufferResources = []),
        (this._renderer = e),
        this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"),
        (this._batchBuffer = new Ob({ minUniformOffsetAlignment: dr }));
      const t = 256 / dr;
      for (let a = 0; a < t; a++) {
        let l = Fe.UNIFORM | Fe.COPY_DST;
        a === 0 && (l |= Fe.COPY_SRC),
          this._buffers.push(
            new Hs({ data: this._batchBuffer.data, usage: l })
          );
      }
    }
    renderEnd() {
      this._uploadBindGroups(), this._resetBindGroups();
    }
    _resetBindGroups() {
      for (const e in this._bindGroupHash) this._bindGroupHash[e] = null;
      this._batchBuffer.clear();
    }
    getUniformBindGroup(e, t) {
      if (!t && this._bindGroupHash[e.uid]) return this._bindGroupHash[e.uid];
      this._renderer.ubo.ensureUniformGroup(e);
      const a = e.buffer.data,
        l = this._batchBuffer.addEmptyGroup(a.length);
      return (
        this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, l / 4),
        (this._bindGroupHash[e.uid] = this._getBindGroup(l / dr)),
        this._bindGroupHash[e.uid]
      );
    }
    getUboResource(e) {
      this._renderer.ubo.updateUniformGroup(e);
      const t = e.buffer.data,
        a = this._batchBuffer.addGroup(t);
      return this._getBufferResource(a / dr);
    }
    getArrayBindGroup(e) {
      const t = this._batchBuffer.addGroup(e);
      return this._getBindGroup(t / dr);
    }
    getArrayBufferResource(e) {
      const a = this._batchBuffer.addGroup(e) / dr;
      return this._getBufferResource(a);
    }
    _getBufferResource(e) {
      if (!this._bufferResources[e]) {
        const t = this._buffers[e % 2];
        this._bufferResources[e] = new sc({
          buffer: t,
          offset: ((e / 2) | 0) * 256,
          size: dr,
        });
      }
      return this._bufferResources[e];
    }
    _getBindGroup(e) {
      if (!this._bindGroups[e]) {
        const t = new qi({ 0: this._getBufferResource(e) });
        this._bindGroups[e] = t;
      }
      return this._bindGroups[e];
    }
    _uploadBindGroups() {
      const e = this._renderer.buffer,
        t = this._buffers[0];
      t.update(this._batchBuffer.byteIndex), e.updateBuffer(t);
      const a = this._renderer.gpu.device.createCommandEncoder();
      for (let l = 1; l < this._buffers.length; l++) {
        const o = this._buffers[l];
        a.copyBufferToBuffer(
          e.getGPUBuffer(t),
          dr,
          e.getGPUBuffer(o),
          0,
          this._batchBuffer.byteIndex
        );
      }
      this._renderer.gpu.device.queue.submit([a.finish()]);
    }
    destroy() {
      for (let e = 0; e < this._bindGroups.length; e++)
        this._bindGroups[e]?.destroy();
      (this._bindGroups = null), (this._bindGroupHash = null);
      for (let e = 0; e < this._buffers.length; e++) this._buffers[e].destroy();
      this._buffers = null;
      for (let e = 0; e < this._bufferResources.length; e++)
        this._bufferResources[e].destroy();
      (this._bufferResources = null),
        this._batchBuffer.destroy(),
        (this._bindGroupHash = null),
        (this._renderer = null);
    }
  }
  Mg.extension = { type: [P.WebGPUPipes], name: "uniformBatch" };
  const zb = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4,
  };
  function Wb(r, e, t, a, l) {
    return (r << 24) | (e << 16) | (t << 10) | (a << 5) | l;
  }
  function Vb(r, e, t, a) {
    return (t << 6) | (r << 3) | (a << 1) | e;
  }
  class Tg {
    constructor(e) {
      (this._moduleCache = Object.create(null)),
        (this._bufferLayoutsCache = Object.create(null)),
        (this._bindingNamesCache = Object.create(null)),
        (this._pipeCache = Object.create(null)),
        (this._pipeStateCaches = Object.create(null)),
        (this._colorMask = 15),
        (this._multisampleCount = 1),
        (this._renderer = e);
    }
    contextChange(e) {
      (this._gpu = e), this.setStencilMode(Ft.DISABLED), this._updatePipeHash();
    }
    setMultisampleCount(e) {
      this._multisampleCount !== e &&
        ((this._multisampleCount = e), this._updatePipeHash());
    }
    setRenderTarget(e) {
      (this._multisampleCount = e.msaaSamples),
        (this._depthStencilAttachment = e.descriptor.depthStencilAttachment
          ? 1
          : 0),
        this._updatePipeHash();
    }
    setColorMask(e) {
      this._colorMask !== e && ((this._colorMask = e), this._updatePipeHash());
    }
    setStencilMode(e) {
      this._stencilMode !== e &&
        ((this._stencilMode = e),
          (this._stencilState = cr[e]),
          this._updatePipeHash());
    }
    setPipeline(e, t, a, l) {
      const o = this.getPipeline(e, t, a);
      l.setPipeline(o);
    }
    getPipeline(e, t, a, l) {
      e._layoutKey || (bp(e, t.attributeData), this._generateBufferKey(e)),
        l || (l = e.topology);
      const o = Wb(e._layoutKey, t._layoutKey, a.data, a._blendModeId, zb[l]);
      return this._pipeCache[o]
        ? this._pipeCache[o]
        : ((this._pipeCache[o] = this._createPipeline(e, t, a, l)),
          this._pipeCache[o]);
    }
    _createPipeline(e, t, a, l) {
      const o = this._gpu.device,
        h = this._createVertexBufferLayouts(e, t),
        c = this._renderer.state.getColorTargets(a);
      c[0].writeMask =
        this._stencilMode === Ft.RENDERING_MASK_ADD ? 0 : this._colorMask;
      const u = this._renderer.shader.getProgramData(t).pipeline,
        d = {
          vertex: {
            module: this._getModule(t.vertex.source),
            entryPoint: t.vertex.entryPoint,
            buffers: h,
          },
          fragment: {
            module: this._getModule(t.fragment.source),
            entryPoint: t.fragment.entryPoint,
            targets: c,
          },
          primitive: { topology: l, cullMode: a.cullMode },
          layout: u,
          multisample: { count: this._multisampleCount },
          label: "PIXI Pipeline",
        };
      return (
        this._depthStencilAttachment &&
        (d.depthStencil = {
          ...this._stencilState,
          format: "depth24plus-stencil8",
          depthWriteEnabled: a.depthTest,
          depthCompare: a.depthTest ? "less" : "always",
        }),
        o.createRenderPipeline(d)
      );
    }
    _getModule(e) {
      return this._moduleCache[e] || this._createModule(e);
    }
    _createModule(e) {
      const t = this._gpu.device;
      return (
        (this._moduleCache[e] = t.createShaderModule({ code: e })),
        this._moduleCache[e]
      );
    }
    _generateBufferKey(e) {
      const t = [];
      let a = 0;
      const l = Object.keys(e.attributes).sort();
      for (let h = 0; h < l.length; h++) {
        const c = e.attributes[l[h]];
        (t[a++] = c.offset),
          (t[a++] = c.format),
          (t[a++] = c.stride),
          (t[a++] = c.instance);
      }
      const o = t.join("|");
      return (e._layoutKey = Gn(o, "geometry")), e._layoutKey;
    }
    _generateAttributeLocationsKey(e) {
      const t = [];
      let a = 0;
      const l = Object.keys(e.attributeData).sort();
      for (let h = 0; h < l.length; h++) {
        const c = e.attributeData[l[h]];
        t[a++] = c.location;
      }
      const o = t.join("|");
      return (
        (e._attributeLocationsKey = Gn(o, "programAttributes")),
        e._attributeLocationsKey
      );
    }
    getBufferNamesToBind(e, t) {
      const a = (e._layoutKey << 16) | t._attributeLocationsKey;
      if (this._bindingNamesCache[a]) return this._bindingNamesCache[a];
      const l = this._createVertexBufferLayouts(e, t),
        o = Object.create(null),
        h = t.attributeData;
      for (let c = 0; c < l.length; c++) {
        const d = Object.values(l[c].attributes)[0].shaderLocation;
        for (const f in h)
          if (h[f].location === d) {
            o[c] = f;
            break;
          }
      }
      return (this._bindingNamesCache[a] = o), o;
    }
    _createVertexBufferLayouts(e, t) {
      t._attributeLocationsKey || this._generateAttributeLocationsKey(t);
      const a = (e._layoutKey << 16) | t._attributeLocationsKey;
      if (this._bufferLayoutsCache[a]) return this._bufferLayoutsCache[a];
      const l = [];
      return (
        e.buffers.forEach((o) => {
          const h = { arrayStride: 0, stepMode: "vertex", attributes: [] },
            c = h.attributes;
          for (const u in t.attributeData) {
            const d = e.attributes[u];
            (d.divisor ?? 1) !== 1 &&
              pe(
                `Attribute ${u} has an invalid divisor value of '${d.divisor}'. WebGPU only supports a divisor value of 1`
              ),
              d.buffer === o &&
              ((h.arrayStride = d.stride),
                (h.stepMode = d.instance ? "instance" : "vertex"),
                c.push({
                  shaderLocation: t.attributeData[u].location,
                  offset: d.offset,
                  format: d.format,
                }));
          }
          c.length && l.push(h);
        }),
        (this._bufferLayoutsCache[a] = l),
        l
      );
    }
    _updatePipeHash() {
      const e = Vb(
        this._stencilMode,
        this._multisampleCount,
        this._colorMask,
        this._depthStencilAttachment
      );
      this._pipeStateCaches[e] ||
        (this._pipeStateCaches[e] = Object.create(null)),
        (this._pipeCache = this._pipeStateCaches[e]);
    }
    destroy() {
      (this._renderer = null), (this._bufferLayoutsCache = null);
    }
  }
  Tg.extension = { type: [P.WebGPUSystem], name: "pipeline" };
  class jb {
    constructor() {
      (this.contexts = []), (this.msaaTextures = []), (this.msaaSamples = 1);
    }
  }
  class Xb {
    init(e, t) {
      (this._renderer = e), (this._renderTargetSystem = t);
    }
    copyToTexture(e, t, a, l, o) {
      const h = this._renderer,
        c = this._getGpuColorTexture(e),
        u = h.texture.getGpuSource(t.source);
      return (
        h.encoder.commandEncoder.copyTextureToTexture(
          { texture: c, origin: a },
          { texture: u, origin: o },
          l
        ),
        t
      );
    }
    startRenderPass(e, t = !0, a, l) {
      const h = this._renderTargetSystem.getGpuRenderTarget(e),
        c = this.getDescriptor(e, t, a);
      (h.descriptor = c),
        this._renderer.pipeline.setRenderTarget(h),
        this._renderer.encoder.beginRenderPass(h),
        this._renderer.encoder.setViewport(l);
    }
    finishRenderPass() {
      this._renderer.encoder.endRenderPass();
    }
    _getGpuColorTexture(e) {
      const t = this._renderTargetSystem.getGpuRenderTarget(e);
      return t.contexts[0]
        ? t.contexts[0].getCurrentTexture()
        : this._renderer.texture.getGpuSource(e.colorTextures[0].source);
    }
    getDescriptor(e, t, a) {
      typeof t == "boolean" && (t = t ? Ns.ALL : Ns.NONE);
      const l = this._renderTargetSystem,
        o = l.getGpuRenderTarget(e),
        h = e.colorTextures.map((d, f) => {
          const p = o.contexts[f];
          let g, _;
          p
            ? (g = p.getCurrentTexture().createView())
            : (g = this._renderer.texture
              .getGpuSource(d)
              .createView({ mipLevelCount: 1 })),
            o.msaaTextures[f] &&
            ((_ = g),
              (g = this._renderer.texture.getTextureView(o.msaaTextures[f])));
          const m = t & Ns.COLOR ? "clear" : "load";
          return (
            a ?? (a = l.defaultClearColor),
            {
              view: g,
              resolveTarget: _,
              clearValue: a,
              storeOp: "store",
              loadOp: m,
            }
          );
        });
      let c;
      if (
        ((e.stencil || e.depth) &&
          !e.depthStencilTexture &&
          (e.ensureDepthStencilTexture(),
            (e.depthStencilTexture.source.sampleCount = o.msaa ? 4 : 1)),
          e.depthStencilTexture)
      ) {
        const d = t & Ns.STENCIL ? "clear" : "load",
          f = t & Ns.DEPTH ? "clear" : "load";
        c = {
          view: this._renderer.texture
            .getGpuSource(e.depthStencilTexture.source)
            .createView(),
          stencilStoreOp: "store",
          stencilLoadOp: d,
          depthClearValue: 1,
          depthLoadOp: f,
          depthStoreOp: "store",
        };
      }
      return { colorAttachments: h, depthStencilAttachment: c };
    }
    clear(e, t = !0, a, l) {
      if (!t) return;
      const { gpu: o, encoder: h } = this._renderer,
        c = o.device;
      if (h.commandEncoder === null) {
        const d = c.createCommandEncoder(),
          f = this.getDescriptor(e, t, a),
          p = d.beginRenderPass(f);
        p.setViewport(l.x, l.y, l.width, l.height, 0, 1), p.end();
        const g = d.finish();
        c.queue.submit([g]);
      } else this.startRenderPass(e, t, a, l);
    }
    initGpuRenderTarget(e) {
      e.isRoot = !0;
      const t = new jb();
      return (
        e.colorTextures.forEach((a, l) => {
          if (a instanceof ji) {
            const o = a.resource.getContext("webgpu"),
              h = a.transparent ? "premultiplied" : "opaque";
            try {
              o.configure({
                device: this._renderer.gpu.device,
                usage:
                  GPUTextureUsage.TEXTURE_BINDING |
                  GPUTextureUsage.COPY_DST |
                  GPUTextureUsage.RENDER_ATTACHMENT |
                  GPUTextureUsage.COPY_SRC,
                format: "bgra8unorm",
                alphaMode: h,
              });
            } catch { }
            t.contexts[l] = o;
          }
          if (((t.msaa = a.source.antialias), a.source.antialias)) {
            const o = new zt({ width: 0, height: 0, sampleCount: 4 });
            t.msaaTextures[l] = o;
          }
        }),
        t.msaa &&
        ((t.msaaSamples = 4),
          e.depthStencilTexture &&
          (e.depthStencilTexture.source.sampleCount = 4)),
        t
      );
    }
    destroyGpuRenderTarget(e) {
      e.contexts.forEach((t) => {
        t.unconfigure();
      }),
        e.msaaTextures.forEach((t) => {
          t.destroy();
        }),
        (e.msaaTextures.length = 0),
        (e.contexts.length = 0);
    }
    ensureDepthStencilTexture(e) {
      const t = this._renderTargetSystem.getGpuRenderTarget(e);
      e.depthStencilTexture &&
        t.msaa &&
        (e.depthStencilTexture.source.sampleCount = 4);
    }
    resizeGpuRenderTarget(e) {
      const t = this._renderTargetSystem.getGpuRenderTarget(e);
      (t.width = e.width),
        (t.height = e.height),
        t.msaa &&
        e.colorTextures.forEach((a, l) => {
          t.msaaTextures[l]?.resize(
            a.source.width,
            a.source.height,
            a.source._resolution
          );
        });
    }
  }
  class Cg extends Dp {
    constructor(e) {
      super(e), (this.adaptor = new Xb()), this.adaptor.init(e, this);
    }
  }
  Cg.extension = { type: [P.WebGPUSystem], name: "renderTarget" };
  class Ag {
    constructor() {
      this._gpuProgramData = Object.create(null);
    }
    contextChange(e) {
      this._gpu = e;
    }
    getProgramData(e) {
      return (
        this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e)
      );
    }
    _createGPUProgramData(e) {
      const t = this._gpu.device,
        a = e.gpuLayout.map((o) => t.createBindGroupLayout({ entries: o })),
        l = { bindGroupLayouts: a };
      return (
        (this._gpuProgramData[e._layoutKey] = {
          bindGroups: a,
          pipeline: t.createPipelineLayout(l),
        }),
        this._gpuProgramData[e._layoutKey]
      );
    }
    destroy() {
      (this._gpu = null), (this._gpuProgramData = null);
    }
  }
  Ag.extension = { type: [P.WebGPUSystem], name: "shader" };
  const As = {};
  (As.normal = {
    alpha: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add",
    },
    color: {
      srcFactor: "one",
      dstFactor: "one-minus-src-alpha",
      operation: "add",
    },
  }),
    (As.add = {
      alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: { srcFactor: "one", dstFactor: "one", operation: "add" },
    }),
    (As.multiply = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
    }),
    (As.screen = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" },
    }),
    (As.overlay = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: { srcFactor: "one", dstFactor: "one-minus-src", operation: "add" },
    }),
    (As.none = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: { srcFactor: "zero", dstFactor: "zero", operation: "add" },
    }),
    (As["normal-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
    }),
    (As["add-npm"] = {
      alpha: { srcFactor: "one", dstFactor: "one", operation: "add" },
      color: { srcFactor: "src-alpha", dstFactor: "one", operation: "add" },
    }),
    (As["screen-npm"] = {
      alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add",
      },
    }),
    (As.erase = {
      alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add",
      },
      color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add",
      },
    }),
    (As.min = {
      alpha: { srcFactor: "one", dstFactor: "one", operation: "min" },
      color: { srcFactor: "one", dstFactor: "one", operation: "min" },
    }),
    (As.max = {
      alpha: { srcFactor: "one", dstFactor: "one", operation: "max" },
      color: { srcFactor: "one", dstFactor: "one", operation: "max" },
    });
  class Pg {
    constructor() {
      (this.defaultState = new gi()), (this.defaultState.blend = !0);
    }
    contextChange(e) {
      this.gpu = e;
    }
    getColorTargets(e) {
      return [
        {
          format: "bgra8unorm",
          writeMask: 0,
          blend: As[e.blendMode] || As.normal,
        },
      ];
    }
    destroy() {
      this.gpu = null;
    }
  }
  Pg.extension = { type: [P.WebGPUSystem], name: "state" };
  const qb = {
    type: "image",
    upload(r, e, t) {
      const a = r.resource,
        l = (r.pixelWidth | 0) * (r.pixelHeight | 0),
        o = a.byteLength / l;
      t.device.queue.writeTexture(
        { texture: e },
        a,
        {
          offset: 0,
          rowsPerImage: r.pixelHeight,
          bytesPerRow: r.pixelHeight * o,
        },
        { width: r.pixelWidth, height: r.pixelHeight, depthOrArrayLayers: 1 }
      );
    },
  },
    Eg = {
      "bc1-rgba-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "bc2-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc3-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "bc7-rgba-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "etc1-rgb-unorm": { blockBytes: 8, blockWidth: 4, blockHeight: 4 },
      "etc2-rgba8unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
      "astc-4x4-unorm": { blockBytes: 16, blockWidth: 4, blockHeight: 4 },
    },
    Yb = { blockBytes: 4, blockWidth: 1, blockHeight: 1 },
    $b = {
      type: "compressed",
      upload(r, e, t) {
        let a = r.pixelWidth,
          l = r.pixelHeight;
        const o = Eg[r.format] || Yb;
        for (let h = 0; h < r.resource.length; h++) {
          const c = r.resource[h],
            u = Math.ceil(a / o.blockWidth) * o.blockBytes;
          t.device.queue.writeTexture(
            { texture: e, mipLevel: h },
            c,
            { offset: 0, bytesPerRow: u },
            {
              width: Math.ceil(a / o.blockWidth) * o.blockWidth,
              height: Math.ceil(l / o.blockHeight) * o.blockHeight,
              depthOrArrayLayers: 1,
            }
          ),
            (a = Math.max(a >> 1, 1)),
            (l = Math.max(l >> 1, 1));
        }
      },
    },
    kg = {
      type: "image",
      upload(r, e, t) {
        const a = r.resource;
        if (!a) return;
        if (globalThis.HTMLImageElement && a instanceof HTMLImageElement) {
          const c = xe.get().createCanvas(a.width, a.height);
          c.getContext("2d").drawImage(a, 0, 0, a.width, a.height),
            (r.resource = c),
            pe(
              "ImageSource: Image element passed, converting to canvas and replacing resource."
            );
        }
        const l = Math.min(e.width, r.resourceWidth || r.pixelWidth),
          o = Math.min(e.height, r.resourceHeight || r.pixelHeight),
          h = r.alphaMode === "premultiply-alpha-on-upload";
        t.device.queue.copyExternalImageToTexture(
          { source: a },
          { texture: e, premultipliedAlpha: h },
          { width: l, height: o }
        );
      },
    },
    Kb = {
      type: "video",
      upload(r, e, t) {
        kg.upload(r, e, t);
      },
    };
  class Zb {
    constructor(e) {
      (this.device = e),
        (this.sampler = e.createSampler({ minFilter: "linear" })),
        (this.pipelines = {});
    }
    _getMipmapPipeline(e) {
      let t = this.pipelines[e];
      return (
        t ||
        (this.mipmapShaderModule ||
          (this.mipmapShaderModule = this.device.createShaderModule({
            code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `,
          })),
          (t = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
              module: this.mipmapShaderModule,
              entryPoint: "vertexMain",
            },
            fragment: {
              module: this.mipmapShaderModule,
              entryPoint: "fragmentMain",
              targets: [{ format: e }],
            },
          })),
          (this.pipelines[e] = t)),
        t
      );
    }
    generateMipmap(e) {
      const t = this._getMipmapPipeline(e.format);
      if (e.dimension === "3d" || e.dimension === "1d")
        throw new Error(
          "Generating mipmaps for non-2d textures is currently unsupported!"
        );
      let a = e;
      const l = e.depthOrArrayLayers || 1,
        o = e.usage & GPUTextureUsage.RENDER_ATTACHMENT;
      if (!o) {
        const u = {
          size: {
            width: Math.ceil(e.width / 2),
            height: Math.ceil(e.height / 2),
            depthOrArrayLayers: l,
          },
          format: e.format,
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_SRC |
            GPUTextureUsage.RENDER_ATTACHMENT,
          mipLevelCount: e.mipLevelCount - 1,
        };
        a = this.device.createTexture(u);
      }
      const h = this.device.createCommandEncoder({}),
        c = t.getBindGroupLayout(0);
      for (let u = 0; u < l; ++u) {
        let d = e.createView({
          baseMipLevel: 0,
          mipLevelCount: 1,
          dimension: "2d",
          baseArrayLayer: u,
          arrayLayerCount: 1,
        }),
          f = o ? 1 : 0;
        for (let p = 1; p < e.mipLevelCount; ++p) {
          const g = a.createView({
            baseMipLevel: f++,
            mipLevelCount: 1,
            dimension: "2d",
            baseArrayLayer: u,
            arrayLayerCount: 1,
          }),
            _ = h.beginRenderPass({
              colorAttachments: [
                {
                  view: g,
                  storeOp: "store",
                  loadOp: "clear",
                  clearValue: { r: 0, g: 0, b: 0, a: 0 },
                },
              ],
            }),
            m = this.device.createBindGroup({
              layout: c,
              entries: [
                { binding: 0, resource: this.sampler },
                { binding: 1, resource: d },
              ],
            });
          _.setPipeline(t),
            _.setBindGroup(0, m),
            _.draw(3, 1, 0, 0),
            _.end(),
            (d = g);
        }
      }
      if (!o) {
        const u = {
          width: Math.ceil(e.width / 2),
          height: Math.ceil(e.height / 2),
          depthOrArrayLayers: l,
        };
        for (let d = 1; d < e.mipLevelCount; ++d)
          h.copyTextureToTexture(
            { texture: a, mipLevel: d - 1 },
            { texture: e, mipLevel: d },
            u
          ),
            (u.width = Math.ceil(u.width / 2)),
            (u.height = Math.ceil(u.height / 2));
      }
      return this.device.queue.submit([h.finish()]), o || a.destroy(), e;
    }
  }
  class Rg {
    constructor(e) {
      (this.managedTextures = []),
        (this._gpuSources = Object.create(null)),
        (this._gpuSamplers = Object.create(null)),
        (this._bindGroupHash = Object.create(null)),
        (this._textureViewHash = Object.create(null)),
        (this._uploads = { image: kg, buffer: qb, video: Kb, compressed: $b }),
        (this._renderer = e),
        e.renderableGC.addManagedHash(this, "_gpuSources"),
        e.renderableGC.addManagedHash(this, "_gpuSamplers"),
        e.renderableGC.addManagedHash(this, "_bindGroupHash"),
        e.renderableGC.addManagedHash(this, "_textureViewHash");
    }
    contextChange(e) {
      this._gpu = e;
    }
    initSource(e) {
      return this._gpuSources[e.uid]
        ? this._gpuSources[e.uid]
        : this._initSource(e);
    }
    _initSource(e) {
      if (e.autoGenerateMipmaps) {
        const u = Math.max(e.pixelWidth, e.pixelHeight);
        e.mipLevelCount = Math.floor(Math.log2(u)) + 1;
      }
      let t = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      e.uploadMethodId !== "compressed" &&
        ((t |= GPUTextureUsage.RENDER_ATTACHMENT),
          (t |= GPUTextureUsage.COPY_SRC));
      const a = Eg[e.format] || { blockWidth: 1, blockHeight: 1 },
        l = Math.ceil(e.pixelWidth / a.blockWidth) * a.blockWidth,
        o = Math.ceil(e.pixelHeight / a.blockHeight) * a.blockHeight,
        h = {
          label: e.label,
          size: { width: l, height: o },
          format: e.format,
          sampleCount: e.sampleCount,
          mipLevelCount: e.mipLevelCount,
          dimension: e.dimension,
          usage: t,
        },
        c = (this._gpuSources[e.uid] = this._gpu.device.createTexture(h));
      return (
        this.managedTextures.includes(e) ||
        (e.on("update", this.onSourceUpdate, this),
          e.on("resize", this.onSourceResize, this),
          e.on("destroy", this.onSourceDestroy, this),
          e.on("unload", this.onSourceUnload, this),
          e.on("updateMipmaps", this.onUpdateMipmaps, this),
          this.managedTextures.push(e)),
        this.onSourceUpdate(e),
        c
      );
    }
    onSourceUpdate(e) {
      const t = this.getGpuSource(e);
      t &&
        (this._uploads[e.uploadMethodId] &&
          this._uploads[e.uploadMethodId].upload(e, t, this._gpu),
          e.autoGenerateMipmaps &&
          e.mipLevelCount > 1 &&
          this.onUpdateMipmaps(e));
    }
    onSourceUnload(e) {
      const t = this._gpuSources[e.uid];
      t && ((this._gpuSources[e.uid] = null), t.destroy());
    }
    onUpdateMipmaps(e) {
      this._mipmapGenerator ||
        (this._mipmapGenerator = new Zb(this._gpu.device));
      const t = this.getGpuSource(e);
      this._mipmapGenerator.generateMipmap(t);
    }
    onSourceDestroy(e) {
      e.off("update", this.onSourceUpdate, this),
        e.off("unload", this.onSourceUnload, this),
        e.off("destroy", this.onSourceDestroy, this),
        e.off("resize", this.onSourceResize, this),
        e.off("updateMipmaps", this.onUpdateMipmaps, this),
        this.managedTextures.splice(this.managedTextures.indexOf(e), 1),
        this.onSourceUnload(e);
    }
    onSourceResize(e) {
      const t = this._gpuSources[e.uid];
      t
        ? (t.width !== e.pixelWidth || t.height !== e.pixelHeight) &&
        ((this._textureViewHash[e.uid] = null),
          (this._bindGroupHash[e.uid] = null),
          this.onSourceUnload(e),
          this.initSource(e))
        : this.initSource(e);
    }
    _initSampler(e) {
      return (
        (this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e)),
        this._gpuSamplers[e._resourceId]
      );
    }
    getGpuSampler(e) {
      return this._gpuSamplers[e._resourceId] || this._initSampler(e);
    }
    getGpuSource(e) {
      return this._gpuSources[e.uid] || this.initSource(e);
    }
    getTextureBindGroup(e) {
      return this._bindGroupHash[e.uid] ?? this._createTextureBindGroup(e);
    }
    _createTextureBindGroup(e) {
      const t = e.source;
      return (
        (this._bindGroupHash[e.uid] = new qi({
          0: t,
          1: t.style,
          2: new ys({
            uTextureMatrix: {
              type: "mat3x3<f32>",
              value: e.textureMatrix.mapCoord,
            },
          }),
        })),
        this._bindGroupHash[e.uid]
      );
    }
    getTextureView(e) {
      const t = e.source;
      return this._textureViewHash[t.uid] ?? this._createTextureView(t);
    }
    _createTextureView(e) {
      return (
        (this._textureViewHash[e.uid] = this.getGpuSource(e).createView()),
        this._textureViewHash[e.uid]
      );
    }
    generateCanvas(e) {
      const t = this._renderer,
        a = t.gpu.device.createCommandEncoder(),
        l = xe.get().createCanvas();
      (l.width = e.source.pixelWidth), (l.height = e.source.pixelHeight);
      const o = l.getContext("webgpu");
      return (
        o.configure({
          device: t.gpu.device,
          usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
          format: xe.get().getNavigator().gpu.getPreferredCanvasFormat(),
          alphaMode: "premultiplied",
        }),
        a.copyTextureToTexture(
          { texture: t.texture.getGpuSource(e.source), origin: { x: 0, y: 0 } },
          { texture: o.getCurrentTexture() },
          { width: l.width, height: l.height }
        ),
        t.gpu.device.queue.submit([a.finish()]),
        l
      );
    }
    getPixels(e) {
      const t = this.generateCanvas(e),
        a = Ki.getOptimalCanvasAndContext(t.width, t.height),
        l = a.context;
      l.drawImage(t, 0, 0);
      const { width: o, height: h } = t,
        c = l.getImageData(0, 0, o, h),
        u = new Uint8ClampedArray(c.data.buffer);
      return Ki.returnCanvasAndContext(a), { pixels: u, width: o, height: h };
    }
    destroy() {
      this.managedTextures.slice().forEach((e) => this.onSourceDestroy(e)),
        (this.managedTextures = null);
      for (const e of Object.keys(this._bindGroupHash)) {
        const t = Number(e);
        this._bindGroupHash[t]?.destroy(), (this._bindGroupHash[t] = null);
      }
      (this._gpu = null),
        (this._mipmapGenerator = null),
        (this._gpuSources = null),
        (this._bindGroupHash = null),
        (this._textureViewHash = null),
        (this._gpuSamplers = null);
    }
  }
  Rg.extension = { type: [P.WebGPUSystem], name: "texture" };
  class Ig {
    constructor() {
      this._maxTextures = 0;
    }
    contextChange(e) {
      const t = new ys({
        uTransformMatrix: { value: new ae(), type: "mat3x3<f32>" },
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uRound: { value: 0, type: "f32" },
      });
      this._maxTextures = e.limits.maxBatchableTextures;
      const a = $n({
        name: "graphics",
        bits: [wh, Th(this._maxTextures), vv, Zn],
      });
      this.shader = new ei({ gpuProgram: a, resources: { localUniforms: t } });
    }
    execute(e, t) {
      const a = t.context,
        l = a.customShader || this.shader,
        o = e.renderer,
        h = o.graphicsContext,
        { batcher: c, instructions: u } = h.getContextRenderData(a),
        d = o.encoder;
      d.setGeometry(c.geometry, l.gpuProgram);
      const f = o.globalUniforms.bindGroup;
      d.setBindGroup(0, f, l.gpuProgram);
      const p = o.renderPipes.uniformBatch.getUniformBindGroup(
        l.resources.localUniforms,
        !0
      );
      d.setBindGroup(2, p, l.gpuProgram);
      const g = u.instructions;
      let _ = null;
      for (let m = 0; m < u.instructionSize; m++) {
        const w = g[m];
        if (
          (w.topology !== _ &&
            ((_ = w.topology),
              d.setPipelineFromGeometryProgramAndState(
                c.geometry,
                l.gpuProgram,
                e.state,
                w.topology
              )),
            (l.groups[1] = w.bindGroup),
            !w.gpuBindGroup)
        ) {
          const x = w.textures;
          (w.bindGroup = xh(x.textures, x.count, this._maxTextures)),
            (w.gpuBindGroup = o.bindGroup.getBindGroup(
              w.bindGroup,
              l.gpuProgram,
              1
            ));
        }
        d.setBindGroup(1, w.bindGroup, l.gpuProgram),
          d.renderPassEncoder.drawIndexed(w.size, 1, w.start);
      }
    }
    destroy() {
      this.shader.destroy(!0), (this.shader = null);
    }
  }
  Ig.extension = { type: [P.WebGPUPipesAdaptor], name: "graphics" };
  class Bg {
    init() {
      const e = $n({ name: "mesh", bits: [ra, bv, Zn] });
      this._shader = new ei({
        gpuProgram: e,
        resources: {
          uTexture: te.EMPTY._source,
          uSampler: te.EMPTY._source.style,
          textureUniforms: {
            uTextureMatrix: { type: "mat3x3<f32>", value: new ae() },
          },
        },
      });
    }
    execute(e, t) {
      const a = e.renderer;
      let l = t._shader;
      if (!l)
        (l = this._shader),
          (l.groups[2] = a.texture.getTextureBindGroup(t.texture));
      else if (!l.gpuProgram) {
        pe("Mesh shader has no gpuProgram", t.shader);
        return;
      }
      const o = l.gpuProgram;
      if (
        (o.autoAssignGlobalUniforms &&
          (l.groups[0] = a.globalUniforms.bindGroup),
          o.autoAssignLocalUniforms)
      ) {
        const h = e.localUniforms;
        l.groups[1] = a.renderPipes.uniformBatch.getUniformBindGroup(h, !0);
      }
      a.encoder.draw({ geometry: t._geometry, shader: l, state: t.state });
    }
    destroy() {
      this._shader.destroy(!0), (this._shader = null);
    }
  }
  Bg.extension = { type: [P.WebGPUPipesAdaptor], name: "mesh" };
  const Qb = [...ug, Sg, vg, gc, bg, yg, Rg, Cg, Ag, Pg, Tg, xg, wg, _g],
    Jb = [...fg, Mg],
    ew = [gp, Bg, Ig],
    Fg = [],
    Gg = [],
    Dg = [];
  ge.handleByNamedList(P.WebGPUSystem, Fg),
    ge.handleByNamedList(P.WebGPUPipes, Gg),
    ge.handleByNamedList(P.WebGPUPipesAdaptor, Dg),
    ge.add(...Qb, ...Jb, ...ew);
  class tw extends ao {
    constructor() {
      const e = {
        name: "webgpu",
        type: pi.WEBGPU,
        systems: Fg,
        renderPipes: Gg,
        renderPipeAdaptors: Dg,
      };
      super(e);
    }
  }
  const sw = Object.freeze(
    Object.defineProperty(
      { __proto__: null, WebGPURenderer: tw },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
  class iw {
    constructor() {
      (this.batches = []), (this.batched = !1);
    }
    destroy() {
      this.batches.forEach((e) => {
        Ot.return(e);
      }),
        (this.batches.length = 0);
    }
  }
  class Ug {
    constructor(e, t) {
      (this.state = gi.for2d()),
        (this.renderer = e),
        (this._adaptor = t),
        this.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._adaptor.contextChange(this.renderer);
    }
    validateRenderable(e) {
      const t = e.context,
        a = !!e._gpuData,
        l = this.renderer.graphicsContext.updateGpuContext(t);
      return !!(l.isBatchable || a !== l.isBatchable);
    }
    addRenderable(e, t) {
      const a = this.renderer.graphicsContext.updateGpuContext(e.context);
      e.didViewUpdate && this._rebuild(e),
        a.isBatchable
          ? this._addToBatcher(e, t)
          : (this.renderer.renderPipes.batch.break(t), t.add(e));
    }
    updateRenderable(e) {
      const a = this._getGpuDataForRenderable(e).batches;
      for (let l = 0; l < a.length; l++) {
        const o = a[l];
        o._batcher.updateElement(o);
      }
    }
    execute(e) {
      if (!e.isRenderable) return;
      const t = this.renderer,
        a = e.context;
      if (!t.graphicsContext.getGpuContext(a).batches.length) return;
      const o = a.customShader || this._adaptor.shader;
      this.state.blendMode = e.groupBlendMode;
      const h = o.resources.localUniforms.uniforms;
      (h.uTransformMatrix = e.groupTransform),
        (h.uRound = t._roundPixels | e._roundPixels),
        aa(e.groupColorAlpha, h.uColor, 0),
        this._adaptor.execute(this, e);
    }
    _rebuild(e) {
      const t = this._getGpuDataForRenderable(e),
        a = this.renderer.graphicsContext.updateGpuContext(e.context);
      t.destroy(), a.isBatchable && this._updateBatchesForRenderable(e, t);
    }
    _addToBatcher(e, t) {
      const a = this.renderer.renderPipes.batch,
        l = this._getGpuDataForRenderable(e).batches;
      for (let o = 0; o < l.length; o++) {
        const h = l[o];
        a.addToBatch(h, t);
      }
    }
    _getGpuDataForRenderable(e) {
      return e._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(e);
    }
    _initGpuDataForRenderable(e) {
      const t = new iw();
      return (e._gpuData[this.renderer.uid] = t), t;
    }
    _updateBatchesForRenderable(e, t) {
      const a = e.context,
        l = this.renderer.graphicsContext.getGpuContext(a),
        o = this.renderer._roundPixels | e._roundPixels;
      t.batches = l.batches.map((h) => {
        const c = Ot.get(Rh);
        return h.copyTo(c), (c.renderable = e), (c.roundPixels = o), c;
      });
    }
    destroy() {
      (this.renderer = null),
        this._adaptor.destroy(),
        (this._adaptor = null),
        (this.state = null);
    }
  }
  Ug.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "graphics",
  };
  const Og = class p1 extends $h {
    constructor(...e) {
      super({});
      let t = e[0] ?? {};
      typeof t == "number" &&
        (me(
          Ie,
          "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"
        ),
          (t = { width: t, height: e[1], verticesX: e[2], verticesY: e[3] })),
        this.build(t);
    }
    build(e) {
      (e = { ...p1.defaultOptions, ...e }),
        (this.verticesX = this.verticesX ?? e.verticesX),
        (this.verticesY = this.verticesY ?? e.verticesY),
        (this.width = this.width ?? e.width),
        (this.height = this.height ?? e.height);
      const t = this.verticesX * this.verticesY,
        a = [],
        l = [],
        o = [],
        h = this.verticesX - 1,
        c = this.verticesY - 1,
        u = this.width / h,
        d = this.height / c;
      for (let p = 0; p < t; p++) {
        const g = p % this.verticesX,
          _ = (p / this.verticesX) | 0;
        a.push(g * u, _ * d), l.push(g / h, _ / c);
      }
      const f = h * c;
      for (let p = 0; p < f; p++) {
        const g = p % h,
          _ = (p / h) | 0,
          m = _ * this.verticesX + g,
          w = _ * this.verticesX + g + 1,
          x = (_ + 1) * this.verticesX + g,
          M = (_ + 1) * this.verticesX + g + 1;
        o.push(m, w, x, w, M, x);
      }
      (this.buffers[0].data = new Float32Array(a)),
        (this.buffers[1].data = new Float32Array(l)),
        (this.indexBuffer.data = new Uint32Array(o)),
        this.buffers[0].update(),
        this.buffers[1].update(),
        this.indexBuffer.update();
    }
  };
  Og.defaultOptions = { width: 100, height: 100, verticesX: 10, verticesY: 10 };
  let rw = Og;
  class _c {
    constructor() {
      (this.batcherName = "default"),
        (this.packAsQuad = !1),
        (this.indexOffset = 0),
        (this.attributeOffset = 0),
        (this.roundPixels = 0),
        (this._batcher = null),
        (this._batch = null),
        (this._textureMatrixUpdateId = -1),
        (this._uvUpdateId = -1);
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    get topology() {
      return this._topology || this.geometry.topology;
    }
    set topology(e) {
      this._topology = e;
    }
    reset() {
      (this.renderable = null),
        (this.texture = null),
        (this._batcher = null),
        (this._batch = null),
        (this.geometry = null),
        (this._uvUpdateId = -1),
        (this._textureMatrixUpdateId = -1);
    }
    setTexture(e) {
      this.texture !== e &&
        ((this.texture = e), (this._textureMatrixUpdateId = -1));
    }
    get uvs() {
      const t = this.geometry.getBuffer("aUV"),
        a = t.data;
      let l = a;
      const o = this.texture.textureMatrix;
      return (
        o.isSimple ||
        ((l = this._transformedUvs),
          (this._textureMatrixUpdateId !== o._updateID ||
            this._uvUpdateId !== t._updateID) &&
          ((!l || l.length < a.length) &&
            (l = this._transformedUvs = new Float32Array(a.length)),
            (this._textureMatrixUpdateId = o._updateID),
            (this._uvUpdateId = t._updateID),
            o.multiplyUvs(a, l))),
        l
      );
    }
    get positions() {
      return this.geometry.positions;
    }
    get indices() {
      return this.geometry.indices;
    }
    get color() {
      return this.renderable.groupColorAlpha;
    }
    get groupTransform() {
      return this.renderable.groupTransform;
    }
    get attributeSize() {
      return this.geometry.positions.length / 2;
    }
    get indexSize() {
      return this.geometry.indices.length;
    }
  }
  class Lg {
    destroy() { }
  }
  class Ng {
    constructor(e, t) {
      (this.localUniforms = new ys({
        uTransformMatrix: { value: new ae(), type: "mat3x3<f32>" },
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uRound: { value: 0, type: "f32" },
      })),
        (this.localUniformsBindGroup = new qi({ 0: this.localUniforms })),
        (this.renderer = e),
        (this._adaptor = t),
        this._adaptor.init();
    }
    validateRenderable(e) {
      const t = this._getMeshData(e),
        a = t.batched,
        l = e.batched;
      if (((t.batched = l), a !== l)) return !0;
      if (l) {
        const o = e._geometry;
        if (
          o.indices.length !== t.indexSize ||
          o.positions.length !== t.vertexSize
        )
          return (
            (t.indexSize = o.indices.length),
            (t.vertexSize = o.positions.length),
            !0
          );
        const h = this._getBatchableMesh(e);
        return (
          h.texture.uid !== e._texture.uid && (h._textureMatrixUpdateId = -1),
          !h._batcher.checkAndUpdateTexture(h, e._texture)
        );
      }
      return !1;
    }
    addRenderable(e, t) {
      const a = this.renderer.renderPipes.batch,
        l = this._getMeshData(e);
      if (
        (e.didViewUpdate &&
          ((l.indexSize = e._geometry.indices?.length),
            (l.vertexSize = e._geometry.positions?.length)),
          l.batched)
      ) {
        const o = this._getBatchableMesh(e);
        o.setTexture(e._texture),
          (o.geometry = e._geometry),
          a.addToBatch(o, t);
      } else a.break(t), t.add(e);
    }
    updateRenderable(e) {
      if (e.batched) {
        const t = this._getBatchableMesh(e);
        t.setTexture(e._texture),
          (t.geometry = e._geometry),
          t._batcher.updateElement(t);
      }
    }
    execute(e) {
      if (!e.isRenderable) return;
      e.state.blendMode = jn(e.groupBlendMode, e.texture._source);
      const t = this.localUniforms;
      (t.uniforms.uTransformMatrix = e.groupTransform),
        (t.uniforms.uRound = this.renderer._roundPixels | e._roundPixels),
        t.update(),
        aa(e.groupColorAlpha, t.uniforms.uColor, 0),
        this._adaptor.execute(this, e);
    }
    _getMeshData(e) {
      var t, a;
      return (
        (t = e._gpuData)[(a = this.renderer.uid)] || (t[a] = new Lg()),
        e._gpuData[this.renderer.uid].meshData || this._initMeshData(e)
      );
    }
    _initMeshData(e) {
      return (
        (e._gpuData[this.renderer.uid].meshData = {
          batched: e.batched,
          indexSize: 0,
          vertexSize: 0,
        }),
        e._gpuData[this.renderer.uid].meshData
      );
    }
    _getBatchableMesh(e) {
      var t, a;
      return (
        (t = e._gpuData)[(a = this.renderer.uid)] || (t[a] = new Lg()),
        e._gpuData[this.renderer.uid].batchableMesh ||
        this._initBatchableMesh(e)
      );
    }
    _initBatchableMesh(e) {
      const t = new _c();
      return (
        (t.renderable = e),
        t.setTexture(e._texture),
        (t.transform = e.groupTransform),
        (t.roundPixels = this.renderer._roundPixels | e._roundPixels),
        (e._gpuData[this.renderer.uid].batchableMesh = t),
        t
      );
    }
    destroy() {
      (this.localUniforms = null),
        (this.localUniformsBindGroup = null),
        this._adaptor.destroy(),
        (this._adaptor = null),
        (this.renderer = null);
    }
  }
  Ng.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "mesh",
  };
  class nw {
    execute(e, t) {
      const a = e.state,
        l = e.renderer,
        o = t.shader || e.defaultShader;
      (o.resources.uTexture = t.texture._source),
        (o.resources.uniforms = e.localUniforms);
      const h = l.gl,
        c = e.getBuffers(t);
      l.shader.bind(o),
        l.state.set(a),
        l.geometry.bind(c.geometry, o.glProgram);
      const d =
        c.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2
          ? h.UNSIGNED_SHORT
          : h.UNSIGNED_INT;
      h.drawElements(h.TRIANGLES, t.particleChildren.length * 6, d, 0);
    }
  }
  class aw {
    execute(e, t) {
      const a = e.renderer,
        l = t.shader || e.defaultShader;
      (l.groups[0] = a.renderPipes.uniformBatch.getUniformBindGroup(
        e.localUniforms,
        !0
      )),
        (l.groups[1] = a.texture.getTextureBindGroup(t.texture));
      const o = e.state,
        h = e.getBuffers(t);
      a.encoder.draw({
        geometry: h.geometry,
        shader: t.shader || e.defaultShader,
        state: o,
        size: t.particleChildren.length * 6,
      });
    }
  }
  function Hg(r, e = null) {
    const t = r * 6;
    if (
      (t > 65535
        ? e || (e = new Uint32Array(t))
        : e || (e = new Uint16Array(t)),
        e.length !== t)
    )
      throw new Error(
        `Out buffer length is incorrect, got ${e.length} and expected ${t}`
      );
    for (let a = 0, l = 0; a < t; a += 6, l += 4)
      (e[a + 0] = l + 0),
        (e[a + 1] = l + 1),
        (e[a + 2] = l + 2),
        (e[a + 3] = l + 0),
        (e[a + 4] = l + 2),
        (e[a + 5] = l + 3);
    return e;
  }
  function ow(r) {
    return { dynamicUpdate: zg(r, !0), staticUpdate: zg(r, !1) };
  }
  function zg(r, e) {
    const t = [];
    t.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let a = 0;
    for (const o in r) {
      const h = r[o];
      if (e !== h.dynamic) continue;
      t.push(`offset = index + ${a}`), t.push(h.code);
      const c = lr(h.format);
      a += c.stride / 4;
    }
    t.push(`
            index += stride * 4;
        }
    `),
      t.unshift(`
        var stride = ${a};
    `);
    const l = t.join(`
`);
    return new Function("ps", "f32v", "u32v", l);
  }
  class hw {
    constructor(e) {
      (this._size = 0), (this._generateParticleUpdateCache = {});
      const t = (this._size = e.size ?? 1e3),
        a = e.properties;
      let l = 0,
        o = 0;
      for (const f in a) {
        const p = a[f],
          g = lr(p.format);
        p.dynamic ? (o += g.stride) : (l += g.stride);
      }
      (this._dynamicStride = o / 4),
        (this._staticStride = l / 4),
        (this.staticAttributeBuffer = new rn(t * 4 * l)),
        (this.dynamicAttributeBuffer = new rn(t * 4 * o)),
        (this.indexBuffer = Hg(t));
      const h = new Yn();
      let c = 0,
        u = 0;
      (this._staticBuffer = new Hs({
        data: new Float32Array(1),
        label: "static-particle-buffer",
        shrinkToFit: !1,
        usage: Fe.VERTEX | Fe.COPY_DST,
      })),
        (this._dynamicBuffer = new Hs({
          data: new Float32Array(1),
          label: "dynamic-particle-buffer",
          shrinkToFit: !1,
          usage: Fe.VERTEX | Fe.COPY_DST,
        }));
      for (const f in a) {
        const p = a[f],
          g = lr(p.format);
        p.dynamic
          ? (h.addAttribute(p.attributeName, {
            buffer: this._dynamicBuffer,
            stride: this._dynamicStride * 4,
            offset: c * 4,
            format: p.format,
          }),
            (c += g.size))
          : (h.addAttribute(p.attributeName, {
            buffer: this._staticBuffer,
            stride: this._staticStride * 4,
            offset: u * 4,
            format: p.format,
          }),
            (u += g.size));
      }
      h.addIndex(this.indexBuffer);
      const d = this.getParticleUpdate(a);
      (this._dynamicUpload = d.dynamicUpdate),
        (this._staticUpload = d.staticUpdate),
        (this.geometry = h);
    }
    getParticleUpdate(e) {
      const t = cw(e);
      return this._generateParticleUpdateCache[t]
        ? this._generateParticleUpdateCache[t]
        : ((this._generateParticleUpdateCache[t] =
          this.generateParticleUpdate(e)),
          this._generateParticleUpdateCache[t]);
    }
    generateParticleUpdate(e) {
      return ow(e);
    }
    update(e, t) {
      e.length > this._size &&
        ((t = !0),
          (this._size = Math.max(e.length, (this._size * 1.5) | 0)),
          (this.staticAttributeBuffer = new rn(
            this._size * this._staticStride * 4 * 4
          )),
          (this.dynamicAttributeBuffer = new rn(
            this._size * this._dynamicStride * 4 * 4
          )),
          (this.indexBuffer = Hg(this._size)),
          this.geometry.indexBuffer.setDataWithSize(
            this.indexBuffer,
            this.indexBuffer.byteLength,
            !0
          ));
      const a = this.dynamicAttributeBuffer;
      if (
        (this._dynamicUpload(e, a.float32View, a.uint32View),
          this._dynamicBuffer.setDataWithSize(
            this.dynamicAttributeBuffer.float32View,
            e.length * this._dynamicStride * 4,
            !0
          ),
          t)
      ) {
        const l = this.staticAttributeBuffer;
        this._staticUpload(e, l.float32View, l.uint32View),
          this._staticBuffer.setDataWithSize(
            l.float32View,
            e.length * this._staticStride * 4,
            !0
          );
      }
    }
    destroy() {
      this._staticBuffer.destroy(),
        this._dynamicBuffer.destroy(),
        this.geometry.destroy();
    }
  }
  function cw(r) {
    const e = [];
    for (const t in r) {
      const a = r[t];
      e.push(t, a.code, a.dynamic ? "d" : "s");
    }
    return e.join("_");
  }
  var dw = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,
    uw = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;
vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,
    Wg = `
struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>,
};

fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
{
  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

   if(uniforms.uRound == 1.0) {
       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);
   }

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;
  class fw extends ei {
    constructor() {
      const e = tn.from({ vertex: uw, fragment: dw }),
        t = Ir.from({
          fragment: { source: Wg, entryPoint: "mainFragment" },
          vertex: { source: Wg, entryPoint: "mainVertex" },
        });
      super({
        glProgram: e,
        gpuProgram: t,
        resources: {
          uTexture: te.WHITE.source,
          uSampler: new Pi({}),
          uniforms: {
            uTranslationMatrix: { value: new ae(), type: "mat3x3<f32>" },
            uColor: { value: new mt(16777215), type: "vec4<f32>" },
            uRound: { value: 1, type: "f32" },
            uResolution: { value: [0, 0], type: "vec2<f32>" },
          },
        },
      });
    }
  }
  class Vg {
    constructor(e, t) {
      (this.state = gi.for2d()),
        (this.localUniforms = new ys({
          uTranslationMatrix: { value: new ae(), type: "mat3x3<f32>" },
          uColor: { value: new Float32Array(4), type: "vec4<f32>" },
          uRound: { value: 1, type: "f32" },
          uResolution: { value: [0, 0], type: "vec2<f32>" },
        })),
        (this.renderer = e),
        (this.adaptor = t),
        (this.defaultShader = new fw()),
        (this.state = gi.for2d());
    }
    validateRenderable(e) {
      return !1;
    }
    addRenderable(e, t) {
      this.renderer.renderPipes.batch.break(t), t.add(e);
    }
    getBuffers(e) {
      return e._gpuData[this.renderer.uid] || this._initBuffer(e);
    }
    _initBuffer(e) {
      return (
        (e._gpuData[this.renderer.uid] = new hw({
          size: e.particleChildren.length,
          properties: e._properties,
        })),
        e._gpuData[this.renderer.uid]
      );
    }
    updateRenderable(e) { }
    execute(e) {
      const t = e.particleChildren;
      if (t.length === 0) return;
      const a = this.renderer,
        l = this.getBuffers(e);
      e.texture || (e.texture = t[0].texture);
      const o = this.state;
      l.update(t, e._childrenDirty),
        (e._childrenDirty = !1),
        (o.blendMode = jn(e.blendMode, e.texture._source));
      const h = this.localUniforms.uniforms,
        c = h.uTranslationMatrix;
      e.worldTransform.copyTo(c),
        c.prepend(a.globalUniforms.globalUniformData.projectionMatrix),
        (h.uResolution = a.globalUniforms.globalUniformData.resolution),
        (h.uRound = a._roundPixels | e._roundPixels),
        aa(e.groupColorAlpha, h.uColor, 0),
        this.adaptor.execute(this, e);
    }
    destroy() {
      (this.renderer = null),
        this.defaultShader &&
        (this.defaultShader.destroy(), (this.defaultShader = null));
    }
  }
  class jg extends Vg {
    constructor(e) {
      super(e, new nw());
    }
  }
  jg.extension = { type: [P.WebGLPipes], name: "particle" };
  class Xg extends Vg {
    constructor(e) {
      super(e, new aw());
    }
  }
  Xg.extension = { type: [P.WebGPUPipes], name: "particle" };
  const qg = class g1 extends rw {
    constructor(e = {}) {
      (e = { ...g1.defaultOptions, ...e }),
        super({ width: e.width, height: e.height, verticesX: 4, verticesY: 4 }),
        this.update(e);
    }
    update(e) {
      (this.width = e.width ?? this.width),
        (this.height = e.height ?? this.height),
        (this._originalWidth = e.originalWidth ?? this._originalWidth),
        (this._originalHeight = e.originalHeight ?? this._originalHeight),
        (this._leftWidth = e.leftWidth ?? this._leftWidth),
        (this._rightWidth = e.rightWidth ?? this._rightWidth),
        (this._topHeight = e.topHeight ?? this._topHeight),
        (this._bottomHeight = e.bottomHeight ?? this._bottomHeight),
        (this._anchorX = e.anchor?.x),
        (this._anchorY = e.anchor?.y),
        this.updateUvs(),
        this.updatePositions();
    }
    updatePositions() {
      const e = this.positions,
        {
          width: t,
          height: a,
          _leftWidth: l,
          _rightWidth: o,
          _topHeight: h,
          _bottomHeight: c,
          _anchorX: u,
          _anchorY: d,
        } = this,
        f = l + o,
        p = t > f ? 1 : t / f,
        g = h + c,
        _ = a > g ? 1 : a / g,
        m = Math.min(p, _),
        w = u * t,
        x = d * a;
      (e[0] = e[8] = e[16] = e[24] = -w),
        (e[2] = e[10] = e[18] = e[26] = l * m - w),
        (e[4] = e[12] = e[20] = e[28] = t - o * m - w),
        (e[6] = e[14] = e[22] = e[30] = t - w),
        (e[1] = e[3] = e[5] = e[7] = -x),
        (e[9] = e[11] = e[13] = e[15] = h * m - x),
        (e[17] = e[19] = e[21] = e[23] = a - c * m - x),
        (e[25] = e[27] = e[29] = e[31] = a - x),
        this.getBuffer("aPosition").update();
    }
    updateUvs() {
      const e = this.uvs;
      (e[0] = e[8] = e[16] = e[24] = 0),
        (e[1] = e[3] = e[5] = e[7] = 0),
        (e[6] = e[14] = e[22] = e[30] = 1),
        (e[25] = e[27] = e[29] = e[31] = 1);
      const t = 1 / this._originalWidth,
        a = 1 / this._originalHeight;
      (e[2] = e[10] = e[18] = e[26] = t * this._leftWidth),
        (e[9] = e[11] = e[13] = e[15] = a * this._topHeight),
        (e[4] = e[12] = e[20] = e[28] = 1 - t * this._rightWidth),
        (e[17] = e[19] = e[21] = e[23] = 1 - a * this._bottomHeight),
        this.getBuffer("aUV").update();
    }
  };
  qg.defaultOptions = {
    width: 100,
    height: 100,
    leftWidth: 10,
    topHeight: 10,
    rightWidth: 10,
    bottomHeight: 10,
    originalWidth: 100,
    originalHeight: 100,
  };
  let pw = qg;
  class gw extends _c {
    constructor() {
      super(), (this.geometry = new pw());
    }
    destroy() {
      this.geometry.destroy();
    }
  }
  class Yg {
    constructor(e) {
      this._renderer = e;
    }
    addRenderable(e, t) {
      const a = this._getGpuSprite(e);
      e.didViewUpdate && this._updateBatchableSprite(e, a),
        this._renderer.renderPipes.batch.addToBatch(a, t);
    }
    updateRenderable(e) {
      const t = this._getGpuSprite(e);
      e.didViewUpdate && this._updateBatchableSprite(e, t),
        t._batcher.updateElement(t);
    }
    validateRenderable(e) {
      const t = this._getGpuSprite(e);
      return !t._batcher.checkAndUpdateTexture(t, e._texture);
    }
    _updateBatchableSprite(e, t) {
      t.geometry.update(e), t.setTexture(e._texture);
    }
    _getGpuSprite(e) {
      return e._gpuData[this._renderer.uid] || this._initGPUSprite(e);
    }
    _initGPUSprite(e) {
      const t = (e._gpuData[this._renderer.uid] = new gw()),
        a = t;
      return (
        (a.renderable = e),
        (a.transform = e.groupTransform),
        (a.texture = e._texture),
        (a.roundPixels = this._renderer._roundPixels | e._roundPixels),
        e.didViewUpdate || this._updateBatchableSprite(e, a),
        t
      );
    }
    destroy() {
      this._renderer = null;
    }
  }
  Yg.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "nineSliceSprite",
  };
  const mw = {
    name: "tiling-bit",
    vertex: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;
            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `,
    },
    fragment: {
      header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
      main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `,
    },
  },
    _w = {
      name: "tiling-bit",
      vertex: {
        header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
        main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `,
      },
      fragment: {
        header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
        main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `,
      },
    };
  let yc, xc;
  class yw extends ei {
    constructor() {
      yc ?? (yc = $n({ name: "tiling-sprite-shader", bits: [ra, mw, Zn] })),
        xc ?? (xc = Kn({ name: "tiling-sprite-shader", bits: [Zh, _w, Qn] }));
      const e = new ys({
        uMapCoord: { value: new ae(), type: "mat3x3<f32>" },
        uClampFrame: {
          value: new Float32Array([0, 0, 1, 1]),
          type: "vec4<f32>",
        },
        uClampOffset: { value: new Float32Array([0, 0]), type: "vec2<f32>" },
        uTextureTransform: { value: new ae(), type: "mat3x3<f32>" },
        uSizeAnchor: {
          value: new Float32Array([100, 100, 0.5, 0.5]),
          type: "vec4<f32>",
        },
      });
      super({
        glProgram: xc,
        gpuProgram: yc,
        resources: {
          localUniforms: new ys({
            uTransformMatrix: { value: new ae(), type: "mat3x3<f32>" },
            uColor: {
              value: new Float32Array([1, 1, 1, 1]),
              type: "vec4<f32>",
            },
            uRound: { value: 0, type: "f32" },
          }),
          tilingUniforms: e,
          uTexture: te.EMPTY.source,
          uSampler: te.EMPTY.source.style,
        },
      });
    }
    updateUniforms(e, t, a, l, o, h) {
      const c = this.resources.tilingUniforms,
        u = h.width,
        d = h.height,
        f = h.textureMatrix,
        p = c.uniforms.uTextureTransform;
      p.set(
        (a.a * u) / e,
        (a.b * u) / t,
        (a.c * d) / e,
        (a.d * d) / t,
        a.tx / e,
        a.ty / t
      ),
        p.invert(),
        (c.uniforms.uMapCoord = f.mapCoord),
        (c.uniforms.uClampFrame = f.uClampFrame),
        (c.uniforms.uClampOffset = f.uClampOffset),
        (c.uniforms.uTextureTransform = p),
        (c.uniforms.uSizeAnchor[0] = e),
        (c.uniforms.uSizeAnchor[1] = t),
        (c.uniforms.uSizeAnchor[2] = l),
        (c.uniforms.uSizeAnchor[3] = o),
        h &&
        ((this.resources.uTexture = h.source),
          (this.resources.uSampler = h.source.style));
    }
  }
  class xw extends $h {
    constructor() {
      super({
        positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        indices: new Uint32Array([0, 1, 2, 0, 2, 3]),
      });
    }
  }
  function vw(r, e) {
    const t = r.anchor.x,
      a = r.anchor.y;
    (e[0] = -t * r.width),
      (e[1] = -a * r.height),
      (e[2] = (1 - t) * r.width),
      (e[3] = -a * r.height),
      (e[4] = (1 - t) * r.width),
      (e[5] = (1 - a) * r.height),
      (e[6] = -t * r.width),
      (e[7] = (1 - a) * r.height);
  }
  function bw(r, e, t, a) {
    let l = 0;
    const o = r.length / e,
      h = a.a,
      c = a.b,
      u = a.c,
      d = a.d,
      f = a.tx,
      p = a.ty;
    for (t *= e; l < o;) {
      const g = r[t],
        _ = r[t + 1];
      (r[t] = h * g + u * _ + f), (r[t + 1] = c * g + d * _ + p), (t += e), l++;
    }
  }
  function Sw(r, e) {
    const t = r.texture,
      a = t.frame.width,
      l = t.frame.height;
    let o = 0,
      h = 0;
    r.applyAnchorToTexture && ((o = r.anchor.x), (h = r.anchor.y)),
      (e[0] = e[6] = -o),
      (e[2] = e[4] = 1 - o),
      (e[1] = e[3] = -h),
      (e[5] = e[7] = 1 - h);
    const c = ae.shared;
    c.copyFrom(r._tileTransform.matrix),
      (c.tx /= r.width),
      (c.ty /= r.height),
      c.invert(),
      c.scale(r.width / a, r.height / l),
      bw(e, 2, 0, c);
  }
  const Eo = new xw();
  class Mw {
    constructor() {
      (this.canBatch = !0),
        (this.geometry = new $h({
          indices: Eo.indices.slice(),
          positions: Eo.positions.slice(),
          uvs: Eo.uvs.slice(),
        }));
    }
    destroy() {
      this.geometry.destroy(), this.shader?.destroy();
    }
  }
  class $g {
    constructor(e) {
      (this._state = gi.default2d), (this._renderer = e);
    }
    validateRenderable(e) {
      const t = this._getTilingSpriteData(e),
        a = t.canBatch;
      this._updateCanBatch(e);
      const l = t.canBatch;
      if (l && l === a) {
        const { batchableMesh: o } = t;
        return !o._batcher.checkAndUpdateTexture(o, e.texture);
      }
      return a !== l;
    }
    addRenderable(e, t) {
      const a = this._renderer.renderPipes.batch;
      this._updateCanBatch(e);
      const l = this._getTilingSpriteData(e),
        { geometry: o, canBatch: h } = l;
      if (h) {
        l.batchableMesh || (l.batchableMesh = new _c());
        const c = l.batchableMesh;
        e.didViewUpdate &&
          (this._updateBatchableMesh(e),
            (c.geometry = o),
            (c.renderable = e),
            (c.transform = e.groupTransform),
            c.setTexture(e._texture)),
          (c.roundPixels = this._renderer._roundPixels | e._roundPixels),
          a.addToBatch(c, t);
      } else
        a.break(t),
          l.shader || (l.shader = new yw()),
          this.updateRenderable(e),
          t.add(e);
    }
    execute(e) {
      const { shader: t } = this._getTilingSpriteData(e);
      t.groups[0] = this._renderer.globalUniforms.bindGroup;
      const a = t.resources.localUniforms.uniforms;
      (a.uTransformMatrix = e.groupTransform),
        (a.uRound = this._renderer._roundPixels | e._roundPixels),
        aa(e.groupColorAlpha, a.uColor, 0),
        (this._state.blendMode = jn(e.groupBlendMode, e.texture._source)),
        this._renderer.encoder.draw({
          geometry: Eo,
          shader: t,
          state: this._state,
        });
    }
    updateRenderable(e) {
      const t = this._getTilingSpriteData(e),
        { canBatch: a } = t;
      if (a) {
        const { batchableMesh: l } = t;
        e.didViewUpdate && this._updateBatchableMesh(e),
          l._batcher.updateElement(l);
      } else if (e.didViewUpdate) {
        const { shader: l } = t;
        l.updateUniforms(
          e.width,
          e.height,
          e._tileTransform.matrix,
          e.anchor.x,
          e.anchor.y,
          e.texture
        );
      }
    }
    _getTilingSpriteData(e) {
      return e._gpuData[this._renderer.uid] || this._initTilingSpriteData(e);
    }
    _initTilingSpriteData(e) {
      const t = new Mw();
      return (t.renderable = e), (e._gpuData[this._renderer.uid] = t), t;
    }
    _updateBatchableMesh(e) {
      const t = this._getTilingSpriteData(e),
        { geometry: a } = t,
        l = e.texture.source.style;
      l.addressMode !== "repeat" && ((l.addressMode = "repeat"), l.update()),
        Sw(e, a.uvs),
        vw(e, a.positions);
    }
    destroy() {
      this._renderer = null;
    }
    _updateCanBatch(e) {
      const t = this._getTilingSpriteData(e),
        a = e.texture;
      let l = !0;
      return (
        this._renderer.type === pi.WEBGL &&
        (l = this._renderer.context.supports.nonPowOf2wrapping),
        (t.canBatch = a.textureMatrix.isSimple && (l || a.source.isPowerOfTwo)),
        t.canBatch
      );
    }
  }
  $g.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "tilingSprite",
  };
  const Tw = {
    name: "local-uniform-msdf-bit",
    vertex: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
      main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
      end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `,
    },
    fragment: {
      header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
      main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `,
    },
  },
    Cw = {
      name: "local-uniform-msdf-bit",
      vertex: {
        header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
        main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
        end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `,
      },
      fragment: {
        header: `
            uniform float uDistance;
         `,
        main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `,
      },
    },
    Aw = {
      name: "msdf-bit",
      fragment: {
        header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `,
      },
    },
    Pw = {
      name: "msdf-bit",
      fragment: {
        header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `,
      },
    };
  let vc, bc;
  class Ew extends ei {
    constructor(e) {
      const t = new ys({
        uColor: { value: new Float32Array([1, 1, 1, 1]), type: "vec4<f32>" },
        uTransformMatrix: { value: new ae(), type: "mat3x3<f32>" },
        uDistance: { value: 4, type: "f32" },
        uRound: { value: 0, type: "f32" },
      });
      vc ?? (vc = $n({ name: "sdf-shader", bits: [wh, Th(e), Tw, Aw, Zn] })),
        bc ?? (bc = Kn({ name: "sdf-shader", bits: [Sh, Ah(e), Cw, Pw, Qn] })),
        super({
          glProgram: bc,
          gpuProgram: vc,
          resources: { localUniforms: t, batchSamplers: Ph(e) },
        });
    }
  }
  class kw extends wo {
    destroy() {
      this.context.customShader && this.context.customShader.destroy(),
        super.destroy();
    }
  }
  class Kg {
    constructor(e) {
      this._renderer = e;
    }
    validateRenderable(e) {
      const t = this._getGpuBitmapText(e);
      return this._renderer.renderPipes.graphics.validateRenderable(t);
    }
    addRenderable(e, t) {
      const a = this._getGpuBitmapText(e);
      Zg(e, a),
        e._didTextUpdate &&
        ((e._didTextUpdate = !1), this._updateContext(e, a)),
        this._renderer.renderPipes.graphics.addRenderable(a, t),
        a.context.customShader && this._updateDistanceField(e);
    }
    updateRenderable(e) {
      const t = this._getGpuBitmapText(e);
      Zg(e, t),
        this._renderer.renderPipes.graphics.updateRenderable(t),
        t.context.customShader && this._updateDistanceField(e);
    }
    _updateContext(e, t) {
      const { context: a } = t,
        l = Nh.getFont(e.text, e._style);
      a.clear(),
        l.distanceField.type !== "none" &&
        (a.customShader ||
          (a.customShader = new Ew(
            this._renderer.limits.maxBatchableTextures
          )));
      const o = _i.graphemeSegmenter(e.text),
        h = e._style;
      let c = l.baseLineOffset;
      const u = Hf(o, h, l, !0),
        d = h.padding,
        f = u.scale;
      let p = u.width,
        g = u.height + u.offsetY;
      h._stroke && ((p += h._stroke.width / f), (g += h._stroke.width / f)),
        a.translate(-e._anchor._x * p - d, -e._anchor._y * g - d).scale(f, f);
      const _ = l.applyFillAsTint ? h._fill.color : 16777215;
      let m = l.fontMetrics.fontSize,
        w = l.lineHeight;
      h.lineHeight && ((m = h.fontSize / f), (w = h.lineHeight / f));
      let x = (w - m) / 2;
      x - l.baseLineOffset < 0 && (x = 0);
      for (let M = 0; M < u.lines.length; M++) {
        const b = u.lines[M];
        for (let T = 0; T < b.charPositions.length; T++) {
          const C = b.chars[T],
            A = l.chars[C];
          if (A?.texture) {
            const R = A.texture;
            a.texture(
              R,
              _ || "black",
              Math.round(b.charPositions[T] + A.xOffset),
              Math.round(c + A.yOffset + x),
              R.orig.width,
              R.orig.height
            );
          }
        }
        c += w;
      }
    }
    _getGpuBitmapText(e) {
      return e._gpuData[this._renderer.uid] || this.initGpuText(e);
    }
    initGpuText(e) {
      const t = new kw();
      return (e._gpuData[this._renderer.uid] = t), this._updateContext(e, t), t;
    }
    _updateDistanceField(e) {
      const t = this._getGpuBitmapText(e).context,
        a = e._style.fontFamily,
        l = We.get(`${a}-bitmap`),
        { a: o, b: h, c, d: u } = e.groupTransform,
        d = Math.sqrt(o * o + h * h),
        f = Math.sqrt(c * c + u * u),
        p = (Math.abs(d) + Math.abs(f)) / 2,
        g = l.baseRenderedFontSize / e._style.fontSize,
        _ = p * l.distanceField.range * (1 / g);
      t.customShader.resources.localUniforms.uniforms.uDistance = _;
    }
    destroy() {
      this._renderer = null;
    }
  }
  Kg.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "bitmapText",
  };
  function Zg(r, e) {
    (e.groupTransform = r.groupTransform),
      (e.groupColorAlpha = r.groupColorAlpha),
      (e.groupColor = r.groupColor),
      (e.groupBlendMode = r.groupBlendMode),
      (e.globalDisplayStatus = r.globalDisplayStatus),
      (e.groupTransform = r.groupTransform),
      (e.localDisplayStatus = r.localDisplayStatus),
      (e.groupAlpha = r.groupAlpha),
      (e._roundPixels = r._roundPixels);
  }
  class Rw extends Ao {
    constructor(e) {
      super(),
        (this.generatingTexture = !1),
        (this.currentKey = "--"),
        (this._renderer = e),
        e.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      const e = this.renderable;
      e._autoResolution && e.onViewUpdate();
    }
    destroy() {
      const { htmlText: e } = this._renderer;
      e.getReferenceCount(this.currentKey) === null
        ? e.returnTexturePromise(this.texturePromise)
        : e.decreaseReferenceCount(this.currentKey),
        this._renderer.runners.resolutionChange.remove(this),
        (this.texturePromise = null),
        (this._renderer = null);
    }
  }
  function wc(r, e) {
    const { texture: t, bounds: a } = r,
      l = e._style._getFinalPadding();
    Ed(a, e._anchor, t);
    const o = e._anchor._x * l * 2,
      h = e._anchor._y * l * 2;
    (a.minX -= l - o), (a.minY -= l - h), (a.maxX -= l - o), (a.maxY -= l - h);
  }
  class Qg {
    constructor(e) {
      this._renderer = e;
    }
    validateRenderable(e) {
      const t = this._getGpuText(e),
        a = e.styleKey;
      return t.currentKey !== a;
    }
    addRenderable(e, t) {
      const a = this._getGpuText(e);
      if (e._didTextUpdate) {
        const l = e._autoResolution ? this._renderer.resolution : e.resolution;
        (a.currentKey !== e.styleKey || e.resolution !== l) &&
          this._updateGpuText(e).catch(() => {}),
          (e._didTextUpdate = !1),
          wc(a, e);
      }
      this._renderer.renderPipes.batch.addToBatch(a, t);
    }
    updateRenderable(e) {
      const t = this._getGpuText(e);
      t._batcher.updateElement(t);
    }
    async _updateGpuText(e) {
      e._didTextUpdate = !1;
      const t = this._getGpuText(e);
      if (t.generatingTexture) return;
      const a = t.texturePromise;
      (t.texturePromise = null),
        (t.generatingTexture = !0),
        (e._resolution = e._autoResolution
          ? this._renderer.resolution
          : e.resolution);
      let l = this._renderer.htmlText.getTexturePromise(e);
      a &&
        (l = l.finally(() => {
          this._renderer.htmlText.decreaseReferenceCount(t.currentKey),
            this._renderer.htmlText.returnTexturePromise(a);
        })),
        (t.texturePromise = l),
        (t.currentKey = e.styleKey),
        (t.texture = await l);
      const o = e.renderGroup || e.parentRenderGroup;
      o && (o.structureDidChange = !0), (t.generatingTexture = !1), wc(t, e);
    }
    _getGpuText(e) {
      return e._gpuData[this._renderer.uid] || this.initGpuText(e);
    }
    initGpuText(e) {
      const t = new Rw(this._renderer);
      return (
        (t.renderable = e),
        (t.transform = e.groupTransform),
        (t.texture = te.EMPTY),
        (t.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
        (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
        (e._resolution = e._autoResolution
          ? this._renderer.resolution
          : e.resolution),
        (e._gpuData[this._renderer.uid] = t),
        t
      );
    }
    destroy() {
      this._renderer = null;
    }
  }
  Qg.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "htmlText",
  };
  function Iw() {
    const { userAgent: r } = xe.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(r);
  }
  const Bw = new cs();
  function Jg(r, e, t, a) {
    const l = Bw;
    (l.minX = 0),
      (l.minY = 0),
      (l.maxX = (r.width / a) | 0),
      (l.maxY = (r.height / a) | 0);
    const o = ss.getOptimalTexture(l.width, l.height, a, !1);
    return (
      (o.source.uploadMethodId = "image"),
      (o.source.resource = r),
      (o.source.alphaMode = "premultiply-alpha-on-upload"),
      (o.frame.width = e / a),
      (o.frame.height = t / a),
      o.source.emit("update", o.source),
      o.updateUvs(),
      o
    );
  }
  function Fw(r, e) {
    const t = e.fontFamily,
      a = [],
      l = {},
      o = /font-family:([^;"\s]+)/g,
      h = r.match(o);
    function c(u) {
      l[u] || (a.push(u), (l[u] = !0));
    }
    if (Array.isArray(t)) for (let u = 0; u < t.length; u++) c(t[u]);
    else c(t);
    h &&
      h.forEach((u) => {
        const d = u.split(":")[1].trim();
        c(d);
      });
    for (const u in e.tagStyles) {
      const d = e.tagStyles[u].fontFamily;
      c(d);
    }
    return a;
  }
  async function Gw(r) {
    const t = await (await xe.get().fetch(r)).blob(),
      a = new FileReader();
    return await new Promise((o, h) => {
      (a.onloadend = () => o(a.result)), (a.onerror = h), a.readAsDataURL(t);
    });
  }
  async function Dw(r, e) {
    const t = await Gw(e);
    return `@font-face {
        font-family: "${r.fontFamily}";
        font-weight: ${r.fontWeight};
        font-style: ${r.fontStyle};
        src: url('${t}');
    }`;
  }
  const Sc = new Map();
  async function Uw(r) {
    const e = r
      .filter((t) => We.has(`${t}-and-url`))
      .map((t) => {
        if (!Sc.has(t)) {
          const { entries: a } = We.get(`${t}-and-url`),
            l = [];
          a.forEach((o) => {
            const h = o.url,
              u = o.faces.map((d) => ({ weight: d.weight, style: d.style }));
            l.push(
              ...u.map((d) =>
                Dw(
                  { fontWeight: d.weight, fontStyle: d.style, fontFamily: t },
                  h
                )
              )
            );
          }),
            Sc.set(
              t,
              Promise.all(l).then((o) =>
                o.join(`
`)
              )
            );
        }
        return Sc.get(t);
      });
    return (await Promise.all(e)).join(`
`);
  }
  function Ow(r, e, t, a, l) {
    const { domElement: o, styleElement: h, svgRoot: c } = l;
    (o.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${r}</div>`),
      o.setAttribute(
        "style",
        `transform: scale(${t});transform-origin: top left; display: inline-block`
      ),
      (h.textContent = a);
    const { width: u, height: d } = l.image;
    return (
      c.setAttribute("width", u.toString()),
      c.setAttribute("height", d.toString()),
      new XMLSerializer().serializeToString(c)
    );
  }
  function Lw(r, e) {
    const t = Ki.getOptimalCanvasAndContext(r.width, r.height, e),
      { context: a } = t;
    return a.clearRect(0, 0, r.width, r.height), a.drawImage(r, 0, 0), t;
  }
  function Nw(r, e, t) {
    return new Promise(async (a) => {
      t && (await new Promise((l) => setTimeout(l, 100))),
        (r.onload = () => {
          a();
        }),
        (r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`),
        (r.crossOrigin = "anonymous");
    });
  }
  class em {
    constructor(e) {
      (this._activeTextures = {}),
        (this._renderer = e),
        (this._createCanvas = e.type === pi.WEBGPU);
    }
    getTexture(e) {
      return this.getTexturePromise(e);
    }
    getManagedTexture(e) {
      const t = e.styleKey;
      if (this._activeTextures[t])
        return this._increaseReferenceCount(t), this._activeTextures[t].promise;
      const a = this._buildTexturePromise(e).then(
        (l) => ((this._activeTextures[t].texture = l), l)
      );
      return (
        (this._activeTextures[t] = {
          texture: null,
          promise: a,
          usageCount: 1,
        }),
        a
      );
    }
    getReferenceCount(e) {
      return this._activeTextures[e]?.usageCount ?? null;
    }
    _increaseReferenceCount(e) {
      this._activeTextures[e].usageCount++;
    }
    decreaseReferenceCount(e) {
      const t = this._activeTextures[e];
      t &&
        (t.usageCount--,
          t.usageCount === 0 &&
          (t.texture
            ? this._cleanUp(t.texture)
            : t.promise
              .then((a) => {
                (t.texture = a), this._cleanUp(t.texture);
              })
              .catch(() => {
                pe("HTMLTextSystem: Failed to clean texture");
              }),
            (this._activeTextures[e] = null)));
    }
    getTexturePromise(e) {
      return this._buildTexturePromise(e);
    }
    async _buildTexturePromise(e) {
      const { text: t, style: a, resolution: l, textureStyle: o } = e,
        h = Ot.get(up),
        c = Fw(t, a),
        u = await Uw(c),
        d = xv(t, a, u, h),
        f = Math.ceil(Math.ceil(Math.max(1, d.width) + a.padding * 2) * l),
        p = Math.ceil(Math.ceil(Math.max(1, d.height) + a.padding * 2) * l),
        g = h.image,
        _ = 2;
      (g.width = (f | 0) + _), (g.height = (p | 0) + _);
      const m = Ow(t, a, l, u, h);
      await Nw(g, m, Iw() && c.length > 0);
      const w = g;
      let x;
      this._createCanvas && (x = Lw(g, l));
      const M = Jg(x ? x.canvas : w, g.width - _, g.height - _, l);
      return (
        o && (M.source.style = o),
        this._createCanvas &&
        (this._renderer.texture.initSource(M.source),
          Ki.returnCanvasAndContext(x)),
        Ot.return(h),
        M
      );
    }
    returnTexturePromise(e) {
      e.then((t) => {
        this._cleanUp(t);
      }).catch(() => {
        pe("HTMLTextSystem: Failed to clean texture");
      });
    }
    _cleanUp(e) {
      ss.returnTexture(e, !0),
        (e.source.resource = null),
        (e.source.uploadMethodId = "unknown");
    }
    destroy() {
      this._renderer = null;
      for (const e in this._activeTextures)
        this._activeTextures[e] &&
          this.returnTexturePromise(this._activeTextures[e].promise);
      this._activeTextures = null;
    }
  }
  em.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "htmlText",
  };
  class Hw extends Ao {
    constructor(e) {
      super(), (this._renderer = e), e.runners.resolutionChange.add(this);
    }
    resolutionChange() {
      const e = this.renderable;
      e._autoResolution && e.onViewUpdate();
    }
    destroy() {
      const { canvasText: e } = this._renderer;
      e.getReferenceCount(this.currentKey) > 0
        ? e.decreaseReferenceCount(this.currentKey)
        : this.texture && e.returnTexture(this.texture),
        this._renderer.runners.resolutionChange.remove(this),
        (this._renderer = null);
    }
  }
  class tm {
    constructor(e) {
      this._renderer = e;
    }
    validateRenderable(e) {
      const t = this._getGpuText(e),
        a = e.styleKey;
      return t.currentKey !== a ? !0 : e._didTextUpdate;
    }
    addRenderable(e, t) {
      const a = this._getGpuText(e);
      if (e._didTextUpdate) {
        const l = e._autoResolution ? this._renderer.resolution : e.resolution;
        (a.currentKey !== e.styleKey || e.resolution !== l) &&
          this._updateGpuText(e),
          (e._didTextUpdate = !1);
      }
      this._renderer.renderPipes.batch.addToBatch(a, t);
    }
    updateRenderable(e) {
      const t = this._getGpuText(e);
      t._batcher.updateElement(t);
    }
    _updateGpuText(e) {
      const t = this._getGpuText(e);
      t.texture &&
        this._renderer.canvasText.decreaseReferenceCount(t.currentKey),
        (e._resolution = e._autoResolution
          ? this._renderer.resolution
          : e.resolution),
        (t.texture = this._renderer.canvasText.getManagedTexture(e)),
        (t.currentKey = e.styleKey),
        wc(t, e);
    }
    _getGpuText(e) {
      return e._gpuData[this._renderer.uid] || this.initGpuText(e);
    }
    initGpuText(e) {
      const t = new Hw(this._renderer);
      return (
        (t.currentKey = "--"),
        (t.renderable = e),
        (t.transform = e.groupTransform),
        (t.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
        (t.roundPixels = this._renderer._roundPixels | e._roundPixels),
        (e._gpuData[this._renderer.uid] = t),
        t
      );
    }
    destroy() {
      this._renderer = null;
    }
  }
  tm.extension = {
    type: [P.WebGLPipes, P.WebGPUPipes, P.CanvasPipes],
    name: "text",
  };
  class sm {
    constructor(e) {
      (this._activeTextures = {}), (this._renderer = e);
    }
    getTexture(e, t, a, l) {
      typeof e == "string" &&
        (me(
          "8.0.0",
          "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"
        ),
          (e = { text: e, style: a, resolution: t })),
        e.style instanceof Dr || (e.style = new Dr(e.style)),
        e.textureStyle instanceof Pi ||
        (e.textureStyle = new Pi(e.textureStyle)),
        typeof e.text != "string" && (e.text = e.text.toString());
      const { text: o, style: h, textureStyle: c } = e,
        u = e.resolution ?? this._renderer.resolution,
        { frame: d, canvasAndContext: f } = ia.getCanvasAndContext({
          text: o,
          style: h,
          resolution: u,
        }),
        p = Jg(f.canvas, d.width, d.height, u);
      if (
        (c && (p.source.style = c),
          h.trim &&
          (d.pad(h.padding),
            p.frame.copyFrom(d),
            p.frame.scale(1 / u),
            p.updateUvs()),
          h.filters)
      ) {
        const g = this._applyFilters(p, h.filters);
        return this.returnTexture(p), ia.returnCanvasAndContext(f), g;
      }
      return (
        this._renderer.texture.initSource(p._source),
        ia.returnCanvasAndContext(f),
        p
      );
    }
    returnTexture(e) {
      const t = e.source;
      (t.resource = null),
        (t.uploadMethodId = "unknown"),
        (t.alphaMode = "no-premultiply-alpha"),
        ss.returnTexture(e, !0);
    }
    renderTextToCanvas() {
      me(
        "8.10.0",
        "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead"
      );
    }
    getManagedTexture(e) {
      e._resolution = e._autoResolution
        ? this._renderer.resolution
        : e.resolution;
      const t = e.styleKey;
      if (this._activeTextures[t])
        return this._increaseReferenceCount(t), this._activeTextures[t].texture;
      const a = this.getTexture({
        text: e.text,
        style: e.style,
        resolution: e._resolution,
        textureStyle: e.textureStyle,
      });
      return (this._activeTextures[t] = { texture: a, usageCount: 1 }), a;
    }
    decreaseReferenceCount(e) {
      const t = this._activeTextures[e];
      t.usageCount--,
        t.usageCount === 0 &&
        (this.returnTexture(t.texture), (this._activeTextures[e] = null));
    }
    getReferenceCount(e) {
      return this._activeTextures[e]?.usageCount ?? 0;
    }
    _increaseReferenceCount(e) {
      this._activeTextures[e].usageCount++;
    }
    _applyFilters(e, t) {
      const a = this._renderer.renderTarget.renderTarget,
        l = this._renderer.filter.generateFilteredTexture({
          texture: e,
          filters: t,
        });
      return this._renderer.renderTarget.bind(a, !1), l;
    }
    destroy() {
      this._renderer = null;
      for (const e in this._activeTextures)
        this._activeTextures[e] &&
          this.returnTexture(this._activeTextures[e].texture);
      this._activeTextures = null;
    }
  }
  (sm.extension = {
    type: [P.WebGLSystem, P.WebGPUSystem, P.CanvasSystem],
    name: "canvasText",
  }),
    ge.add(_1, y1);
  const ur = document.createElement("canvas"),
    oa = 599,
    la = 519,
    zs = { ggbg: !1, bgp2: null, gbgmc: null, bgee2: null };
  window.ur = ur;
  window.zs = zs;
  if (!ggl) {
    var im = document.createElement("img");
    (im.onload = function () {
      (ur.width = oa), (ur.height = la);
      var r = ur.getContext("2d");
      try {
        r.drawImage(this, 0, 0), (zs.bgp2 = r.createPattern(ur, "repeat"));
      } catch { }
    }),
      (im.src = "http://slither.io/s/bg54.jpg");
  }
  function rm() {
    if (zs.ggbg) {
      zs.gbgmc || (zs.gbgmc = document.createElement("canvas")),
        (zs.gbgmc.width = mww),
        (zs.gbgmc.height = mhh);
      var r = zs.gbgmc.getContext("2d");
      try {
        r.drawImage(Mc, 0, 0, 512, 512, 0, 0, mww, mhh);
      } catch { }
    }
  }
  var Mc = document.createElement("img");
  (Mc.onload = function () {
    (zs.ggbg = !0), rm();
  }),
    (Mc.src = "http://slither.io/s/gbg.jpg");
  const Kt = [],
    _t = 48,
    Ps = new Float32Array(32767),
    Es = new Float32Array(32767),
    Nr = new Float32Array(32767),
    xs = new Uint8Array(32767),
    At = [
      192, 144, 128, 128, 238, 255, 255, 255, 224, 255, 144, 80, 255, 40, 100,
      120, 72, 160, 255, 56, 56, 78, 255, 101, 128, 60, 0, 217, 255, 144, 32,
      240, 240, 240, 240, 32, 40, 104, 0, 104, 0,
    ],
    Wt = [
      128, 153, 208, 255, 238, 160, 144, 64, 48, 255, 153, 80, 192, 136, 117,
      134, 84, 80, 224, 68, 68, 35, 86, 200, 132, 192, 255, 69, 64, 144, 32, 32,
      240, 144, 32, 240, 60, 128, 0, 40, 0,
    ],
    Vt = [
      255, 255, 208, 128, 112, 96, 144, 64, 224, 255, 255, 80, 80, 96, 255, 255,
      255, 255, 64, 255, 255, 192, 9, 232, 144, 72, 83, 69, 64, 144, 240, 32,
      32, 32, 240, 32, 173, 255, 112, 170, 0,
    ];
  window.max_skin_cv = 64;
  for (var q = 0; q < At.length; q++) {
    var xi = "00" + At[q].toString(16),
      vi = "00" + Wt[q].toString(16),
      bi = "00" + Vt[q].toString(16);
    (xi = xi.substr(xi.length - 2)),
      (vi = vi.substr(vi.length - 2)),
      (bi = bi.substr(bi.length - 2));
  }
  const ha = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 37, 39,
  ];
  if (ggl) {
    var N = 72,
      se = document.createElement("canvas");
    se.width = se.height = N;
    var Y = se.getContext("2d");
    (Y.fillStyle = "#fff"),
      Y.arc(N / 2, N / 2, N / 2, 0, pi2),
      Y.fill(),
      (eyeo = {}),
      (eyeo.cc = se),
      (eyeo.sheet = 0),
      textures.push(eyeo);
    var N = 3.5 * 6 * 2,
      se = document.createElement("canvas");
    se.width = se.height = N;
    var Y = se.getContext("2d");
    (Y.fillStyle = "#000000"),
      Y.arc(N / 2, N / 2, N / 2, 0, pi2),
      Y.fill(),
      (pupilo = {}),
      (pupilo.cc = se),
      (pupilo.sheet = 0),
      textures.push(pupilo);
    var N = 3.5 * 6 * 2,
      se = document.createElement("canvas");
    se.width = se.height = N;
    var Y = se.getContext("2d");
    (Y.fillStyle = "#fff"),
      Y.arc(N / 2, N / 2, N / 2, 0, pi2),
      Y.fill(),
      (tpupilo = {}),
      (tpupilo.cc = se),
      (tpupilo.sheet = 0),
      textures.push(tpupilo);
  }
  for (var q = 0; q < At.length; q++) {
    var ee = {};
    (ee.imgs = []),
      (ee.fws = []),
      (ee.fhs = []),
      (ee.fw2s = []),
      (ee.fh2s = []),
      (ee.gimgs = []),
      (ee.gfws = []),
      (ee.gfhs = []),
      (ee.gfw2s = []),
      (ee.gfh2s = []),
      (ee.oimgs = []),
      (ee.ofws = []),
      (ee.ofhs = []),
      (ee.ofw2s = []),
      (ee.ofh2s = []);
    var xi = "00" + At[q].toString(16),
      vi = "00" + Wt[q].toString(16),
      bi = "00" + Vt[q].toString(16);
    (xi = xi.substr(xi.length - 2)),
      (vi = vi.substr(vi.length - 2)),
      (bi = bi.substr(bi.length - 2)),
      (ee.cs = "#" + xi + vi + bi);
    var N = 62,
      ca = document.createElement("canvas");
    ca.width = ca.height = N;
    var Y = ca.getContext("2d"),
      da = Y.getImageData(0, 0, N, N),
      Ri = da.data,
      Cc = Ri.length,
      ks,
      Ae = 0,
      ve = 0,
      si = q;
    q == 26
      ? (si = 3)
      : q == 29
        ? (si = 9)
        : q == 30
          ? (si = 15)
          : q == 31
            ? (si = 7)
            : q == 32
              ? (si = 4)
              : q == 33
                ? (si = 5)
                : q == 34
                  ? (si = 0)
                  : q == 35
                    ? (si = 3)
                    : q == 36 && (si = 7);
    var le = At[si],
      he = Wt[si],
      ce = Vt[si],
      nm = (le + he + ce) / 3;
    if (nm <= 24) le = he = ce = 90;
    else {
      var Tc = 120 / nm;
      (le = Math.min(255, Math.floor(le * Tc))),
        (he = Math.min(255, Math.floor(he * Tc))),
        (ce = Math.min(255, Math.floor(ce * Tc)));
    }
    for (ks = 0; ks < Cc; ks += 4) {
      var ie =
        1 - Math.sqrt(Math.pow(N / 2 - Ae, 2) + Math.pow(N / 2 - ve, 2)) / 32;
      ie < 0 ? (ie = 0) : (ie = 0.5 * (1 - Math.cos(Math.PI * ie))),
        (Ri[ks] = le),
        (Ri[ks + 1] = he),
        (Ri[ks + 2] = ce),
        (Ri[ks + 3] = Math.floor(255 * ie)),
        Ae++,
        Ae >= N && ((Ae = 0), ve++);
    }
    if ((Y.putImageData(da, 0, 0), (ee.kfmc = ca), ggl)) {
      var ko = {};
      (ko.cc = ca), (ko.sheet = 0), textures.push(ko), (ee.kfo = ko);
    }
    var Q = _t / 2,
      Ro = document.createElement("canvas");
    Ro.width = Ro.height = _t;
    var Y = Ro.getContext("2d");
    (Y.fillStyle = "#fff"), Y.arc(Q, Q, Q, 0, pi2), Y.fill();
    var da = Y.getImageData(0, 0, _t, _t),
      Ri = da.data,
      Cc = Ri.length,
      ks,
      Ae = 0,
      ve = 0,
      vs = 7,
      le,
      he,
      ce;
    q == 36 && (vs = 60);
    for (var He, pr = [], am = [], Ge = 0; Ge < vs; Ge++) {
      for (Ae = ve = 0, ks = 0; ks < Cc; ks += 4) {
        var ie,
          E = Math.max(
            0,
            Math.min(
              1,
              1 - Math.sqrt(Math.pow(Ae - Q, 2) + Math.pow(ve - Q, 2)) / 34
            )
          );
        nsr
          ? (ie = Math.pow(E, 0.5))
          : ((ie = Math.pow(
            Math.max(0, Math.min(1, 1 - Math.abs(ve - Q) / Q)),
            0.35
          )),
            (ie += (E - ie) * 0.375)),
          (le = At[q]),
          (he = Wt[q]),
          (ce = Vt[q]),
          q == 24
            ? ((E =
              Math.sqrt(
                Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
              ) / Q),
              (E = Math.pow(E * 1.05, 4)),
              E > 1 && (E = 1),
              (le += (255 * 1.2 - le) * E),
              (he += (192 * 1.2 - he) * E),
              (ce += (64 * 1.2 - ce) * E),
              (ie *= 1.22 - (0.44 * Ge) / (vs - 1)))
            : q == 26
              ? ((E =
                Math.sqrt(
                  Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                ) / Q),
                (E = Math.pow(E, 2)),
                E > 1 && (E = 1),
                (ie *= 1.22 - (0.44 * Ge) / (vs - 1)),
                (le *= ie),
                (he *= ie),
                (ce *= ie),
                (ie = 1),
                (le += (128 * 1.1 - le) * E),
                (he += (255 * 1.1 - he) * E),
                (ce += (136 * 1.1 - ce) * E))
              : q == 27
                ? ((E =
                  Math.sqrt(
                    Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                  ) / Q),
                  (E = Math.pow(E, 2)),
                  E > 1 && (E = 1),
                  (ie *= 1.22 - (0.44 * Ge) / (vs - 1)),
                  (le *= ie),
                  (he *= ie),
                  (ce *= ie),
                  (ie = 1),
                  (le += (217 * 1.1 - le) * E),
                  (he += (69 * 1.1 - he) * E),
                  (ce += (69 * 1.1 - ce) * E))
                : q == 28
                  ? ((E = 0.5 - 0.5 * Math.cos((Math.PI * Ge) / vs)),
                    (le += (128 - le) * E),
                    (he += (128 - he) * E),
                    (ce += (255 - ce) * E),
                    (ie *= 1.1),
                    ie > 1 && (ie = 1))
                  : q == 29
                    ? ((E =
                      Math.sqrt(
                        Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                      ) / Q),
                      (E = Math.pow(E, 2)),
                      E > 1 && (E = 1),
                      (ie *= 1.44 - (0.88 * Ge) / (vs - 1)),
                      (le = ie * 32),
                      (he = ie * 32),
                      (ce = ie * 32),
                      (ie = 1),
                      (le += (255 - le) * E),
                      (he += (255 - he) * E),
                      (ce += (255 - ce) * E))
                    : q == 30
                      ? ((E =
                        Math.sqrt(
                          Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                        ) / Q),
                        (E = Math.pow(E, 2)),
                        E > 1 && (E = 1),
                        (ie = (0.1 + (0.9 * Ge) / vs) % 1),
                        (le = ie * 80),
                        (he = ie * 80),
                        (ce = 128 + ie * 160),
                        (le += (255 - le) * 0.3 * E),
                        (he += (255 - he) * 0.3 * E),
                        (ce += (255 * 1.4 - ce) * 0.3 * E),
                        (ie = 1))
                      : q == 31
                        ? ((E =
                          Math.sqrt(
                            Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                          ) / Q),
                          (E = Math.pow(E, 2)),
                          E > 1 && (E = 1),
                          (ie = (0.1 + (0.9 * Ge) / vs) % 1),
                          (le = 128 + ie * 160),
                          (he = ie * 80),
                          (ce = ie * 80),
                          (le += (255 * 1.4 - le) * 0.3 * E),
                          (he += (255 - he) * 0.3 * E),
                          (ce += (255 - ce) * 0.3 * E),
                          (ie = 1))
                        : q == 32
                          ? ((E =
                            Math.sqrt(
                              Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                            ) / Q),
                            (E = Math.pow(E, 2)),
                            E > 1 && (E = 1),
                            (ie = (0.1 + (0.9 * Ge) / vs) % 1),
                            (le = 96 + ie * 128),
                            (he = 96 + ie * 128),
                            (ce = ie * 80),
                            (le += (255 * 1.2 - le) * 0.6 * E),
                            (he += (255 * 1.2 - he) * 0.6 * E),
                            (ce += (255 - ce) * 0.6 * E),
                            (ie = 1))
                          : q == 33
                            ? ((E =
                              Math.sqrt(
                                Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                              ) / Q),
                              (E = Math.pow(E, 2)),
                              E > 1 && (E = 1),
                              (ie = (0.1 + (0.9 * Ge) / vs) % 1),
                              (le = 96 + ie * 128),
                              (he = 48 + ie * 80),
                              (ce = ie * 48),
                              (le += (255 * 1.2 - le) * 0.6 * E),
                              (he += (255 * 1.1 - he) * 0.6 * E),
                              (ce += (255 - ce) * 0.6 * E),
                              (ie = 1))
                            : q == 34
                              ? ((E =
                                Math.sqrt(
                                  Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                                ) / Q),
                                (E = Math.pow(E, 2)),
                                E > 1 && (E = 1),
                                (ie = (0.1 + (0.9 * Ge) / vs) % 1),
                                (le = 96 + ie * 128),
                                (he = ie * 80),
                                (ce = 96 + ie * 128),
                                (le += (255 * 1.2 - le) * 0.6 * E),
                                (he += (255 - he) * 0.6 * E),
                                (ce += (255 * 1.2 - ce) * 0.6 * E),
                                (ie = 1))
                              : q == 35
                                ? ((E =
                                  Math.sqrt(
                                    Math.pow(0.5 * (Ae - Q), 2) + Math.pow(1 * (ve - Q), 2)
                                  ) / Q),
                                  (E = Math.pow(E, 2)),
                                  E > 1 && (E = 1),
                                  (ie = (0.1 + (0.9 * Ge) / vs) % 1),
                                  (le = ie * 80),
                                  (he = 96 + ie * 128),
                                  (ce = ie * 80),
                                  (le += (255 - le) * 0.6 * E),
                                  (he += (255 * 1.2 - he) * 0.6 * E),
                                  (ce += (255 - ce) * 0.6 * E),
                                  (ie = 1))
                                : q == 36
                                  ? ((He = (Ge / vs + 0.6 + 0.25 * (Ae / _t)) % 1),
                                    (E = (ve - Q) / _t),
                                    (E = 1.3 * (E - 1.3 * (He - 0.5))),
                                    (E = E * 2),
                                    E < 0 && (E = -E),
                                    (E *= 2.4),
                                    E < 1 &&
                                    ((le += (255 * 2.2 - le) * 1 * (1 - E)),
                                      (he += (255 * 2.2 - he) * 1 * (1 - E)),
                                      (ce += (255 * 2.2 - ce) * 1 * (1 - E))),
                                    He < 0.5
                                      ? (E = (ve - Q * 0.055 - Q) / _t)
                                      : (E = (ve + Q * 0.055 - Q) / _t),
                                    (E = 1.3 * (E - 1.3 * (He - 0.5))),
                                    (E = E * 2),
                                    E < 0 && (E = -E),
                                    (E *= 4.8),
                                    E < 1 &&
                                    ((le += (255 - le) * 1 * (1 - E)),
                                      (he += (32 - he) * 1 * (1 - E)),
                                      (ce += (64 - ce) * 1 * (1 - E))),
                                    (E = (Q - ve) / _t),
                                    (E = 1.3 * (E - 1.3 * (He - 0.5))),
                                    (E = E * 2),
                                    E < 0 && (E = -E),
                                    (E *= 2.4),
                                    E < 1 &&
                                    ((le += (255 * 2.2 - le) * 1 * (1 - E)),
                                      (he += (255 * 2.2 - he) * 1 * (1 - E)),
                                      (ce += (255 * 2.2 - ce) * 1 * (1 - E))),
                                    He < 0.5
                                      ? (E = (Q + Q * 0.055 - ve) / _t)
                                      : (E = (Q - Q * 0.055 - ve) / _t),
                                    (E = 1.3 * (E - 1.3 * (He - 0.5))),
                                    (E = E * 2),
                                    E < 0 && (E = -E),
                                    (E *= 4.8),
                                    E < 1 &&
                                    ((le += (255 - le) * 1 * (1 - E)),
                                      (he += (32 - he) * 1 * (1 - E)),
                                      (ce += (64 - ce) * 1 * (1 - E))),
                                    (E = (ve - Q) / _t),
                                    He >= 0.47 && He <= 0.53
                                      ? ((le = 255), (he = 32), (ce = 64))
                                      : E >= -0.1 && E <= 0.1
                                        ? ((He = 0.5 - He),
                                          He < 0 && (He = -He),
                                          (He = 1 - Math.pow(He / 0.5, 2)),
                                          (le += (255 - le) * He),
                                          (he += (32 - he) * He),
                                          (ce += (64 - ce) * He))
                                        : ((He >= 0.44 && He <= 0.56) || (E >= -0.15 && E <= 0.15)) &&
                                        ((He = 0.5 - He),
                                          He < 0 && (He = -He),
                                          (He = 1 - Math.pow(He / 0.5, 2)),
                                          (le += (255 - le) * He),
                                          (he += (255 - he) * He),
                                          (ce += (255 - ce) * He)),
                                    nsr ||
                                    ((ie = Math.pow(
                                      Math.max(0, Math.min(1, 1 - Math.abs(ve - Q) / Q)),
                                      0.35
                                    )),
                                      (E = Math.pow(
                                        Math.max(0, Math.min(1, 1 - Math.abs(ve - Q) / Q)),
                                        0.5
                                      )),
                                      (le += (At[q] - le) * (1 - E)),
                                      (he += (Wt[q] - he) * (1 - E)),
                                      (ce += (Vt[q] - ce) * (1 - E))))
                                  : (ie *= 1.22 - (0.44 * Ge) / (vs - 1)),
          (Ri[ks] = Math.max(0, Math.min(255, Math.floor(le * ie)))),
          (Ri[ks + 1] = Math.max(0, Math.min(255, Math.floor(he * ie)))),
          (Ri[ks + 2] = Math.max(0, Math.min(255, Math.floor(ce * ie)))),
          Ae++,
          Ae >= _t && ((Ae = 0), ve++);
      }
      Y.putImageData(da, 0, 0);
      var fn = document.createElement("canvas");
      fn.width = fn.height = _t;
      var rt = fn.getContext("2d");
      if ((rt.drawImage(Ro, 0, 0), q == 10)) {
        var gr = -1,
          mr = 1;
        nsr && ((gr = -4), (mr = 3));
        for (var Rs = gr; Rs <= mr; Rs++) {
          var _r = Q + Math.cos((2 * Math.PI * Rs) / 8) * (Q / 16) * 13,
            yr = Q + Math.sin((2 * Math.PI * Rs) / 8) * (Q / 16) * 13;
          (rt.fillStyle = "#fff"), rt.beginPath();
          for (var bt = 0; bt <= 5; bt++)
            (Ae =
              _r + Math.cos((2 * Math.PI * bt) / 5) * 24 * 0.05 * (_t / 32)),
              (ve =
                yr + Math.sin((2 * Math.PI * bt) / 5) * 24 * 0.05 * (_t / 32)),
              bt == 0 ? rt.moveTo(Ae, ve) : rt.lineTo(Ae, ve),
              (Ae =
                _r +
                Math.cos((2 * Math.PI * (bt + 0.5)) / 5) *
                62 *
                0.05 *
                (_t / 32)),
              (ve =
                yr +
                Math.sin((2 * Math.PI * (bt + 0.5)) / 5) *
                62 *
                0.05 *
                (_t / 32)),
              rt.lineTo(Ae, ve);
          rt.fill();
        }
      } else if (q == 19) {
        var gr = -2,
          mr = 2;
        nsr && ((gr = -7), (mr = 7));
        for (var Rs = gr; Rs <= mr; Rs++) {
          var _r = Q + Math.cos((2 * Math.PI * Rs) / 15) * (Q / 16) * 13,
            yr = Q + Math.sin((2 * Math.PI * Rs) / 15) * (Q / 16) * 13;
          rt.save(),
            (rt.globalAlpha = 0.7),
            (rt.fillStyle = "#fff"),
            rt.beginPath();
          for (var bt = 0; bt <= 5; bt++)
            (Ae =
              _r + Math.cos((2 * Math.PI * bt) / 5) * 12 * 0.05 * (_t / 32)),
              (ve =
                yr + Math.sin((2 * Math.PI * bt) / 5) * 12 * 0.05 * (_t / 32)),
              bt == 0 ? rt.moveTo(Ae, ve) : rt.lineTo(Ae, ve),
              (Ae =
                _r +
                Math.cos((2 * Math.PI * (bt + 0.5)) / 5) *
                31 *
                0.05 *
                (_t / 32)),
              (ve =
                yr +
                Math.sin((2 * Math.PI * (bt + 0.5)) / 5) *
                31 *
                0.05 *
                (_t / 32)),
              rt.lineTo(Ae, ve);
          rt.fill(), rt.restore();
        }
      } else if (q == 20) {
        var gr = -1.5,
          mr = 1.5;
        nsr && ((gr = -6.5), (mr = 7.5));
        for (var Rs = gr; Rs <= mr; Rs++) {
          var _r = Q + Math.cos((2 * Math.PI * Rs) / 15) * (Q / 16) * 13,
            yr = Q + Math.sin((2 * Math.PI * Rs) / 15) * (Q / 16) * 13;
          rt.save(),
            (rt.globalAlpha = 0.7),
            (rt.fillStyle = "#fff"),
            rt.beginPath();
          for (var bt = 0; bt <= 5; bt++)
            (Ae = _r + Math.cos((2 * Math.PI * bt) / 5) * 14 * 0.05 * (Q / 16)),
              (ve =
                yr + Math.sin((2 * Math.PI * bt) / 5) * 14 * 0.05 * (Q / 16)),
              bt == 0 ? rt.moveTo(Ae, ve) : rt.lineTo(Ae, ve),
              (Ae =
                _r +
                Math.cos((2 * Math.PI * (bt + 0.5)) / 5) *
                36 *
                0.05 *
                (Q / 16)),
              (ve =
                yr +
                Math.sin((2 * Math.PI * (bt + 0.5)) / 5) *
                36 *
                0.05 *
                (Q / 16)),
              rt.lineTo(Ae, ve);
          rt.fill(), rt.restore();
        }
      }
      if (iioc && testing)
        if (pr.length >= 1) pr.push(pr[0]);
        else if (Kt.length >= 2) pr.push(Kt[0].kmcs[0]);
        else {
          var xr = fn.toDataURL(),
            Is = document.createElement("img");
          (Is.src = "ayy.png"), pr.push(Is);
        }
      else pr.push(fn);
      if (ggl) {
        var Io = {};
        (Io.cc = fn), (Io.sheet = 0), textures.push(Io), am.push(Io);
      }
    }
    if (
      ((ee.kmcs = pr),
        (ee.kmos = am),
        (ee.kl = pr.length),
        (ee.klp = !0),
        q == 36 && (ee.klp = !1),
        Kt.push(ee),
        ggl)
    ) {
      var Ge = 18.8;
      if (q < 9) {
        var Bo = {},
          Fo = {},
          Go = {},
          se = document.createElement("canvas"),
          N = 64;
        se.width = se.height = N;
        var Y = se.getContext("2d"),
          Ws = 0.2,
          Gt = Y.createRadialGradient(N / 2, N / 2, 0, N / 2, N / 2, N / 2);
        Gt.addColorStop(
          0,
          "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 1)"
        ),
          Gt.addColorStop(
            0.99,
            "rgba(" +
            Math.floor(At[q] * Ws) +
            ", " +
            Math.floor(Wt[q] * Ws) +
            ", " +
            Math.floor(Vt[q] * Ws) +
            ", 1)"
          ),
          Gt.addColorStop(
            1,
            "rgba(" +
            Math.floor(At[q] * Ws) +
            ", " +
            Math.floor(Wt[q] * Ws) +
            ", " +
            Math.floor(Vt[q] * Ws) +
            ", 0)"
          ),
          (Y.fillStyle = Gt),
          Y.fillRect(0, 0, N, N),
          (Bo.cc = se),
          (Bo.sheet = 0),
          textures.push(Bo),
          (ee.wodo = Bo);
        var Ge = 18.8,
          se = document.createElement("canvas"),
          N = Math.ceil(Ge * 2.5 + 28);
        se.width = se.height = N;
        var Y = se.getContext("2d");
        (Y.fillStyle = ee.cs),
          Y.arc(N / 2, N / 2, Ge * 0.65, 0, pi2),
          (Y.shadowBlur = 12),
          (Y.shadowOffsetY = 0),
          (Y.shadowColor = ee.cs),
          (Y.globalAlpha = 0.8),
          Y.fill(),
          (Y.globalAlpha = 1),
          Y.fill(),
          (Fo.cc = se),
          (Fo.sheet = 0),
          textures.push(Fo),
          (ee.wfdo = Fo),
          (N = 64);
        var se = document.createElement("canvas");
        se.width = se.height = N;
        var Y = se.getContext("2d"),
          Gt = Y.createRadialGradient(N / 2, N / 2, 1, N / 2, N / 2, N / 2);
        Gt.addColorStop(
          0,
          "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 1)"
        ),
          Gt.addColorStop(
            1,
            "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 0)"
          ),
          (Y.fillStyle = Gt),
          Y.fillRect(0, 0, N, N),
          (Go.cc = se),
          (Go.sheet = 0),
          textures.push(Go),
          (ee.wgdo = Go),
          (N = 128);
        var se = document.createElement("canvas");
        se.width = se.height = N;
        var Y = se.getContext("2d"),
          Gt = Y.createRadialGradient(N / 2, N / 2, 1, N / 2, N / 2, 63);
        Gt.addColorStop(
          0,
          "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 1)"
        ),
          Gt.addColorStop(
            1,
            "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 0)"
          ),
          (Y.fillStyle = Gt),
          Y.fillRect(0, 0, N, N);
        var Do = {};
        (Do.cc = se), (Do.sheet = 0), textures.push(Do), (ee.gpro = Do);
      }
    } else if (q < 9)
      for (var Ge = 2.8; Ge <= 18.8; Ge += 1) {
        var se = document.createElement("canvas"),
          N = Math.ceil(Ge * 2.5 + 28);
        se.width = se.height = N;
        var Y = se.getContext("2d");
        if (
          ((Y.fillStyle = ee.cs),
            Y.arc(N / 2, N / 2, Ge * 0.65, 0, pi2),
            (Y.shadowBlur = 12),
            (Y.shadowOffsetY = 0),
            (Y.shadowColor = "#" + xi + vi + bi),
            (Y.globalAlpha = 0.8),
            Y.fill(),
            (Y.globalAlpha = 1),
            Y.fill(),
            iioc && testing)
        ) {
          var xr = se.toDataURL(),
            Is = document.createElement("img");
          (Is.src = xr), ee.imgs.push(Is);
        } else ee.imgs.push(se);
        ee.fws.push(N),
          ee.fhs.push(N),
          ee.fw2s.push(N / 2),
          ee.fh2s.push(N / 2),
          (N = Math.ceil(Ge * 8 + 6));
        var se = document.createElement("canvas");
        se.width = se.height = N;
        var Y = se.getContext("2d"),
          Gt = Y.createRadialGradient(N / 2, N / 2, 1, N / 2, N / 2, Ge * 4);
        if (
          (Gt.addColorStop(
            0,
            "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 1)"
          ),
            Gt.addColorStop(
              1,
              "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 0)"
            ),
            (Y.fillStyle = Gt),
            Y.fillRect(0, 0, N, N),
            iioc && testing)
        ) {
          var xr = se.toDataURL(),
            Is = document.createElement("img");
          (Is.src = xr), ee.gimgs.push(Is);
        } else ee.gimgs.push(se);
        ee.gfws.push(N),
          ee.gfhs.push(N),
          ee.gfw2s.push(N / 2),
          ee.gfh2s.push(N / 2);
        var se = document.createElement("canvas"),
          N = Math.ceil(Ge * 2 * 0.65 + 6);
        se.width = se.height = N;
        var Y = se.getContext("2d"),
          Ws = 0.2,
          Gt = Y.createRadialGradient(N / 2, N / 2, 0, N / 2, N / 2, Ge / 2);
        if (
          (Gt.addColorStop(
            0,
            "rgba(" + At[q] + ", " + Wt[q] + ", " + Vt[q] + ", 1)"
          ),
            Gt.addColorStop(
              0.99,
              "rgba(" +
              Math.floor(At[q] * Ws) +
              ", " +
              Math.floor(Wt[q] * Ws) +
              ", " +
              Math.floor(Vt[q] * Ws) +
              ", 1)"
            ),
            Gt.addColorStop(
              1,
              "rgba(" +
              Math.floor(At[q] * Ws) +
              ", " +
              Math.floor(Wt[q] * Ws) +
              ", " +
              Math.floor(Vt[q] * Ws) +
              ", 0)"
            ),
            (Y.fillStyle = Gt),
            Y.fillRect(0, 0, N, N),
            (Y.strokeStyle = "#000000"),
            (Y.lineWidth = 2),
            Y.arc(N / 2, N / 2, Ge * 0.65, 0, pi2),
            (Y.globalAlpha = 1),
            Y.stroke(),
            iioc && testing)
        ) {
          var xr = se.toDataURL(),
            Is = document.createElement("img");
          (Is.src = xr), ee.oimgs.push(Is);
        } else ee.oimgs.push(se);
        ee.ofws.push(N),
          ee.ofhs.push(N),
          ee.ofw2s.push(N / 2),
          ee.ofh2s.push(N / 2);
      }
    if (q < 9) {
      if (!ggl) {
        (ee.ic = ee.imgs.length),
          (ee.pr_imgs = []),
          (ee.pr_fws = []),
          (ee.pr_fhs = []),
          (ee.pr_fw2s = []),
          (ee.pr_fh2s = []);
        for (var se, N, Y, Ge = 3; Ge <= 24; Ge += 1) {
          if (
            ((se = document.createElement("canvas")),
              (N = Math.ceil(Ge * 2 + 38)),
              (se.width = se.height = N),
              (Y = se.getContext("2d")),
              (Y.fillStyle = ee.cs),
              Y.arc(N / 2, N / 2, Ge / 2, 0, pi2),
              (Y.shadowBlur = 22),
              (Y.shadowOffsetY = 0),
              (Y.shadowColor = "#" + xi + vi + bi),
              Y.fill(),
              Y.fill(),
              iioc && testing)
          ) {
            var xr = se.toDataURL(),
              Is = document.createElement("img");
            (Is.src = xr), ee.pr_imgs.push(Is);
          } else ee.pr_imgs.push(se);
          ee.pr_fws.push(N),
            ee.pr_fhs.push(N),
            ee.pr_fw2s.push(N / 2),
            ee.pr_fh2s.push(N / 2);
        }
      }
      if (ggl) {
        (se = document.createElement("canvas")),
          (N = Math.ceil(86)),
          (se.width = se.height = N),
          (Y = se.getContext("2d")),
          (Y.fillStyle = ee.cs),
          Y.arc(N / 2, N / 2, 24 / 2, 0, pi2),
          (Y.shadowBlur = 22),
          (Y.shadowOffsetY = 0),
          (Y.shadowColor = "#" + xi + vi + bi),
          Y.fill(),
          Y.fill();
        var Uo = {};
        (Uo.cc = se), (Uo.sheet = 0), textures.push(Uo), (ee.pro = Uo);
      }
    }
  }
  var om = [
    "ler did no",
    "gas the",
    "gas all",
    "gas every",
    "panis",
    "panus",
    "paynis",
    "my ass",
    "cut your",
    "heil hit",
    "flick your",
    "fingerba",
    "arse",
    "naked",
    "menstr",
    "eat my",
    "eat as",
    "lick as",
    "suck as",
    "suck my",
    "fuk",
    "dong",
    "cunn",
    "penil",
    "suck a",
    "foresk",
    "puto",
    "puta",
    "suck",
    "mierd",
    "bit.ly",
    "ilbe.co",
    "rxist.co",
    "ween",
    "wein",
    "wien",
    "peen",
    "turd",
    "wank",
    "crap",
    "ur mom",
    "tu madre",
    "chinga",
    "pu$$",
    "ch!ther",
    "phalus",
    "phallus",
    "verga",
    "culo",
    "kurwa",
    "erect",
    "schlong",
    "ureth",
    "taint",
    "pene",
    "v-cell",
    "f*ck",
  ],
    lm = [
      "buttlov",
      "buttf",
      "smegm",
      "therplu",
      "eatmy",
      "suckm",
      "sucka",
      "chither",
      "entmpw",
      "chlther",
      "ch1ther",
      "urbate",
      "erioorg",
      "eri0org",
      "erio0rg",
      "eri00rg",
      "erloorg",
      "erl0org",
      "erlo0rg",
      "erl00rg",
      "erioco",
      "lithere",
      "eriodo",
      "odskinpr",
      "therbot",
      "therb0t",
      "ragapw",
      "mydik",
      "urdik",
      "heriobo",
      "mistik",
      "ki11all",
      "agarbots",
      "rcomwith",
      "brazz",
      "iomods",
      "cunt",
      "suckdik",
      "slibot",
      "iogamep",
      "siibot",
      "garb0t",
      "herioha",
      "itherhac",
      "sucksdik",
      "sukdik",
      "deltaloves",
      "suksdik",
      "hitler",
      "assmunch",
      "lickmy",
      "hith3r",
      "fuqall",
      "fukall",
      "tobils",
      "yourmom",
      "yourmother",
      "muslimsare",
      "allmuslims",
      "themuslim",
      "jewsare",
      "alljews",
      "thejews",
      "hateblack",
      "killall",
      "allblacks",
      "allwhites",
      "lackpeop",
      "jccheesey",
      "rape",
      "hangall",
      "murderall",
    ];
  const hm = ["ass", "kkk", "titty", "titties"];
  function ua(r) {
    if (adm) return !0;
    var e = "",
      t = "",
      a = "",
      l = 0,
      o = !1,
      h = !1,
      c,
      u;
    for (c = 0; c < r.length; c++)
      (u = r.charCodeAt(c)),
        u == 32
          ? h || ((h = !0), (e += " "))
          : ((h = !1), (e += String.fromCharCode(u)));
    for (h = !1, c = 0; c < r.length; c++)
      if (
        ((u = r.charCodeAt(c)),
          (o = u >= 48 && u <= 57),
          o || (u >= 65 && u <= 90) || (u >= 97 && u <= 122))
      )
        if (
          ((t += String.fromCharCode(u)),
            (a += String.fromCharCode(u)),
            (h = !1),
            o)
        ) {
          if ((l++, l >= 7)) return !1;
        } else l = 0;
      else h || ((h = !0), (a += " "));
    var d = e.toLowerCase();
    for (c = om.length - 1; c >= 0; c--) if (d.indexOf(om[c]) >= 0) return !1;
    var f = t.toLowerCase();
    for (c = lm.length - 1; c >= 0; c--) if (f.indexOf(lm[c]) >= 0) return !1;
    var p = a.toLowerCase().split(" ");
    for (c = p.length - 1; c >= 0; c--)
      for (var g = hm.length - 1; g >= 0; g--) if (p[c] == hm[g]) return !1;
    return !0;
  }
  function fa(r, e, t, a) {
    if (e < r.gptz.length) {
      var l = r.gptz[e];
      return (l.xx = t), (l.yy = a), l;
    } else return (l = {}), (l.xx = t), (l.yy = a), r.gptz.push(l), l;
  }
  function zw() {
    var r = Date.now();
    for (i = 0; i < sos.length; i++) {
      var e = sos[i];
      e.tainted && r - e.tainted_mtm > 12e4 && (e.tainted = !1);
    }
  }
  function cm() {
    zw();
    var r, e, t;
    for (r = 0; r < sos.length; r++)
      (sos[r].ptm = 9999999), sos[r].active && sos[r].ptm--;
    var a = null,
      l = 9999999;
    for (t = clus.length - 1; t >= 0; t--) {
      var f = clus[t];
      if (f && f.ptms.length > 0) {
        var o = 0;
        for (e = f.ptms.length - 1; e >= 0; e--) o += f.ptms[e];
        o = o / f.ptms.length;
        var h = 9999999;
        for (e = f.ptms.length - 1; e >= 0; e--)
          f.ptms[e] < h && (h = f.ptms[e]);
        testing &&
          console.log(
            "cluster " + t + "   ping time: " + h + "   old ping time: " + o
          ),
          h < l && ((l = h), (a = f));
        for (var e = sos.length - 1; e >= 0; e--)
          sos[e].clu == t && (sos[e].ptm = h);
      }
    }
    var c,
      u,
      d,
      f = a;
    if (f)
      for (e = 0; e < 50; e++) {
        if (f.sos.length > 0) {
          for (c = 0, t = 0; t < f.sos.length; t++)
            (d = f.sos[t]), d.active && ((c += d.wg / f.swg), (d.ptv = c));
          for (
            d.active && (d.ptv = 1), u = Math.random(), fbso = null, t = 0;
            t < f.sos.length;
            t++
          )
            if (((d = f.sos[t]), d.active && !d.tainted)) {
              fbso = d;
              break;
            }
          for (
            t = 0;
            t < f.sos.length &&
            ((d = f.sos[t]),
              !(d.active && !d.tainted && ((fbso = d), d.ptv >= u)));
            t++
          );
          fbso && fbso.tainted && (fbso = null);
        }
        if (fbso != null) break;
      }
  }
  function Ww() {
    for (var r, e = !1, t = mos.length - 1; t >= 0; t--) {
      var a = mos[t];
      (r = !1),
        a.mo
          ? a.mof != 1 &&
          ((e = !0), (a.mof += 0.33), a.mof >= 1 && (a.mof = 1), (r = !0))
          : a.mof != 0 &&
          ((e = !0), (a.mof -= 0.2), a.mof <= 0 && (a.mof = 0), (r = !0)),
        r &&
        (a.disabled
          ? (a.upi.style.opacity = 0)
          : (a.upi.style.opacity = a.mof)),
        (r = !1),
        a.md
          ? a.mdf != 1 &&
          ((e = !0), (a.mdf += 0.33), a.mdf >= 1 && (a.mdf = 1), (r = !0))
          : a.mdf != 0 &&
          ((e = !0), (a.mdf -= 0.2), a.mdf <= 0 && (a.mdf = 0), (r = !0)),
        r &&
        (a.disabled
          ? (a.downi.style.opacity = 0)
          : (a.downi.style.opacity = a.mdf));
    }
    e || (whmos = !1);
  }
  function pa() {
    var r = {};
    return (
      (r.os = []),
      (r.end_pos = 0),
      (r.add = function (e) {
        this.end_pos == this.os.length
          ? this.os.push(e)
          : (this.os[this.end_pos] = e),
          this.end_pos++;
      }),
      (r.get = function () {
        if (this.end_pos >= 1) {
          this.end_pos--;
          var e = this.os[this.end_pos];
          return (this.os[this.end_pos] = null), e;
        }
        return null;
      }),
      r
    );
  }
  function Ji(r, e, t, a, l, o) {
    var h = {};
    (h.id = r),
      (h.xx = e),
      (h.yy = t),
      (h.rx = e),
      (h.ry = t),
      l ? (h.rsp = 3) : (h.rsp = 1),
      o > 9 && (o %= 9),
      (h.cv = o),
      (h.rad = 1e-5),
      (h.sz = a),
      (h.lrrad = h.rad);
    var c = Kt[h.cv];
    if (!c) return null;
    if (
      ((h.cv2 = Math.floor((c.ic * gsc * h.sz) / 16.5)),
        h.cv2 < 0 && (h.cv2 = 0),
        h.cv2 >= c.ic && (h.cv2 = c.ic - 1),
        ggl)
    ) {
      var u = dm.get();
      if (u)
        (h.fi = u.fi),
          (h.ofi = u.ofi),
          (h.gfi = u.gfi),
          (h.g2fi = u.g2fi),
          (h.fi.texture = c.wfdo.t),
          (h.ofi.texture = c.wodo.t),
          (h.gfi.texture = c.wgdo.t),
          (h.g2fi.texture = c.wgdo.t),
          (h.fi.visible = !1),
          (h.ofi.visible = !1),
          (h.gfi.visible = !1),
          (h.g2fi.visible = !1);
      else {
        var d = new Ke(c.wodo.t);
        d.anchor.set(0.5), (d.visible = !1), (h.ofi = d), fdlo.addChild(d);
        var f = new Ke(c.wfdo.t);
        f.anchor.set(0.5), (f.visible = !1), (h.fi = f), fdglo.addChild(f);
        var p = new Ke(c.wgdo.t);
        p.anchor.set(0.5), (p.visible = !1), (h.gfi = p), fdglo.addChild(p);
        var g = new Ke(c.wgdo.t);
        g.anchor.set(0.5), (g.visible = !1), (h.g2fi = g), g2lo.addChild(g);
      }
    } else
      (h.fi = c.imgs[h.cv2]),
        (h.fw = c.fws[h.cv2]),
        (h.fh = c.fhs[h.cv2]),
        (h.fw2 = c.fw2s[h.cv2]),
        (h.fh2 = c.fh2s[h.cv2]),
        (h.ofi = c.oimgs[h.cv2]),
        (h.ofw = c.ofws[h.cv2]),
        (h.ofh = c.ofhs[h.cv2]),
        (h.ofw2 = c.ofw2s[h.cv2]),
        (h.ofh2 = c.ofh2s[h.cv2]),
        (h.gcv = Math.floor(c.ic * gsc * (0.25 + (0.75 * h.sz) / 16.5))),
        h.gcv < 0 && (h.gcv = 0),
        h.gcv >= c.ic && (h.gcv = c.ic - 1),
        (h.gfi = c.gimgs[h.gcv]),
        (h.gfw = c.gfws[h.gcv]),
        (h.gfh = c.gfhs[h.gcv]),
        (h.gfw2 = c.gfw2s[h.gcv]),
        (h.gfh2 = c.gfh2s[h.gcv]),
        (h.g2cv = Math.floor(c.ic * gsc * 2 * (0.25 + (0.75 * h.sz) / 16.5))),
        h.g2cv < 0 && (h.g2cv = 0),
        h.g2cv >= c.ic && (h.g2cv = c.ic - 1),
        (h.g2fi = c.gimgs[h.g2cv]),
        (h.g2fw = c.gfws[h.g2cv]),
        (h.g2fh = c.gfhs[h.g2cv]),
        (h.g2fw2 = c.gfw2s[h.g2cv]),
        (h.g2fh2 = c.gfh2s[h.g2cv]);
    return (
      (h.fr = 0),
      (h.gfr = Math.random() * 64),
      (h.gr = 0.65 + 0.1 * h.sz),
      (h.wsp = (2 * Math.random() - 1) * 0.0225),
      (h.eaten_fr = 0),
      (foods[foods_c++] = h),
      h
    );
  }
  const dm = pa();
  function Oo(r) {
    ggl &&
      ((r.fi.visible = !1),
        (r.ofi.visible = !1),
        (r.gfi.visible = !1),
        (r.g2fi.visible = !1)),
      dm.add(r);
  }
  function Vw(r, e, t, a, l, o, h, c, u) {
    var d = {};
    (d.id = r),
      (d.xx = e),
      (d.yy = t),
      (d.rad = 1e-5),
      (d.sz = a),
      (d.cv = l % 9),
      (d.dir = o),
      (d.wang = h),
      (d.ang = c),
      (d.sp = u),
      (d.fr = 0),
      (d.gfr = Math.random() * 64),
      (d.gr = 0.5 + Math.random() * 0.15 + 0.1 * d.sz),
      (d.rr = Math.min(255, At[l])),
      (d.gg = Math.min(255, Wt[l])),
      (d.bb = Math.min(255, Vt[l]));
    var f = "00" + Math.min(255, Math.max(0, Math.round(d.rr))).toString(16),
      p = "00" + Math.min(255, Math.max(0, Math.round(d.gg))).toString(16),
      g = "00" + Math.min(255, Math.max(0, Math.round(d.bb))).toString(16);
    (f = f.substr(f.length - 2)),
      (p = p.substr(p.length - 2)),
      (g = g.substr(g.length - 2));
    var _ = Kt[d.cv];
    if (!_) return null;
    if (
      ((d.cs = "#" + f + p + g),
        ggl ||
        ((d.cv2 = Math.floor((_.pr_imgs.length * gsc * d.sz) / 9)),
          d.cv2 < 0 && (d.cv2 = 0),
          d.cv2 >= _.pr_imgs.length && (d.cv2 = _.pr_imgs.length - 1)),
        ggl)
    ) {
      var m,
        w,
        x = um.get();
      x
        ? ((m = x.pri),
          (d.pri = m),
          (m.texture = _.pro.t),
          (w = x.gpri),
          (d.gpri = w),
          (w.texture = _.gpro.t))
        : ((m = new Ke(_.pro.t)),
          m.anchor.set(0.5),
          (d.pri = m),
          prlo.addChild(m),
          (w = new Ke(_.gpro.t)),
          w.anchor.set(0.5),
          (d.gpri = w),
          prglo.addChild(w)),
        (m.visible = !0),
        (w.visible = !0);
    } else
      (d.fi = _.pr_imgs[d.cv2]),
        (d.fw = _.pr_fws[d.cv2]),
        (d.fh = _.pr_fhs[d.cv2]),
        (d.fw2 = _.pr_fw2s[d.cv2]),
        (d.fh2 = _.pr_fh2s[d.cv2]),
        (d.gcv = _.gimgs.length - 1),
        (d.gfi = _.gimgs[d.gcv]),
        (d.gfw = _.gfws[d.gcv]),
        (d.gfh = _.gfhs[d.gcv]),
        (d.gfw2 = _.gfw2s[d.gcv]),
        (d.gfh2 = _.gfh2s[d.gcv]);
    return (
      (d.fxs = new Float32Array(is)),
      (d.fys = new Float32Array(is)),
      (d.fpos = 0),
      (d.ftg = 0),
      (d.fx = 0),
      (d.fy = 0),
      (d.eaten = !1),
      (d.eaten_fr = 0),
      preys.push(d),
      d
    );
  }
  const um = pa();
  function Lo(r) {
    ggl && ((r.pri.visible = !1), (r.gpri.visible = !1)), um.add(r);
  }
  const No = 100,
    Ac = 53,
    nt = Ac,
    is = Ac,
    er = 26,
    tr = Ac,
    Hr = 38,
    Pc = pa(),
    jw = pa(),
    Xw = pa();
  class qw {
    constructor() {
      (this.app = null),
        (this.bgx2 = 0),
        (this.bgy2 = 0),
        (this.smuc_m3 = No - 3),
        (this.smus = new Float32Array(No)),
        (this.fmlts = []),
        (this.fpsls = []),
        (this.mscps = 0),
        (this.sector_size = 480),
        (this.ssd256 = this.sector_size / 256),
        (this.sector_count_along_edge = 130),
        (this.spangdv = 4.8),
        (this.nsp1 = 4.25),
        (this.nsp2 = 0.5),
        (this.nsp3 = 12),
        (this.mamu = 0.033),
        (this.mamu2 = 0.028),
        (this.cst = 0.43),
        (this.default_msl = 42),
        (this.want_quality = 1),
        (this.alcsc = new Uint8Array(256)),
        (this.ralcsc = new Uint8Array(256)),
        (this.falcsc = new Uint8Array(256)),
        (this.flxas = []);
      for (let t = 0; t < Hr; t++)
        this.flxas[t] = 0.5 * (1 - Math.cos((Math.PI * t) / (Hr - 1)));
      this.lfas = new Float32Array(tr);
      for (let t = 0; t < tr; t++)
        this.lfas[t] =
          0.5 * (1 - Math.cos((Math.PI * (tr - 1 - t)) / (tr - 1)));
      this.rfas = new Float32Array(is);
      for (let t = 0; t < is; t++)
        this.rfas[t] =
          0.5 * (1 - Math.cos((Math.PI * (is - 1 - t)) / (is - 1)));
      for (this.hfas = new Float32Array(nt), e = 0; e < nt; e++)
        this.hfas[e] =
          0.5 * (1 - Math.cos((Math.PI * (nt - 1 - e)) / (nt - 1)));
      for (this.afas = new Float32Array(er), e = 0; e < er; e++)
        this.afas[e] =
          0.5 * (1 - Math.cos((Math.PI * (er - 1 - e)) / (er - 1)));
      for (var e = 0; e <= 255; e++) (this.ralcsc[e] = 0), (this.falcsc[e] = 0);
      for (var e = ha.length - 1; e >= 0; e--)
        (this.ralcsc[ha[e]] = 1), (this.falcsc[ha[e]] = 1);
      (this.falcsc[40] = 1), (this.alcsc = this.ralcsc), this.recalcSepMults();
    }
    setMscps(e) {
      if (e != G.mscps) {
        (this.mscps = e), (this.fmlts = []), (this.fpsls = []);
        for (let l = 0; l <= this.mscps; l++)
          l >= this.mscps
            ? this.fmlts.push(this.fmlts[l - 1])
            : this.fmlts.push(Math.pow(1 - l / this.mscps, 2.25)),
            l == 0
              ? this.fpsls.push(0)
              : this.fpsls.push(this.fpsls[l - 1] + 1 / this.fmlts[l - 1]);
        let t = this.fmlts[this.fmlts.length - 1],
          a = this.fpsls[this.fpsls.length - 1];
        for (let l = 0; l < 2048; l++) this.fmlts.push(t), this.fpsls.push(a);
      }
    }
    recalcSepMults() {
      this.smus = new Float32Array(No);
      let e = 0,
        t = 3,
        a = 0;
      for (let l = 0; l < No; l++)
        l < t
          ? (this.smus[l] = 1)
          : (e++, e <= 4 && (a = (this.cst * e) / 4), (this.smus[l] = 1 - a));
    }
    destroySlitherAtIndex(e) {
      var t = slithers[e];
      slithers.splice(e, 1),
        ggl &&
        ((t.lsgvc = 0),
          (t.sgsv = []),
          t.uglo.destroy({ children: !0 }),
          t.shlo.destroy({ children: !0 }),
          t.sglo.destroy({ children: !0 }),
          t.sflo.destroy({ children: !0 }),
          t.sdlo.destroy({ children: !0 }),
          t.eyelo.destroy({ children: !0 }),
          t.nko && t.nko.destroy({ children: !0 }),
          suglo.removeChild(t.uglo),
          shilo.removeChild(t.shlo),
          slilo.removeChild(t.sglo),
          slilo.removeChild(t.eyelo),
          sfilo.removeChild(t.sflo),
          sdilo.removeChild(t.sdlo));
    }
    resetGame() {
      ws && (ws.close(), (ws = null)), (want_close_socket = !1);
      for (var e = slithers.length - 1; e >= 0; e--)
        this.destroySlitherAtIndex(e);
      (slithers = []), (slither = null);
      for (var e = foods_c - 1; e >= 0; e--) Oo(foods[e]);
      (foods = []), (foods_c = 0);
      for (var e = preys.length - 1; e >= 0; e--) Lo(preys[e]);
      for (
        preys = [],
        sectors = [],
        os = {},
        rank = 0,
        best_rank = 999999999,
        slither_count = 0,
        biggest_slither_count = 0,
        connected = !1,
        playing = !1,
        wfpr = !1,
        lagging = !1,
        j = vfc - 1;
        j >= 0;
        j--
      )
        (fvxs[j] = 0), (fvys[j] = 0);
      (fvtg = 0),
        (fvx = 0),
        (fvy = 0),
        (lag_mult = 1),
        (cptm = 0),
        (mmal = 0),
        (mmgad = !1);
      var t = asmc.getContext("2d");
      t.clearRect(0, 0, mmsz, mmsz);
      var t = asmc2.getContext("2d");
      t.clearRect(0, 0, mmsz, mmsz), (gsc = sgsc), (targetGsc = sgsc);
    }
  }
  const G = new qw();
  var Ho = document.createElement("canvas");
  Ho.width = Ho.height = 48;
  var ue = Ho.getContext("2d");
  (ue.fillStyle = "#000000"),
    ue.moveTo(36, 6),
    ue.lineTo(30, 6),
    ue.quadraticCurveTo(0, 24, 30, 42),
    ue.lineTo(36, 42),
    ue.quadraticCurveTo(14, 24, 36, 6),
    ue.fill();
  var vr = document.createElement("canvas"),
    ga;
  if (ggl) {
    vr.width = vr.height = 64;
    var ue = vr.getContext("2d");
    (ue.fillStyle = "#FF7755"),
      ue.arc(32, 32, 32, 0, pi2),
      ue.fill(),
      (ga = {}),
      (ga.cc = vr),
      (ga.sheet = 0),
      textures.push(ga);
  } else {
    vr.width = vr.height = 32;
    var ue = vr.getContext("2d");
    (ue.fillStyle = "#FF9966"), ue.arc(16, 16, 16, 0, pi2), ue.fill();
  }
  var we = 52,
    pn = document.createElement("canvas");
  pn.width = pn.height = we;
  var ue = pn.getContext("2d"),
    wi = ue.getImageData(0, 0, we, we),
    tt = wi.data,
    zr = tt.length,
    De,
    Lt = 0,
    ii = 0;
  for (De = 0; De < zr; De += 4) {
    var _e = Math.abs(
      Math.sqrt(Math.pow(we / 2 - Lt, 2) + Math.pow(we / 2 - ii, 2)) - 16
    );
    _e <= 4 ? (_e = 1 - _e / 4) : (_e = 0),
      (_e *= 0.8),
      (tt[De] = tt[De + 1] = tt[De + 2] = 0),
      (tt[De + 3] = Math.floor(255 * _e)),
      Lt++,
      Lt >= we && ((Lt = 0), ii++);
  }
  if ((ue.putImageData(wi, 0, 0), iioc && testing)) {
    var Yw = pn.toDataURL(),
      fm = document.createElement("img");
    (fm.src = Yw), (pn = fm);
  }
  we = 62;
  var ma = document.createElement("canvas");
  ma.width = ma.height = we;
  var ue = ma.getContext("2d"),
    wi = ue.getImageData(0, 0, we, we),
    tt = wi.data,
    zr = tt.length,
    De,
    Lt = 0,
    ii = 0;
  for (De = 0; De < zr; De += 4) {
    var _e =
      Math.sqrt(Math.pow(we / 2 - Lt, 2) + Math.pow(we / 2 + 4 - ii, 2)) - 15;
    (_e *= 0.1),
      _e < 0 && (_e = -_e),
      _e > 1 && (_e = 1),
      (_e = 1 - _e),
      (_e *= 0.25),
      (tt[De] = tt[De + 1] = tt[De + 2] = 0),
      (tt[De + 3] = Math.floor(255 * _e)),
      Lt++,
      Lt >= we && ((Lt = 0), ii++);
  }
  ue.putImageData(wi, 0, 0);
  var zo = {};
  ggl && ((zo.cc = ma), (zo.sheet = 0), textures.push(zo));
  var we = 64,
    _a = document.createElement("canvas");
  _a.width = _a.height = we;
  var ue = _a.getContext("2d");
  (ue.fillStyle = "#fff"),
    ue.beginPath(),
    ue.arc(we / 2, we / 2, we / 2, 0, pi2),
    ue.fill();
  var wi = ue.getImageData(0, 0, we, we),
    tt = wi.data,
    zr = tt.length,
    De,
    Lt = 0,
    ii = 0;
  for (De = 0; De < zr; De += 4) {
    var _e =
      Math.abs(
        we / 2 - Math.sqrt(Math.pow(we / 2 - Lt, 2) + Math.pow(we / 2 - ii, 2))
      ) /
      (we / 2);
    (_e = _e * 1.06 - 0.06),
      _e < 0 ? (_e = 0) : ((_e = Math.pow(_e, 0.35)), (_e *= 1.35)),
      (_e += (1 - _e) * 0.25),
      (tt[De] = Math.max(0, Math.min(255, Math.round(72 * _e)))),
      (tt[De + 1] = Math.max(0, Math.min(255, Math.round(255 * _e)))),
      (tt[De + 2] = Math.max(0, Math.min(255, Math.round(116 * _e)))),
      Lt++,
      Lt >= we && ((Lt = 0), ii++),
      (_e =
        we / 2 -
        Math.sqrt(Math.pow(we / 2 - Lt, 2) + Math.pow(we / 2 - ii, 2))),
      _e <= 3
        ? (tt[De + 3] = Math.max(0, Math.min(255, Math.round((_e / 3) * 255))))
        : (tt[De + 3] = 255);
  }
  ue.putImageData(wi, 0, 0);
  var ya;
  ggl && ((ya = {}), (ya.cc = _a), (ya.sheet = 0), textures.push(ya));
  var we = 48,
    xa = document.createElement("canvas");
  xa.width = xa.height = we;
  var ue = xa.getContext("2d");
  (ue.fillStyle = "#fff"),
    ue.beginPath(),
    ue.arc(we / 2, we / 2, we / 2, 0, pi2),
    ue.fill();
  var wi = ue.getImageData(0, 0, we, we),
    tt = wi.data,
    zr = tt.length,
    De,
    Lt = 0,
    ii = 0;
  for (De = 0; De < zr; De += 4) {
    var _e =
      Math.abs(
        we / 2 - Math.sqrt(Math.pow(we / 2 - Lt, 2) + Math.pow(we / 2 - ii, 2))
      ) /
      (we / 2);
    _e > 0.5 ? (_e = 0) : (_e = 1 - Math.pow(_e / 0.5, 1)),
      (_e *= 0.8),
      _e == 0
        ? ((tt[De] = 0), (tt[De + 1] = 0), (tt[De + 2] = 0))
        : ((tt[De] = Math.max(0, Math.min(255, Math.round(28 + 59 * _e)))),
          (tt[De + 1] = Math.max(0, Math.min(255, Math.round(83 + 85 * _e)))),
          (tt[De + 2] = Math.max(
            0,
            Math.min(255, Math.round(128 + 110 * _e))
          ))),
      Lt++,
      Lt >= we && ((Lt = 0), ii++);
  }
  ue.putImageData(wi, 0, 0);
  var va;
  ggl && ((va = {}), (va.cc = xa), (va.sheet = 0), textures.push(va));
  var Ec = document.createElement("canvas");
  Ec.width = Ec.height = 64;
  var ue = Ec.getContext("2d"),
    ri = ue.createRadialGradient(32, 32, 1, 32, 32, 31);
  ri.addColorStop(0, "rgba(255, 255, 255, 1)"),
    ri.addColorStop(0.83, "rgba(150,150,150, 1)"),
    ri.addColorStop(0.84, "rgba(80,80,80, 1)"),
    ri.addColorStop(0.99, "rgba(80,80,80, 1)"),
    ri.addColorStop(1, "rgba(80,80,80, 0)"),
    (ue.fillStyle = ri),
    ue.fillRect(0, 0, 64, 64);
  var Wo = document.createElement("canvas");
  (Wo.width = 84), (Wo.height = 84);
  var ba = document.createElement("canvas");
  (ba.width = 84), (ba.height = 84);
  var ue = ba.getContext("2d");
  (ue.fillStyle = "#ff5609"),
    ue.fillRect(13, 10, 58 / 2, 64),
    ue.fillRect(13, 10, 58, 22),
    ue.fillRect(13, 54, 58, 22);
  var ue = Wo.getContext("2d");
  (ue.shadowColor = "#000000"),
    (ue.shadowBlur = 20),
    ue.drawImage(ba, 0, 0),
    ue.drawImage(ba, 0, 0);
  var Vo = document.createElement("canvas");
  Vo.width = Vo.height = 64;
  var ue = Vo.getContext("2d"),
    ri = ue.createRadialGradient(32, 32, 1, 32, 32, 31);
  ri.addColorStop(0, "rgba(255, 128, 128, 1)"),
    ri.addColorStop(0.5, "rgba(222, 3, 3, 1)"),
    ri.addColorStop(0.96, "rgba(157, 18, 18, 1)"),
    ri.addColorStop(1, "rgba(0,0,0, 0)"),
    (ue.fillStyle = ri),
    ue.fillRect(0, 0, 64, 64);
  var jo = document.createElement("canvas");
  (jo.width = 172), (jo.height = 113);
  var kc = document.createElement("img");
  (kc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 172), (r.height = 113);
    var e = r.getContext("2d");
    e.drawImage(kc, 21, 21);
    var e = jo.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (kc.src = "http://slither.io/s/kwk6.png");
  var Xo = document.createElement("canvas");
  (Xo.width = 79), (Xo.height = 130);
  var Rc = document.createElement("img");
  (Rc.onload = function () {
    var r = Xo.getContext("2d");
    r.drawImage(Rc, 0, 0);
  }),
    (Rc.src = "http://slither.io/s/jmou3.png");
  var qo = document.createElement("canvas");
  (qo.width = 190), (qo.height = 188);
  var Ic = document.createElement("img");
  (Ic.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 190), (r.height = 188);
    var e = r.getContext("2d");
    e.drawImage(Ic, 21, 21);
    var e = qo.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Ic.src = "http://slither.io/s/pewd.png");
  var Yo = document.createElement("canvas");
  (Yo.width = 142), (Yo.height = 149);
  var Bc = document.createElement("img");
  (Bc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 142), (r.height = 149);
    var e = r.getContext("2d");
    e.drawImage(Bc, 21, 21);
    var e = Yo.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Bc.src = "http://slither.io/s/play.png");
  var $o = document.createElement("canvas");
  ($o.width = 173), ($o.height = 178);
  var Fc = document.createElement("img");
  (Fc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 173), (r.height = 178);
    var e = r.getContext("2d");
    e.drawImage(Fc, 21, 21);
    var e = $o.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Fc.src = "http://slither.io/s/bonkers2.png");
  var Ko = document.createElement("canvas");
  (Ko.width = 143), (Ko.height = 161);
  var Gc = document.createElement("img");
  (Gc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 143), (r.height = 161);
    var e = r.getContext("2d");
    e.drawImage(Gc, 21, 21);
    var e = Ko.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Gc.src = "http://slither.io/s/leaf.png");
  var Zo = document.createElement("canvas");
  (Zo.width = 140), (Zo.height = 140);
  var Dc = document.createElement("img");
  (Dc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 140), (r.height = 140);
    var e = r.getContext("2d");
    e.drawImage(Dc, 21, 21);
    var e = Zo.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Dc.src = "http://slither.io/s/swiss.png");
  var Qo = document.createElement("canvas");
  (Qo.width = 162), (Qo.height = 137);
  var Uc = document.createElement("img");
  (Uc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 162), (r.height = 137);
    var e = r.getContext("2d");
    e.drawImage(Uc, 21, 21);
    var e = Qo.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Uc.src = "http://slither.io/s/moldova.png");
  var Jo = document.createElement("canvas");
  (Jo.width = 137), (Jo.height = 142);
  var Oc = document.createElement("img");
  (Oc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 137), (r.height = 142);
    var e = r.getContext("2d");
    e.drawImage(Oc, 21, 21);
    var e = Jo.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Oc.src = "http://slither.io/s/vietnam.png");
  var el = document.createElement("canvas");
  (el.width = 152), (el.height = 152);
  var Lc = document.createElement("img");
  (Lc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 152), (r.height = 152);
    var e = r.getContext("2d");
    e.drawImage(Lc, 21, 21);
    var e = el.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Lc.src = "http://slither.io/s/argentina.png");
  var tl = document.createElement("canvas");
  (tl.width = 142), (tl.height = 163);
  var Nc = document.createElement("img");
  (Nc.onload = function () {
    var r = document.createElement("canvas");
    (r.width = 142), (r.height = 163);
    var e = r.getContext("2d");
    e.drawImage(Nc, 21, 21);
    var e = tl.getContext("2d");
    (e.shadowColor = "#000000"), (e.shadowBlur = 20), e.drawImage(r, 0, 0);
  }),
    (Nc.src = "http://slither.io/s/mov2.png");
  const be = {
    komc: pn,
    ksmc: ma,
    bonkbulb: $o,
    movbulb: tl,
    argentinabulb: el,
    vietnambulb: Jo,
    moldovabulb: Qo,
    playbulb: Yo,
    swissbulb: Zo,
    leafbulb: Ko,
    sest: null,
    sestt: null,
    ecmc: Ho,
    jmou: Xo,
    acbulb: Vo,
    cdbulb: Wo,
    pwdbulb: qo,
    kwkbulb: jo,
    jsebi: _a,
    jsepi: xa,
    jsebo: ya,
    jsepo: va,
    kdmc: vr,
    kso: zo,
    kdo: ga,
  };
  if (ggl)
    (async () =>
      (be.sestt = await Ur.load("https://slither.io/s2/sest5.png")))();
  else {
    const r = document.createElement("canvas");
    (r.width = 105), (r.height = 88);
    var Hc = document.createElement("img");
    (Hc.onload = function () {
      var e = r.getContext("2d");
      e.drawImage(Hc, 0, 0);
    }),
      (Hc.src = "https://slither.io/s2/sest5.png"),
      (be.sest = r);
  }
  function Ii(r, e, t) {
    if (!(r.dead_amt > 0)) {
      if (
        (ggl &&
          (r.sglo &&
            ((r.lsgvc = 0),
              (r.sgs = []),
              (r.shs = []),
              (r.shs2 = []),
              (r.sfs = []),
              (r.sfus = []),
              (r.sgsv = []),
              (r.sds = []),
              r.uglo.destroy({ children: !0 }),
              r.shlo.destroy({ children: !0 }),
              r.sglo.destroy({ children: !0 }),
              r.sflo.destroy({ children: !0 }),
              r.sdlo.destroy({ children: !0 }),
              r.eyelo.destroy({ children: !0 }),
              suglo.removeChild(r.uglo),
              shilo.removeChild(r.shlo),
              slilo.removeChild(r.sglo),
              slilo.removeChild(r.eyelo),
              sfilo.removeChild(r.sflo),
              sdilo.removeChild(r.sdlo),
              (r.sglo = null)),
            r.jse &&
            (r.ebi.destroy({ children: !0 }), r.epi.destroy({ children: !0 })),
            r.slg &&
            (r.stem1.destroy({ children: !0 }),
              r.stem2.destroy({ children: !0 }))),
          (r.rcv = e),
          (r.er = 6),
          (r.pr = 3.5),
          (r.pma = 2.3),
          (r.ec = "#fff"),
          (r.ecv = 16777215),
          (r.eca = 0.75),
          (r.ppa = 1),
          (r.ppc = "#000000"),
          (r.ppcv = 0),
          (r.antenna = !1),
          (r.one_eye = !1),
          (r.drez = !1),
          (r.ed = 6),
          (r.esp = 6),
          (r.easp = 0.1),
          (r.eac = !1),
          (r.jyt = !1),
          (r.jse = !1),
          (r.slg = !1),
          (r.eo = 0),
          (r.swell = 0),
          (r.cusk = !1),
          t != null)
      ) {
        var a = t.length;
        if (a >= 10) {
          for (var l, o = 8, h = [], c = 0, u = 0; o < a;)
            if (((c = t[o]), o++, o < a && ((u = t[o]), o++, G.alcsc[u] == 1)))
              for (l = 0; l < c; l++) h.push(u);
          h.length > 0 &&
            ((r.rbcs = h), (e = r.rbcs[0]), (r.cv = e), (r.cusk = !0));
        }
      }
      var d = null,
        f = null,
        p = 0;
      if (!r.cusk) {
        if (e == 24) {
          (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#00688c"),
            (r.atc2 = "#64c8e7"),
            (r.atwg = !0),
            (r.atia = 0.35),
            (r.abrot = !1);
          var g = 8;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.acbulb),
            (r.blbx = -10),
            (r.blby = -10),
            (r.blbw = 20),
            (r.blbh = 20),
            (r.bsc = 1),
            (r.blba = 0.75);
        } else if (e == 25) {
          (r.ec = "#FF5609"),
            (r.ecv = 16733705),
            (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#000000"),
            (r.atc2 = "#5630d7"),
            (r.atia = 1),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.cdbulb),
            (r.blbx = -5),
            (r.blby = -10),
            (r.blbw = 20),
            (r.blbh = 20),
            (r.bsc = 1.6),
            (r.blba = 1);
        } else if (e == 27)
          (r.jse = !0),
            (r.one_eye = !0),
            (r.ebi = be.jsebi),
            (r.ebiw = 64),
            (r.ebih = 64),
            (r.ebisz = 29),
            (r.epi = be.jsepi),
            (r.epiw = 48),
            (r.epih = 48),
            (r.episz = 14),
            (r.pma = 4),
            (r.swell = 0.06);
        else if (e == 37) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#301400"),
            (r.atc2 = "#ff6813"),
            (r.atwg = !0),
            (r.atia = 0.5),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.kwkbulb),
            (r.blbx = -39),
            (r.blby = -63),
            (r.blbw = 172),
            (r.blbh = 113),
            (r.bsc = 0.42),
            (r.blba = 1);
        } else if (e == 39) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#1d3245"),
            (r.atc2 = "#44d4ff"),
            (r.atwg = !0),
            (r.atia = 0.43),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.pwdbulb),
            (r.blbx = -36),
            (r.blby = -100),
            (r.blbw = 190),
            (r.blbh = 188),
            (r.bsc = 0.25),
            (r.blba = 1);
        } else if (e == 40) (r.eac = !0), (r.jyt = !0);
        else if (e == 41)
          (r.ed = 34),
            (r.esp = 14),
            (r.eca = 1),
            (r.eo = 3),
            (r.er = 8),
            (r.easp = 0.038),
            (r.pr = 4.5),
            (r.pma = 3),
            (r.slg = !0);
        else if (e == 42) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#002828"),
            (r.atc2 = "#80d0d0"),
            (r.atwg = !0),
            (r.atia = 0.5),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.playbulb),
            (r.blbx = -29),
            (r.blby = -74),
            (r.blbw = 142),
            (r.blbh = 149),
            (r.bsc = 0.36),
            (r.blba = 1);
        } else if (e == 44) (r.ec = "#D4D4D4"), (r.ecv = 13948116);
        else if (e == 45) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#c02020"),
            (r.atc2 = "#ff4040"),
            (r.atwg = !0),
            (r.atia = 0.5),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.leafbulb),
            (r.blbx = -11.11 - 21),
            (r.blby = -81),
            (r.blbw = 143),
            (r.blbh = 161),
            (r.bsc = 0.33),
            (r.blba = 1);
        } else if (e == 46) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#c02020"),
            (r.atc2 = "#ff4040"),
            (r.atwg = !0),
            (r.atia = 0.5),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.swissbulb),
            (r.blbx = -10.78 - 21),
            (r.blby = -70),
            (r.blbw = 140),
            (r.blbh = 140),
            (r.bsc = 0.285),
            (r.blba = 1);
        } else if (e == 47) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#3030ff"),
            (r.atc2 = "#6060ff"),
            (r.atwg = !0),
            (r.atia = 0.5),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.moldovabulb),
            (r.blbx = -13.2 - 21),
            (r.blby = -69),
            (r.blbw = 162),
            (r.blbh = 137),
            (r.bsc = 0.33),
            (r.blba = 1);
        } else if (e == 48) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#c02020"),
            (r.atc2 = "#ff4040"),
            (r.atwg = !0),
            (r.atia = 0.75),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.vietnambulb),
            (r.blbx = -10.45 - 21),
            (r.blby = -71),
            (r.blbw = 137),
            (r.blbh = 142),
            (r.bsc = 0.3),
            (r.blba = 1);
        } else if (e == 49) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#64accf"),
            (r.atc2 = "#84dcff"),
            (r.atwg = !0),
            (r.atia = 0.7),
            (r.abrot = !0);
          var g = 11;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.argentinabulb),
            (r.blbx = -12.1 - 21),
            (r.blby = -76),
            (r.blbw = 152),
            (r.blbh = 152),
            (r.bsc = 0.3),
            (r.blba = 1);
        } else if (e == 59) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#886818"),
            (r.atc2 = "#ffe040"),
            (r.atwg = !0),
            (r.atia = 0.55),
            (r.abrot = !0);
          var g = 11;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.movbulb),
            (r.blbx = -41),
            (r.blby = -91),
            (r.blbw = 142),
            (r.blbh = 163),
            (r.bsc = 0.3),
            (r.blba = 1);
        } else if (e == 60) r.drez = !0;
        else if (e == 62) {
          (r.eca = 1),
            (r.antenna = !0),
            (r.atba = 0),
            (r.atc1 = "#402200"),
            (r.atc2 = "#ffc20f"),
            (r.atwg = !0),
            (r.atia = 0.5),
            (r.abrot = !0);
          var g = 9;
          (r.atx = new Float32Array(g)),
            (r.aty = new Float32Array(g)),
            (r.atvx = new Float32Array(g)),
            (r.atvy = new Float32Array(g)),
            (r.atax = new Float32Array(g)),
            (r.atay = new Float32Array(g));
          for (var _ = g - 1; _ >= 0; _--) (r.atx[_] = r.xx), (r.aty[_] = r.yy);
          (r.bulb = be.bonkbulb),
            (r.blbx = -29),
            (r.blby = -89),
            (r.blbw = 173),
            (r.blbh = 178),
            (r.bsc = 0.25),
            (r.blba = 1);
        } else
          e == 63
            ? ((r.ec = "#000000"),
              (r.ecv = 0),
              (r.eca = 1),
              (r.ppc = "#CCCCCC"),
              (r.ppcv = 13421772),
              (r.pr = 2.5))
            : e == 64 && ((r.ec = "#FFFF80"), (r.ecv = 16777088), (r.eca = 1));
        var m = null;
        e == 9
          ? (m = [
            7, 9, 7, 9, 7, 9, 7, 9, 7, 9, 7, 10, 10, 10, 10, 10, 10, 10, 10,
            10,
          ])
          : e == 10
            ? (m = [9, 9, 9, 9, 9, 1, 1, 1, 1, 1, 7, 7, 7, 7, 7])
            : e == 11
              ? (m = [11, 11, 11, 11, 11, 7, 7, 7, 7, 7, 12, 12, 12, 12, 12])
              : e == 12
                ? (m = [7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 13, 13, 13, 13, 13])
                : e == 13
                  ? (m = [14, 14, 14, 14, 14, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7])
                  : e == 14
                    ? (m = [9, 9, 9, 9, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7])
                    : e == 15
                      ? (m = [0, 1, 2, 3, 4, 5, 6, 7, 8])
                      : e == 16
                        ? (m = [15, 15, 15, 15, 15, 15, 15, 4, 4, 4, 4, 4, 4, 4])
                        : e == 17
                          ? (m = [9, 9, 9, 9, 9, 9, 9, 16, 16, 16, 16, 16, 16, 16])
                          : e == 18
                            ? (m = [7, 7, 7, 7, 7, 7, 7, 9, 9, 9, 9, 9, 9, 9])
                            : e == 19
                              ? (m = [9])
                              : e == 20
                                ? (m = [3, 3, 3, 3, 3, 0, 0, 0, 0, 0])
                                : e == 21
                                  ? (m = [
                                    3, 3, 3, 3, 3, 3, 3, 18, 18, 18, 18, 18, 18, 20, 19, 20, 19, 20,
                                    19, 20, 18, 18, 18, 18, 18, 18,
                                  ])
                                  : e == 22
                                    ? (m = [
                                      5, 5, 5, 5, 5, 5, 5, 9, 9, 9, 9, 9, 9, 9, 13, 13, 13, 13, 13, 13,
                                      13,
                                    ])
                                    : e == 23
                                      ? (m = [
                                        16, 16, 16, 16, 16, 16, 16, 18, 18, 18, 18, 18, 18, 18, 7, 7, 7,
                                        7, 7, 7, 7,
                                      ])
                                      : e == 24
                                        ? (m = [
                                          23, 23, 23, 23, 23, 23, 23, 23, 23, 18, 18, 18, 18, 18, 18, 18,
                                          18, 18,
                                        ])
                                        : e == 25
                                          ? (m = [
                                            21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
                                            22, 22, 22, 22, 22,
                                          ])
                                          : e == 26
                                            ? (m = [24])
                                            : e == 27
                                              ? (m = [25])
                                              : e == 28
                                                ? (m = [
                                                  18, 18, 18, 18, 18, 18, 18, 25, 25, 25, 25, 25, 25, 25, 7, 7, 7,
                                                  7, 7, 7, 7,
                                                ])
                                                : e == 29
                                                  ? (m = [11, 11, 4, 11, 11, 11, 11, 4, 11, 11])
                                                  : e == 30
                                                    ? (m = [10, 10, 19, 20, 10, 10, 20, 19])
                                                    : e == 31
                                                      ? (m = [10, 10])
                                                      : e == 32
                                                        ? (m = [20, 20])
                                                        : e == 33
                                                          ? (m = [12, 11, 11])
                                                          : e == 34
                                                            ? (m = [7, 7, 9, 13, 13, 9, 16, 16, 9, 12, 12, 9, 7, 7, 9, 16, 16, 9])
                                                            : e == 35
                                                              ? (m = [7, 7, 9, 9, 6, 6, 9, 9])
                                                              : e == 36
                                                                ? (m = [16, 16, 9, 9, 15, 15, 9, 9])
                                                                : e == 37
                                                                  ? (m = [22])
                                                                  : e == 38
                                                                    ? (m = [18])
                                                                    : e == 39
                                                                      ? (m = [23])
                                                                      : e == 40
                                                                        ? (m = [26])
                                                                        : e == 41
                                                                          ? (m = [27])
                                                                          : e == 42
                                                                            ? (m = [
                                                                              2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5,
                                                                              5, 5, 7, 7, 7, 7, 7, 7, 7, 7,
                                                                            ])
                                                                            : e == 43
                                                                              ? (m = [28])
                                                                              : e == 44
                                                                                ? (m = [29])
                                                                                : e == 45
                                                                                  ? (m = [7, 7, 7, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7])
                                                                                  : e == 46
                                                                                    ? (m = [7])
                                                                                    : e == 47
                                                                                      ? (m = [
                                                                                        16, 16, 16, 18, 18, 18, 18, 18, 18, 18, 18, 18, 7, 7, 7, 7, 7, 7,
                                                                                        7, 7, 16, 16, 16, 16,
                                                                                      ])
                                                                                      : e == 48
                                                                                        ? (m = [7])
                                                                                        : e == 49
                                                                                          ? (m = [23, 23, 23, 23, 23, 9, 9, 9, 9, 9, 9, 9, 9, 23, 23])
                                                                                          : e == 50
                                                                                            ? (m = [
                                                                                              18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 16, 16,
                                                                                              16, 16, 16, 16, 16, 16, 7, 7, 7, 7, 7, 7, 7, 7,
                                                                                            ])
                                                                                            : e == 51
                                                                                              ? (m = [7, 7, 7, 9, 9, 16, 16, 16, 16, 16, 16, 9, 9])
                                                                                              : e == 52
                                                                                                ? (m = [
                                                                                                  7, 7, 7, 7, 18, 18, 18, 18, 18, 18, 18, 18, 18, 7, 7, 7, 7, 7,
                                                                                                ])
                                                                                                : e == 53
                                                                                                  ? (m = [30])
                                                                                                  : e == 54
                                                                                                    ? (m = [31])
                                                                                                    : e == 55
                                                                                                      ? (m = [32])
                                                                                                      : e == 56
                                                                                                        ? (m = [33])
                                                                                                        : e == 57
                                                                                                          ? (m = [34])
                                                                                                          : e == 58
                                                                                                            ? (m = [35])
                                                                                                            : e == 59
                                                                                                              ? (m = [18])
                                                                                                              : e == 60
                                                                                                                ? ((m = [36]), (d = 37), (f = 38), (p = 30))
                                                                                                                : e == 61
                                                                                                                  ? (m = [
                                                                                                                    30, 30, 30, 30, 30, 30, 35, 35, 35, 35, 35, 35, 33, 33, 33, 33,
                                                                                                                    33, 33, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 34, 34,
                                                                                                                    34, 34, 34, 34,
                                                                                                                  ])
                                                                                                                  : e == 62
                                                                                                                    ? (m = [17, 17, 17, 17, 17, 39, 39, 39, 39, 39])
                                                                                                                    : e == 63
                                                                                                                      ? (m = [7, 7, 7, 11, 11, 11])
                                                                                                                      : e == 64
                                                                                                                        ? (m = [16, 16, 11, 11])
                                                                                                                        : e == 65 && (m = [4, 4, 4, 4, 9, 9, 9, 9]),
          ggl && (m || (m = [e])),
          m && (e = m[0]),
          (r.rbcs = m),
          (r.cv = e);
      }
      if (((r.fdhc = d), (r.fdtc = f), (r.fdl = p), ggl)) {
        if (r.sglo) {
          var w = r.lsgvc;
          for (_ = 0; _ < w; _++) r.sgsv[_] = !1;
        } else {
          r.lsgvc = 0;
          var x = null;
          if (
            (slither == null && ((x = ssdo), (ssdo = null)),
              x == null && (x = jw.get()),
              x)
          )
            (r.sgs = x.sgs),
              (r.shs = x.shs),
              (r.shs2 = x.shs2),
              (r.sfs = x.sfs),
              (r.sfus = x.sfus),
              (r.sds = x.sds),
              (r.sgsv = x.sgsv),
              (r.uglo = x.uglo),
              (r.eyelo = x.eyelo),
              (r.lefteye = x.lefteye),
              (r.leftpupil = x.leftpupil),
              (r.righteye = x.righteye),
              (r.rightpupil = x.rightpupil),
              (r.sglo = x.sglo),
              (r.shlo = x.shlo),
              (r.sflo = x.sflo),
              (r.sdlo = x.sdlo),
              r == slither &&
              ((r.uglo.zIndex = -1),
                (r.shlo.zIndex = -1),
                (r.sglo.zIndex = -1),
                (r.eyelo.zIndex = -1),
                (r.sflo.zIndex = -1),
                (r.sdlo.zIndex = -1)),
              (r.shlo.visible = !0),
              (r.sglo.visible = !0),
              (r.eyelo.visible = !0);
          else {
            (r.sgs = []),
              (r.shs = []),
              (r.shs2 = []),
              (r.sfs = []),
              (r.sfus = []),
              (r.sgsv = []),
              (r.sds = []),
              (r.uglo = new Ne()),
              (r.shlo = new Ne()),
              (r.sglo = new Ne()),
              (r.eyelo = new Ne()),
              (r.sflo = new Ne()),
              (r.sdlo = new Ne()),
              r == slither &&
              ((r.uglo.zIndex = -1),
                (r.shlo.zIndex = -1),
                (r.sglo.zIndex = -1),
                (r.eyelo.zIndex = -1),
                (r.sflo.zIndex = -1),
                (r.sdlo.zIndex = -1)),
              suglo.addChild(r.uglo),
              shilo.addChild(r.shlo),
              slilo.addChild(r.sglo),
              slilo.addChild(r.eyelo),
              sfilo.addChild(r.sflo),
              sdilo.addChild(r.sdlo);
            var M = new Ke(eyeo.t);
            M.anchor.set(0.5), (r.lefteye = M), r.eyelo.addChild(M);
            var b = new Ke(eyeo.t);
            b.anchor.set(0.5), (r.righteye = b), r.eyelo.addChild(b);
            var T = new Ke(pupilo.t);
            T.anchor.set(0.5), (r.leftpupil = T), r.eyelo.addChild(T);
            var C = new Ke(pupilo.t);
            C.anchor.set(0.5), (r.rightpupil = C), r.eyelo.addChild(C);
          }
          (r.sflo.visible = !1), (r.uglo.visible = !1), (r.sdlo.visible = !1);
        }
        (r.eyelo.visible = !0),
          r.eac || r.one_eye
            ? ((r.lefteye.visible = !1),
              (r.leftpupil.visible = !1),
              (r.righteye.visible = !1),
              (r.rightpupil.visible = !1))
            : ((r.lefteye.visible = !0),
              (r.lefteye.tint = r.ecv),
              (r.leftpupil.visible = !0),
              (r.righteye.visible = !0),
              (r.righteye.tint = r.ecv),
              (r.rightpupil.visible = !0)),
          r.jse &&
          ((r.ebi = new Ke(be.jsebo.t)),
            r.ebi.anchor.set(0.5),
            r.eyelo.addChild(r.ebi),
            (r.epi = new Ke(be.jsepo.t)),
            r.epi.anchor.set(0.5),
            r.eyelo.addChild(r.epi)),
          r.slg &&
          ((r.stem1 = new Ke(be.sestt)),
            r.stem1.anchor.set(0.2666, 0.5),
            r.eyelo.addChildAt(r.stem1, 0),
            (r.stem2 = new Ke(be.sestt)),
            r.stem2.anchor.set(0.2666, 0.5),
            r.eyelo.addChildAt(r.stem2, 0)),
          r.ppcv == 0
            ? ((r.leftpupil.texture = pupilo.t),
              (r.rightpupil.texture = pupilo.t),
              (r.leftpupil.tint = 16777215),
              (r.rightpupil.tint = 16777215))
            : ((r.leftpupil.texture = tpupilo.t),
              (r.rightpupil.texture = tpupilo.t),
              (r.leftpupil.tint = r.ppcv),
              (r.rightpupil.tint = r.ppcv));
      }
    }
  }
  function $w(r, e, t, a) {
    var l = document.createElement("div"),
      o;
    r.tagName
      ? (o = r)
      : ((o = document.getElementById(r)),
        (o.style.width = t + "px"),
        (o.style.height = a + "px"),
        (l.style.width = t + "px"),
        (l.style.height = a + "px"));
    var h = {};
    (h.lic = 0),
      (h.elem = o),
      (h.md = !1),
      (h.mo = !1),
      (h.mdf = 0),
      (h.mof = 0);
    var c = !0;
    return (
      o.style &&
      o.style.position &&
      ((o.style.position + "").toLowerCase() == "absolute" && (c = !1),
        (o.style.position + "").toLowerCase() == "fixed" && (c = !1)),
      c && (o.style.position = "relative"),
      (l.style.position = "absolute"),
      (l.style.opacity = 0),
      (l.style.left = "0px"),
      (l.style.top = "0px"),
      o.appendChild(l),
      (h.ho = l),
      (h.alic = function () {
        this.lic++,
          this.lic == 3 &&
          ((this.ho.style.opacity = 1), this.onload && this.onload());
      }),
      mos.push(h),
      (h.setEnabled = function (u) {
        u
          ? ((this.disabled = !1),
            (this.upi.style.opacity = this.mof),
            (this.downi.style.opacity = this.mdf),
            (this.elem.style.opacity = 1),
            (this.elem.style.cursor = "pointer"))
          : ((this.disabled = !0),
            (this.upi.style.opacity = 0),
            (this.downi.style.opacity = 0),
            (this.elem.style.opacity = 0.38),
            (this.elem.style.cursor = "default"));
      }),
      (l.style.opacity = 1),
      (o.onmouseenter = function () {
        for (var u = mos.length - 1; u >= 0; u--) {
          var d = mos[u];
          if (d.elem == this) {
            d.disabled ||
              d.mo ||
              ((d.mo = !0), d.onmouseenter && d.onmouseenter(), (whmos = !0));
            break;
          }
        }
      }),
      (o.onmouseleave = function () {
        for (var u = mos.length - 1; u >= 0; u--) {
          var d = mos[u];
          if (d.elem == this) {
            d.mo &&
              ((d.mo = !1), d.onmouseleave && d.onmouseleave(), (whmos = !0));
            break;
          }
        }
      }),
      (o.onmousedown = function (u) {
        for (var d = mos.length - 1; d >= 0; d--) {
          var f = mos[d];
          if (f.elem == this) {
            if (!f.disabled && !f.md)
              return (
                (f.md = !0),
                f.onmousedown && f.onmousedown(u, f),
                (whmos = !0),
                !1
              );
            break;
          }
        }
      }),
      (o.onmouseup = o.ondragend =
        function (u) {
          for (var d = mos.length - 1; d >= 0; d--) {
            var f = mos[d];
            if (f.elem == this) {
              f.md &&
                ((f.mdf = 1),
                  (f.md = !1),
                  f.onmouseup &&
                  (f.onmouseup(u, f), is_mobile && f.elem.onmouseleave()),
                  (whmos = !0));
              break;
            }
          }
        }),
      swmup ||
      ((swmup = !0),
        (window.onmouseup =
          window.ondragover =
          window.ondragend =
          function () {
            for (var u = mos.length - 1; u >= 0; u--) {
              var d = mos[u];
              d.md && ((d.md = !1), (whmos = !0));
            }
          })),
      h
    );
  }
  function sl(r, e, t, a, l) {
    var o = document.createElement("div");
    o.className = "btnt nsi sadg" + l;
    var p = o.style;
    (p.position = "absolute"),
      (p.width = "auto"),
      (p.color = "#fff"),
      (p.fontWeight = "bold"),
      (p.textAlign = "center"),
      (p.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
      (p.fontSize = t + "px"),
      (o.textContent = r),
      (p.cursor = "pointer"),
      document.body.appendChild(o);
    var h = Math.ceil(35 + o.offsetWidth);
    document.body.removeChild(o),
      (o.textContent = ""),
      (p.width = h + "px"),
      (p.height = e + "px"),
      (p.lineHeight = e + "px"),
      is_mobile || (p.boxShadow = "0px 3px 20px rgba(0,0,0, .75)"),
      (p.borderRadius = a + "px");
    var c = document.createElement("div"),
      p = c.style;
    (p.position = "absolute"),
      (p.left = p.top = "0px"),
      (p.width = h + "px"),
      (p.height = e + "px"),
      (p.borderRadius = a + 1 + "px"),
      (p.opacity = 0),
      (c.className = "sadu" + l);
    var u = document.createElement("div"),
      p = u.style;
    (p.position = "absolute"),
      (p.left = p.top = "-1px"),
      (p.width = h + 2 + "px"),
      (p.height = e + 2 + "px"),
      (p.borderRadius = a + "px"),
      (p.opacity = 0),
      (u.className = "sadd" + l);
    var d = $w(o);
    (d.a = 1),
      d.ho.appendChild(c),
      (d.upi = c),
      d.ho.appendChild(u),
      (d.downi = u),
      (d.ts = t),
      (d.ww = h),
      (d.bgm = l),
      (d.setText = function (g) {
        var _ = document.createElement("div");
        _.className = "nsi sadg" + this.bgm;
        var m = _.style;
        (m.position = "absolute"),
          (m.width = "auto"),
          (m.color = "#fff"),
          (m.fontWeight = "bold"),
          (m.textAlign = "center"),
          (m.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
          (m.fontSize = this.ts + "px"),
          (_.textContent = g),
          document.body.appendChild(_);
        var w = Math.ceil(35 + _.offsetWidth);
        document.body.removeChild(_),
          (this.btnf.textContent = g),
          (this.ww = w),
          (this.elem.style.width = w + "px"),
          (this.upi.style.width = w + "px"),
          (this.downi.style.width = w + 2 + "px"),
          (this.btnf.style.width = w + "px");
      });
    var f = document.createElement("div");
    o.appendChild(f), (d.btnf = f);
    var p = f.style;
    return (
      (p.position = "absolute"),
      (p.left = p.top = "0px"),
      (p.width = h + "px"),
      (p.height = e + "px"),
      (p.borderRadius = a + "px"),
      (f.textContent = r),
      (f.className = "nsi"),
      (p.color = "#fff"),
      (p.opacity = 0.9),
      d.ho.appendChild(f),
      d
    );
  }
  const Kw = document.getElementById("bsk");
  (Kw.onclick = function () {
    if (playing && choosing_skin && !building_skin && !selecting_cosmetic) {
      var r,
        e,
        t,
        a,
        l = 0,
        o = 0;
      (build_segments = []), (G.alcsc = G.falcsc);
      var h = "";
      try {
        (localStorage.want_custom_skin = "1"), (h = localStorage.custom_skin);
      } catch { }
      if (h && h.length > 0) {
        h = ("" + h).split(",");
        for (var c = 0, u = -1, d = !0, r = 8; r < h.length; r++) {
          if (d) c = Number(h[r]);
          else {
            u = Number(h[r]);
            for (var e = 0; e < c; e++) build_segments.push(u);
          }
          d = !d;
        }
      }
      Ii(slither, 0, nl(!0)), (building_skin = !0), (ending_build_skin = !1);
      var f = 4,
        p = [],
        g = [];
      for (r = 0; r < f; r++) {
        for (
          t = 0, o = Math.floor((ha.length * (r + 1)) / f), e = l;
          e < o;
          e++
        )
          t++;
        g.push(t), (l = o);
      }
      g[0]--, g[1]--, g[2]++, g[3]++;
      var _ = [];
      for (l = 0, r = 0; r < f; r++)
        for (_ = [], p.push(_), e = 0; e < g[r]; e++) _.push(ha[l]), l++;
      for (t = 0; t < p.length; t++)
        for (_ = p[t], r = 0; r < _.length; r++)
          if (((e = _[r]), e >= 0 && e < At.length)) {
            var m = Kt[e];
            if (!m) continue;
            a = {};
            var w = m.kmcs[0],
              x = document.createElement("canvas");
            (a.ii = x), (x.width = w.width), (x.height = w.height);
            var M = x.getContext("2d");
            M.rotate(Math.PI),
              M.drawImage(w, -w.width, -w.height),
              (x.style.opacity = 0),
              (x.style.position = "absolute"),
              (x.style.left = "0px"),
              (x.style.top = "0px"),
              (x.draggable = !1),
              (a.xx = Math.floor(
                (_.length * 55 * (r - (_.length - 1) / 2)) / _.length
              )),
              (a.yy = Math.floor(-32 - t * 62));
            var b = document.createElement("a");
            (b.draggable = !1),
              (b.href = "#"),
              (b.className = "btn btnt"),
              (b.style.zIndex = 53),
              (b.style.position = "fixed"),
              b.appendChild(x),
              (a.a = b),
              document.body.appendChild(b),
              (a.cv = e),
              (b.onclick = function () {
                if (
                  !choosing_skin ||
                  !building_skin ||
                  build_segments.length >= 47
                )
                  return !1;
                for (var T = bskbtns.length - 1; T >= 0; T--)
                  if (bskbtns[T].a == this) {
                    build_segments.push(bskbtns[T].cv);
                    break;
                  }
                return Ii(slither, 0, nl(!0)), !1;
              }),
              bskbtns.push(a);
          }
      gm(), (Dt.style.opacity = 0), (Dt.style.display = "inline");
    }
    return !1;
  }),
    (psk.onclick = function () {
      if (building_skin || selecting_cosmetic) return !1;
      if (playing && slither != null) {
        var r = slither.rcv;
        r--,
          r < 0 && (r = window.max_skin_cv),
          gw2k16 || (r == 42 && r--),
          Ii(slither, r, null);
        try {
          localStorage.want_custom_skin = "0";
        } catch { }
      }
      return !1;
    }),
    (nsk.onclick = function () {
      if (building_skin || selecting_cosmetic) return !1;
      if (playing && slither != null) {
        var r = slither.rcv;
        r++,
          gw2k16 || (r == 42 && r++),
          r > window.max_skin_cv && (r = 0),
          Ii(slither, r, null);
        try {
          localStorage.want_custom_skin = "0";
        } catch { }
      }
      return !1;
    });
  var il = "Reset";
  var Sa = sl("" + il + "", 47, 20, 34, 1);
  const Dt = Sa.elem;
  (Dt.style.zIndex = 53),
    (Dt.style.position = "fixed"),
    (Dt.style.left = "300px"),
    (Dt.style.top = "300px"),
    (Dt.style.display = "none"),
    (Dt.style.opacity = 0),
    document.body.appendChild(Dt),
    (Sa.elem.onclick = function () {
      if (building_skin && !ending_build_skin) {
        build_segments = [];
        var r = nl(!0);
        Ii(slither, 0, r);
      }
    });
  var rl = "Save";
  var Sa = sl("" + rl + "", 47, 20, 34, 1);
  const Xt = Sa.elem;
  (Xt.style.zIndex = 53),
    (Xt.style.position = "fixed"),
    (Xt.style.left = "300px"),
    (Xt.style.top = "300px"),
    (Xt.style.display = "none"),
    (Xt.style.opacity = 0),
    document.body.appendChild(Xt),
    (Sa.elem.onclick = function () {
      if (building_skin && !ending_build_skin) {
        ending_build_skin = !0;
        var r = "";
        if (build_segments.length > 0) r = nl(!1);
        else {
          var e = "";
          try {
            if (((e = localStorage.custom_skin), e && e.length > 0)) {
              (e = ("" + e).split(",")), (r = new Uint8Array(e.length));
              for (var t = 0; t < e.length; t++) r[t] = Number(e[t]);
            }
          } catch { }
        }
        if ((r == null && (r = ""), r.length > 0)) {
          Ii(slither, 0, r);
          for (var e = [], t = 0; t < r.length; t++) e.push(r[t]);
          var a = e.join(",");
          try {
            (localStorage.custom_skin = a),
              (localStorage.want_custom_skin = "1");
          } catch { }
        } else {
          var l = Math.floor(Math.random() * 9);
          try {
            var o = localStorage.snakercv;
            o == "" + Number(o) && (l = Number(o));
          } catch { }
          Ii(slither, l, null);
          try {
            localStorage.want_custom_skin = "0";
          } catch { }
        }
        return;
      }
      if (selecting_cosmetic && !ending_select_cosmetic) {
        ending_select_cosmetic = !0;
        try {
          localStorage.cosmetic = slither.accessory;
        } catch { }
        return;
      }
      if (playing) {
        try {
          localStorage.snakercv = slither.rcv;
        } catch { }
        (connected = !1), (playing = !1), (dead_mtm = Date.now() - 5e3);
      }
    });
  function nl(r) {
    var e = [];
    e.push(255),
      e.push(255),
      e.push(255),
      e.push(0),
      e.push(0),
      e.push(0),
      e.push(Math.floor(Math.random() * 256)),
      e.push(Math.floor(Math.random() * 256));
    var t, a;
    if (((a = build_segments.length), a > 0)) {
      var l,
        o = build_segments[0],
        h = 0;
      for (t = 0; t < a; t++)
        (l = build_segments[t]),
          l != o &&
          (h > 255 && (h = 255), e.push(h), e.push(o), (h = 0), (o = l)),
          h++;
      h > 0 && (e.push(h), e.push(o));
    }
    r && (e.push(250), e.push(40));
    var c = new Uint8Array(e.length);
    for (t = 0; t < e.length; t++) c[t] = e[t];
    return c;
  }
  function gm() {
    if (bskbtns.length > 0)
      for (var r = bskbtns.length - 1; r >= 0; r--) {
        var e = bskbtns[r],
          t = e.a;
        (t.style.left = Math.floor(ww / 2 + e.xx) + "px"),
          (t.style.top = Math.floor(hh / 2 + e.yy) + "px");
      }
  }
  function al() {
    if (cosbtns.length > 0)
      for (var r = cosbtns.length - 1; r >= 0; r--) {
        var e = cosbtns[r],
          t = e.a;
        (t.style.left = Math.floor(ww / 2 + e.xx) + "px"),
          (t.style.top = Math.floor(hh / 2 + e.yy) + "px");
      }
  }
  const mm = [
    "oakley",
    "graduation",
    "funkystar",
    "headphones",
    "eyebrows",
    "spikecollar",
    "disguise",
    "cape",
    "crown",
    "antlers",
    "unicorn",
    "angel",
    "bat",
    "dragon",
    "bear",
    "rabbit",
    "cat",
    "dreadlocks",
    "blonde",
    "ginger",
    "blackhair",
    "mohawk",
    "catglass",
    "swirly",
    "nerdglass",
    "3dglass",
    "heartglass",
    "monocle",
    "deerstalker",
    "visor",
    "cap",
    "hardhat",
  ],
    sr = [];
  for (let r = 0; r < mm.length; r++) {
    const e = {};
    sr.push(e),
      (e.loaded = !1),
      (e.img = null),
      (e.u = "http://slither.io/s/a_" + mm[r] + ".png"),
      r == 0
        ? ((e.sc = 0.205), (e.px = 66), (e.py = 174 / 2))
        : r == 1
          ? ((e.sc = 0.2), (e.px = 205), (e.py = 202 / 2))
          : r == 2
            ? ((e.sc = 0.205), (e.px = 83), (e.py = 174 / 2))
            : r == 3
              ? ((e.sc = 0.25), (e.px = 130), (e.py = 194 / 2))
              : r == 4
                ? ((e.sc = 0.25), (e.px = 64), (e.py = 164 / 2))
                : r == 5
                  ? ((e.sc = 0.25), (e.px = 94), (e.py = 158 / 2))
                  : r == 6
                    ? ((e.sc = 0.25), (e.px = 64), (e.py = 180 / 2))
                    : r == 7
                      ? ((e.sc = 0.32), (e.px = 170), (e.py = 172 / 2))
                      : r == 8
                        ? ((e.sc = 0.18), (e.px = 180), (e.py = 150 / 2))
                        : r == 9
                          ? ((e.sc = 0.3), (e.px = 120), (e.py = 200 / 2))
                          : r == 10
                            ? ((e.sc = 0.3), (e.px = 201), (e.py = 80 / 2))
                            : r == 11
                              ? ((e.sc = 0.3), (e.px = 152), (e.py = 250 / 2))
                              : r == 12
                                ? ((e.sc = 0.25), (e.px = 132), (e.py = 300 / 2))
                                : r == 13
                                  ? ((e.sc = 0.25), (e.px = 145), (e.py = 280 / 2))
                                  : r == 14
                                    ? ((e.sc = 0.165), (e.px = 115), (e.py = 180 / 2))
                                    : r == 15
                                      ? ((e.sc = 0.19), (e.px = 172), (e.py = 250 / 2))
                                      : r == 16
                                        ? ((e.sc = 0.19), (e.px = 127), (e.py = 180 / 2))
                                        : r == 17
                                          ? ((e.sc = 0.25), (e.px = 114), (e.py = 160 / 2))
                                          : r == 18
                                            ? ((e.sc = 0.225), (e.px = 144), (e.py = 170 / 2))
                                            : r == 19
                                              ? ((e.sc = 0.225), (e.px = 154), (e.py = 178 / 2))
                                              : r == 20
                                                ? ((e.sc = 0.215), (e.px = 159), (e.py = 182 / 2))
                                                : r == 21
                                                  ? ((e.sc = 0.215), (e.px = 184), (e.py = 94 / 2))
                                                  : r == 22
                                                    ? ((e.sc = 0.19), (e.px = 88), (e.py = 212 / 2))
                                                    : r == 23
                                                      ? ((e.sc = 0.19), (e.px = 63), (e.py = 212 / 2))
                                                      : r == 24
                                                        ? ((e.sc = 0.19), (e.px = 93), (e.py = 210 / 2))
                                                        : r == 25
                                                          ? ((e.sc = 0.17), (e.px = 94), (e.py = 244 / 2))
                                                          : r == 26
                                                            ? ((e.sc = 0.153), (e.px = 54), (e.py = 226 / 2))
                                                            : r == 27
                                                              ? ((e.sc = 0.175), (e.px = 60), (e.py = Math.floor(133 / 2 - 44)))
                                                              : r == 28
                                                                ? ((e.sc = 0.19), (e.px = 195), (e.py = 154 / 2))
                                                                : r == 29
                                                                  ? ((e.sc = 0.21), (e.px = 77), (e.py = 184 / 2))
                                                                  : r == 30
                                                                    ? ((e.sc = 0.19), (e.px = 194), (e.py = 160 / 2))
                                                                    : r == 31 && ((e.sc = 0.16), (e.px = 223), (e.py = 180 / 2));
  }
  const Zw = sr.length,
    Qw = document.getElementById("scos");
  Qw.onclick = function () {
    if (playing && choosing_skin && !building_skin && !selecting_cosmetic) {
      (selecting_cosmetic = !0), (ending_select_cosmetic = !1);
      for (var r, e = 0, t = 1, a = 0; a < 32; a++)
        actco.length > a && actco[a] == 1 && t++;
      t > 8 && (t = 8);
      for (var a = 0; a <= 32; a++)
        if (a == 32 || (actco.length > a && actco[a] == 1)) {
          (r = {}), a == 32 ? (r.v = -1) : (r.v = a);
          var l = document.createElement("img");
          (l.onload = function () {
            for (var c, u = cosbtns.length - 1; u >= 0; u--)
              if (((c = cosbtns[u]), c.ii == this)) {
                c.v == -1
                  ? ((c.ww = this.width * 0.5),
                    (c.hh = this.height * 0.5),
                    (this.width = c.ww),
                    (this.height = c.hh),
                    (c.xx -= c.ww / 2),
                    (c.yy -= c.hh / 2),
                    al())
                  : ((c.ww = this.width * 0.35),
                    (c.hh = this.height * 0.35),
                    (this.width = c.ww),
                    (this.height = c.hh),
                    (c.xx -= c.ww / 2),
                    (c.yy -= c.hh / 2),
                    al());
                break;
              }
          }),
            a == 32
              ? (l.src = "http://slither.io/s/a_none.png")
              : (l.src = sr[a].u),
            (l.style.opacity = 0),
            (l.style.position = "absolute"),
            (l.style.left = "0px"),
            (l.style.top = "0px"),
            (l.draggable = !1),
            (r.ii = l),
            trf(l, "rotate(90deg)"),
            (r.xx = 102 * ((e % 8) - (t / 2 - 0.5))),
            (r.yy = -22 - 80 * Math.floor(e / 8)),
            e++;
          var o = document.createElement("a");
          (o.draggable = !1),
            (o.href = "#"),
            (o.className = "btn btnt"),
            (o.style.zIndex = 53),
            (o.style.position = "fixed"),
            o.appendChild(l),
            (r.a = o),
            document.body.appendChild(o),
            (o.onclick = function () {
              if (!choosing_skin || !selecting_cosmetic) return !1;
              for (var c = cosbtns.length - 1; c >= 0; c--)
                if (cosbtns[c].a == this) {
                  slither.accessory = cosbtns[c].v;
                  break;
                }
              return !1;
            }),
            cosbtns.push(r);
        }
      al();
    }
    return !1;
  };
  const Ve = { lga: 0, lgss: 0, ncka: 0, showlogo_iv: -1 },
    Wr = [];
  Wr.push(
    {
      pts: [
        107, 107, 80, 83, 53, 98, 31, 115, 55, 131, 98, 147, 101, 162, 101, 190,
        66, 188, 49, 187, 34, 173,
      ],
      kc: 22,
      ws: 4,
      wr: 0.025,
      qm: 0.025,
      sp: 0.06,
      sz: 11,
    },
    {
      pts: [150, 30, 150, 30 + 154 / 2, 150, 184],
      kc: 66,
      ws: 4,
      wr: 0.05,
      qm: 0.025,
      sp: 0.06,
      sz: 11,
    },
    {
      pts: [207, 96, 207, 96 + 88 / 2, 207, 184],
      kc: 46,
      ws: 4,
      wr: 0.03,
      qm: 0.035,
      sp: 0.06,
      sz: 11,
    },
    {
      pts: [207, 47, 207, 47 + 3 / 2, 207, 50],
      kc: 11,
      ws: 2,
      wr: 0.06,
      qm: 0.05,
      sp: 0.06,
      sz: 15,
      r: 0.5,
    },
    {
      pts: [267, 65, 267, 65 + 99 / 2, 267, 164, 267, 194, 297, 186],
      kc: 66,
      ws: 6,
      wr: -0.025,
      qm: -0.0125,
      sp: 0.06,
      sz: 11,
      r: 1.5,
    },
    {
      pts: [243, 94, 268, 94, 293, 94],
      kc: 66,
      ws: 4,
      wr: 0.015,
      qm: 0.025,
      sp: 0.06,
      sz: 9,
      r: 1.2,
    },
    {
      pts: [
        338,
        30,
        338,
        30 + 154 / 4,
        338,
        30 + 308 / 4,
        338,
        30 + 462 / 4,
        338,
        184,
        338,
        164,
        338,
        144,
        338,
        104,
        378,
        104,
        418,
        104,
        418,
        144,
        418,
        164,
        418,
        184,
      ],
      kc: 46,
      ws: 4,
      wr: 0.005,
      qm: 0.02,
      sp: 0.06,
      sz: 11,
      r: 2.1,
    },
    {
      pts: [
        535, 175, 500, 201, 472, 175, 442, 138, 472, 105, 502, 84, 532, 105,
        546, 118, 544, 139, 504, 139, 464, 139,
      ],
      kc: 35,
      ws: 6,
      wr: -0.013,
      qm: -0.025,
      sp: 0.06,
      sz: 11,
      r: 1.3,
    },
    {
      pts: [
        591,
        96,
        591,
        96 + 88 / 2,
        591,
        184,
        591,
        184 + -58 / 2,
        591,
        126,
        613,
        82,
        652,
        109,
      ],
      kc: 38,
      ws: 4,
      wr: 0.01,
      qm: -0.035,
      sp: 0.06,
      sz: 11,
    },
    {
      pts: [663, 177, 663, 177 + 3 / 2, 663, 180],
      kc: 11,
      ws: 2,
      wr: 0.06,
      qm: 0.05,
      sp: 0.06,
      sz: 15,
    },
    {
      pts: [717, 96, 717, 96 + 88 / 2, 717, 184],
      kc: 33,
      ws: 4,
      wr: 0.06,
      qm: 0.05,
      sp: 0.06,
      sz: 11,
    },
    {
      pts: [717, 47, 717, 47 + 3 / 2, 717, 50],
      kc: 11,
      ws: 2,
      wr: 0.06,
      qm: 0.05,
      sp: 0.06,
      sz: 15,
    },
    {
      pts: [
        814, 186, 860, 188, 858, 136, 854, 96, 814, 96, 770, 96, 770, 136, 770,
        186, 814, 186,
      ],
      kc: 43,
      ws: 4,
      wr: 0,
      qm: 0.0274,
      sp: 0.073,
      sz: 11,
      r: 1.5,
    }
  );
  for (var zc = 0; zc < Wr.length; zc++) Wr[zc].mwig = 5;
  var _m = 0,
    vm = Date.now();
  function Wc(r) {
    var e = Date.now(),
      t = (e - vm) / 25;
    vm = e;
    var a, l, o, h, c, u, d, f, p, g, _, m, w, x, M, b, T, C, A;
    if (
      ((_m += t),
        Wr[Wr.length - 1].mwig == 0 &&
        Ve.lga == 1 &&
        Ve.lgss == 1 &&
        Ve.ncka == 1)
    )
      clearInterval(Ve.showlogo_iv), (Ve.showlogo_iv = -1);
    else {
      for (
        (r || Ve.lga != 1) &&
        ((Ve.lga += 0.05 * t),
          Ve.lga >= 1 && (Ve.lga = 1),
          (lmc2.style.opacity = Ve.lga)),
        Ve.lgss != 1 &&
        ((Ve.lgss += 0.00375 * t), Ve.lgss >= 1 && (Ve.lgss = 1)),
        (r || Ve.ncka != 1) &&
        ((Ve.ncka += 0.006 * t),
          Ve.ncka >= 1 && (Ve.ncka = 1),
          (nick_holder.style.opacity = Math.min(1, Ve.ncka * 6)),
          is_mobile ||
          (smh.style.opacity = Math.max(
            0,
            Math.min(1, (Ve.ncka - 0.05) * 5)
          )),
          Ve.ncka >= 0.01 &&
          (playh.style.opacity = Math.min(1, (Ve.ncka - 0.01) * 5))),
        lctx.clearRect(0, 0, lw, lh),
        w = 0;
        w < Wr.length;
        w++
      ) {
        var R = Wr[w],
          k = R.pts,
          W = R.kc,
          D = R.ws,
          I = R.wr,
          y = R.qm,
          Z = R.sp,
          V = R.sz,
          A = R.r,
          z = R.mwig;
        if (
          (r && ((R.wch = !0), (z = 1e-7)),
            R.wch &&
            z != 0 &&
            ((z *= 0.982),
              (z -= 0.001 * t),
              render_mode == 1 && (z -= 0.005 * t),
              z <= 0 && (z = 0),
              (R.mwig = z)),
            A || (A = 1),
            lctx.beginPath(),
            w < 9)
        ) {
          var $ = ctx.createLinearGradient(0, 70 * lgsc, 0, 230 * lgsc);
          $.addColorStop(0, "#80FFA0"),
            $.addColorStop(1, "#008040"),
            (lctx.fillStyle = $);
        } else {
          var $ = ctx.createLinearGradient(0, 50 * lgsc, 0, 265 * lgsc);
          $.addColorStop(0, "#9850FF"),
            $.addColorStop(1, "#281060"),
            (lctx.fillStyle = $);
        }
        (b = !1), (C = 0), (o = k[0]), (h = k[1]), (_ = o), (m = h);
        var B = D,
          re = _m * Z;
        for (x = 2; x < k.length; x += 4) {
          (a = o), (l = h);
          let ht = k[x],
            it = k[x + 1];
          (o = k[x + 2]), (h = k[x + 3]);
          for (var qe = 1; qe <= W; qe++) {
            C++;
            var S = qe / W;
            (c = a + (ht - a) * S),
              (u = l + (it - l) * S),
              (d = ht + (o - ht) * S),
              (f = it + (h - it) * S),
              (p = c + (d - c) * S),
              (g = u + (f - u) * S),
              (T = Math.atan2(g - m, p - _)),
              b
                ? (T - M > Math.PI
                  ? (T -= 2 * Math.PI)
                  : T - M < -Math.PI && (T += 2 * Math.PI),
                  (M += (T - M) * 0.05),
                  (M %= 2 * Math.PI))
                : ((b = !0), (M = T)),
              (_ = p),
              (m = g),
              (p += Math.cos(Math.PI / 2 + M) * Math.sin(re) * B * z),
              (g += Math.sin(Math.PI / 2 + M) * Math.sin(re) * B * z),
              (re -= 0.76 * y * B),
              (B += I),
              lctx.beginPath();
            var J =
              V *
              1.15 *
              Math.min(
                1,
                lgsc *
                (0.2 + 0.8 * Ve.lga) *
                (30 * Ve.lgss * A - C / 20 - w / 2)
              );
            J > 0.5 && (lctx.arc(p * lgsc, g * lgsc, J, 0, pi2), (R.wch = !0)),
              lctx.fill();
          }
        }
      }
      lctx2.clearRect(0, 0, lw, lh),
        (lctx2.shadowColor = "#000000"),
        (lctx2.shadowBlur = 16),
        (lctx2.shadowOffsetY = 7),
        lctx2.drawImage(lmc, 0, 0);
    }
  }
  is_safari || is_mobile
    ? ((Ve.lga = 1), (Ve.lgss = 1), (Ve.ncka = 1), Wc(!0))
    : (Ve.showlogo_iv = setInterval(function () {
      Wc(!1);
    }, 25));
  let ol = [],
    br = null,
    bm = 10,
    ll = 120,
    Ma = 48;
  const Se = {
    svl_hiding: !1,
    svl_showing: !1,
    choosing_server: !1,
    svl_a: 0,
    svlww: 5 * ll + 6 * bm + 10,
    svlhh: 580,
  },
    Bs = document.createElement("div");
  (Bs.style.position = "fixed"),
    (Bs.style.left = Bs.style.top = "0px"),
    (Bs.style.background = "#00000080"),
    (Bs.style.zIndex = 1000),
    (Bs.style.opacity = 0),
    (Bs.style.transition = "opacity 0.3s ease"),
    (Bs.style.display = "none"),
    document.body.appendChild(Bs),
    (Bs.onclick = function () {
      jc();
    }),
    (csrv.onclick = function () {
      return Jw(), !1;
    });
  const Ze = document.createElement("div");
  (Ze.style.position = "fixed"),
    (Ze.style.width = Se.svlww + "px"),
    (Ze.style.height = Se.svlhh + "px"),
    (Ze.style.borderRadius = "26px"),
    (Ze.style.border = "2px solid rgba(190, 210, 255, .66)"),
    (Ze.style.boxShadow = "0px 6px 50px rgba(0,0,0, 1)"),
    (Ze.style.background = "#000000"),
    (Ze.style.zIndex = 1001),
    (Ze.style.opacity = 0),
    (Ze.style.transform = "scale(0)"),
    (Ze.style.transition = "transform 0.3s ease, opacity 0.3s ease"),
    (Ze.style.display = "none"),
    document.body.appendChild(Ze);
  var sviStyle = document.createElement("style");
  sviStyle.textContent = ".svi:hover{border-color:#bed2ffcc!important}.svi.selected{border-color:#56ac81!important}";
  document.head.appendChild(sviStyle);
  var Vs = document.createElement("div");
  (Vs.style.position = "absolute"),
    (Vs.style.left = "5px"),
    (Vs.style.top = "5px"),
    (Vs.style.width = Se.svlww - 10 + "px"),
    (Vs.style.height = Se.svlhh - 10 + "px"),
    (Vs.style.borderRadius = "8px"),
    (Vs.style.overflowX = "hidden"),
    (Vs.style.overflowY = "hidden"),
    Ze.appendChild(Vs);
  var Vr = document.createElement("input");
  (Vr.style.opacity = 0),
    (Vr.style.position = "fixed"),
    (Vr.style.left = "-100000px"),
    Ze.appendChild(Vr),
    Vr.addEventListener("focus", function () {
      Vr.blur();
    });
  function Jw() {
    Se.choosing_server = !0;
    var r = -1;
    bso && (r = bso.sid);
    for (var e = ol.length - 1; e >= 0; e--) Vs.removeChild(ol[e]);
    (ol = []),
      (br = null),
      cm(),
      r == -1 && fbso != null && (r = fbso.sid),
      sos.sort(function (re, qe) {
        return parseFloat(re.ptm) - parseFloat(qe.ptm);
      });
    for (var e = sos.length - 1; e >= 0; e--)
      for (var t = sos[e].sid, a = sos.length - 1; a > e; a--) {
        var l = sos[a].sid;
        if (t == l) {
          sos[a].ptm > sos[e].ptm ? sos.splice(a, 1) : sos.splice(e, 1),
            (a = -1);
          break;
        }
      }
    for (var o = [], e = 0; e < sos.length; e++)
      (sos[e].active || sos[e] == bso || sos[e] == fbso) && o.push(sos[e]);
    Vs.className = "nsi";
    for (
      var h = -1,
      c = 0,
      u = bm,
      d = [160, 0, 255, 255, 255],
      f = [255, 255, 255, 136, 64],
      p = [160, 0, 0, 0, 64],
      e = 0;
      e < o.length;
      e++
    ) {
      h++, h >= 5 && ((h = 0), c++);
      var g = o[e],
        _ = document.createElement("div");
      (_.className = "svi nsi"),
        (_.style.width = ll + "px"),
        (_.style.height = Ma + "px"),
        (_.style.position = "absolute"),
        (_.style.borderRadius = "8px"),
        (_.style.background = "#161c22"),
        (_.style.cursor = "pointer"),
        (_.style.userSelect = "none"),
        (_.style.webkitUserSelect = "none"),
        (_.style.mozUserSelect = "none"),
        (_.style.msUserSelect = "none"),
        (_.style.border = "3px solid transparent"),
        (_.style.transition = "border-color 0.2s, transform 0.2s"),
        (_.style.boxSizing = "border-box");
      var sidePadding = 4;
      var signalAreaWidth = D + 10;
      var m = document.createElement("div");
      _.appendChild(m),
        (m.style.position = "absolute"),
        (m.style.textAlign = "center"),
        (m.style.color = "#fff"),
        (m.style.width = (ll - 6 - sidePadding * 2 - signalAreaWidth) + "px"),
        (m.style.height = Ma + "px"),
        (m.style.lineHeight = m.style.height),
        (m.style.left = sidePadding + "px"),
        (m.style.top = "-3px");
      let qe = [];
      for (let S = -1; S <= 1; S++)
        for (let J = -1; J <= 1; J++) qe.push(S + "px " + J + "px 0 #000");
      (qe = qe.join(", ")),
        (m.style.textShadow = qe),
        (m.style.fontWeight = "bold"),
        (m.style.textAlign = "left"),
        (m.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
        (m.style.fontSize = "20px"),
        (m.textContent = g.sid);
      var w, x;
      if (
        (g.ptm < 65
          ? ((w = 0), (x = (g.ptm - 0) / 65))
          : g.ptm < 135
            ? ((w = 1), (x = (g.ptm - 65) / 70))
            : g.ptm < 210
              ? ((w = 2), (x = (g.ptm - 135) / 75))
              : g.ptm < 300
                ? ((w = 3), (x = (g.ptm - 210) / 90))
                : ((w = 4), (x = 0)),
          e == 0 && w >= 1 && ((w = 0), (x = 1)),
          w == d.length - 1)
      )
        var M = d[w],
          b = f[w],
          T = p[w];
      else
        var M = d[w] + (d[w + 1] - d[w]) * x,
          b = f[w] + (f[w + 1] - f[w]) * x,
          T = p[w] + (p[w + 1] - p[w]) * x;
      var C = "00" + Math.floor(M).toString(16),
        A = "00" + Math.floor(b).toString(16),
        R = "00" + Math.floor(T).toString(16);
      (C = C.substr(C.length - 2)),
        (A = A.substr(A.length - 2)),
        (R = R.substr(R.length - 2));
      var k = "#" + C + A + R,
        W = d.length - 1,
        D = 32,
        I = 22,
        y = document.createElement("canvas");
      (y.width = D), (y.height = I);
      var Z = y.getContext("2d");
      Z.fillStyle = k;
      for (var a = 1; a <= W; a++) {
        var V = (a / W) * 18;
        (Z.globalAlpha = 1),
          (Z.fillStyle = "#000000"),
          Z.fillRect(2 + (a - 1) * (D / 4) - 1, 20 - V - 1, 6, V + 2),
          (Z.fillStyle = k),
          a == 1 + W - w
            ? (Z.globalAlpha = 0.25 + 0.75 * (1 - x))
            : a <= 1 + W - w
              ? (Z.globalAlpha = 1)
              : (Z.globalAlpha = 0.25),
          Z.fillRect(2 + (a - 1) * (D / 4), 20 - V, 4, V);
      }
      var msGap = 1;
      var msHeight = 12;
      var innerHeight = Ma - 6;
      var contentHeight = I + msGap + msHeight;
      var signalTop = (innerHeight - contentHeight) / 2;
      var z = document.createElement("div");
      _.appendChild(z),
        (z.style.position = "absolute"),
        (z.style.textAlign = "left"),
        (z.style.color = k),
        (z.style.width = D + "px"),
        (z.style.whiteSpace = "nowrap"),
        (z.style.height = "12px"),
        (z.style.right = sidePadding + "px"),
        (z.style.top = (signalTop + I + msGap) + "px"),
        (z.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
        (z.style.fontWeight = 'Bold'),
        (z.style.fontSize = "10px"),
        g.ptm < 5e4 && (z.textContent = g.ptm + " ms");
      var $ = document.createElement("img");
      ($.src = y.toDataURL()),
        ($.className = "nsi"),
        ($.draggable = !1),
        ($.style.position = "absolute"),
        ($.style.right = sidePadding + "px"),
        ($.style.top = signalTop + "px"),
        _.appendChild($),
        (_.onclick = function () {
          for (var S = 0; S < sos.length; S++) {
            var J = sos[S];
            if (J.dv == this) {
              Vc(J), jc();
              break;
            }
          }
        }),
        Vs.appendChild(_),
        ol.push(_),
        (g.dv = _),
        (g.div_x = u + h * (ll + u)),
        (g.div_y = u + c * (Ma + u)),
        (_.style.left = g.div_x + "px"),
        (_.style.top = g.div_y + "px"),
        g.sid == r && Vc(g);
    }
    (Se.svlhh = u + c * (Ma + u) + Ma + u + 10),
      (Ze.style.height = Se.svlhh + "px"),
      (Vs.style.height = Se.svlhh - 10 + "px"),
      (Ze.style.top = Math.round(hh / 2 - Se.svlhh / 2) + "px"),
      (nick.disabled = !0),
      (Se.svl_hiding = !1),
      (Se.svl_showing = !1),
      (Se.svl_a = 1),
      (Bs.style.display = "inline"),
      (Ze.style.display = "inline"),
      setTimeout(function () { Bs.style.opacity = 1; Ze.style.opacity = 1; Ze.style.transform = "scale(1)" }, 20),
      Vr.focus();
  }
  function Vc(r) {
    r &&
      (Se.choosing_server &&
        (br != null &&
          br.dv.classList.remove("selected"),
          (br = r),
          r.dv &&
          r.dv.classList.add("selected")),
        (bso = r),
        (forcing = !0));
  }
  function jc() {
    (Se.choosing_server = !1),
      Se.svl_hiding || ((nick.disabled = !1), nick.focus()),
      (Se.svl_hiding = !1),
      (Se.svl_showing = !1),
      (Se.svl_a = 0),
      (Bs.style.opacity = 0),
      (Ze.style.opacity = 0),
      (Ze.style.transform = "scale(0)"),
      setTimeout(function () { Bs.style.display = "none"; Ze.style.display = "none" }, 300);
  }
  function e2() {
    var t = Se.svl_a;
    var eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    var r = Math.round(1e4 * eased) / 1e4;
    ww < Se.svlww + 60 && (r *= ww / (Se.svlww + 60)),
      (r = Math.round(r * 1e4) / 1e4),
      Se.svl_eased = eased,
      (Ze.style.webkitTransform =
        Ze.style.OTransform =
        Ze.style.msTransform =
        Ze.style.MozTransform =
        Ze.style.transform =
        "scale(" + r + "," + r + ")");
  }
  (window.forceOnce = function (e, t, a) {
      (forcing = !0),
        (fobso = {}),
        (fobso.ip = e),
        (fobso.po = t),
        (fobso.ac = 999),
        (fobso.c_aa = a);
    });
  const hl = 180,
    at = document.createElement("div");
  (at.className = "nsi"),
    (at.style.position = "fixed"),
    (at.style.right = "4px"),
    (at.style.top = "4px"),
    (at.style.textAlign = "center"),
    (at.style.width = hl + 64 + 16 + 30 - 5 + "px"),
    (at.style.height = "28px"),
    (at.style.color = "#fff"),
    (at.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
    (at.style.fontSize = "21px"),
    (at.style.fontWeight = "bold"),
    (at.style.overflow = "hidden"),
    (at.style.opacity = 0.5),
    (at.style.zIndex = 7),
    (at.style.display = "none"),
    (at.style.cursor = "default");
  var cl = "Leaderboard";
  (at.textContent = cl),
    trf(at, agpu),
    document.body.appendChild(at),
    (window.at = at);
  const ot = document.createElement("div");
  (ot.className = "nsi"),
    (ot.style.position = "fixed"),
    (ot.style.textAlign = "center"),
    (ot.style.right = "4px"),
    (ot.style.top = "32px"),
    (ot.style.width = "50px"),
    (ot.style.height = "800px"),
    (ot.style.color = "#fff"),
    (ot.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
    (ot.style.fontSize = "12px"),
    (ot.style.overflow = "hidden"),
    (ot.style.opacity = 0.7),
    (ot.style.zIndex = 7),
    (ot.style.display = "none"),
    (ot.style.cursor = "default"),
    (ot.style.lineHeight = "150%"),
    trf(ot, agpu),
    document.body.appendChild(ot),
    (window.ot = ot);
  const st = document.createElement("div");
  (st.className = "nsi"),
    (st.style.position = "fixed"),
    (st.style.textAlign = "left"),
    (st.style.whiteSpace = "nowrap"),
    (st.style.right = "64px"),
    (st.style.top = "32px"),
    (st.style.width = hl + "px"),
    (st.style.height = "800px"),
    (st.style.color = "#fff"),
    (st.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
    (st.style.fontSize = "12px"),
    (st.style.overflow = "hidden"),
    (st.style.opacity = 0.7),
    (st.style.zIndex = 8),
    (st.style.display = "none"),
    (st.style.cursor = "default"),
    (st.style.lineHeight = "150%"),
    trf(st, agpu),
    document.body.appendChild(st),
    (window.st = st);
  const lt = document.createElement("div");
  (lt.className = "nsi"),
    (lt.style.position = "fixed"),
    (lt.style.textAlign = "right"),
    (lt.style.right = hl + 64 + 16 + "px"),
    (lt.style.top = "32px"),
    (lt.style.width = "30px"),
    (lt.style.height = "800px"),
    (lt.style.color = "#fff"),
    (lt.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
    (lt.style.fontSize = "12px"),
    (lt.style.overflow = "hidden"),
    (lt.style.opacity = 0.7),
    (lt.style.zIndex = 9),
    (lt.style.display = "none"),
    (lt.style.cursor = "default"),
    (lt.style.lineHeight = "150%"),
    trf(lt, agpu),
    document.body.appendChild(lt),
    (window.lt = lt),
    document.getElementById("grqh"),
    document.createElement("img");
  const Yc = document.getElementById("grqi");
  try {
    localStorage.qual == "0"
      ? ((Yc.src = "http://slither.io/s/lowquality.png"), (G.want_quality = 0), (high_quality = !1), (gla = 0))
      : (G.want_quality = 1);
  } catch { }
  const t2 = document.getElementById("grq");
  t2.onclick = function () {
    try {
      localStorage.qual == "0"
        ? ((localStorage.qual = "1"),
          (Yc.src = "http://slither.io/s/highquality.png"),
          (G.want_quality = 1),
          (high_quality = !0),
          (gla = 1))
        : ((localStorage.qual = "0"),
          (Yc.src = "http://slither.io/s/lowquality.png"),
          (G.want_quality = 0),
          (high_quality = !1),
          (gla = 0));
    } catch { }
    return !1;
  };
  var qt, je, Xe, Zt, Pe, Qt, Ee;
  for (
    Xe = document.createElement("canvas"),
    qt = 2,
    je = 56,
    Xe.width = qt,
    Xe.height = je,
    Qt = Xe.getContext("2d", { willReadFrequently: !0 }),
    Zt = Qt.getImageData(0, 0, qt, je),
    Pe = Zt.data,
    Pe.length,
    Ee = 0,
    yy = 0;
    yy < je;
    yy++
  )
    for (
      j = (je - 1 - yy) / (je - 1),
      j = 0.5 * (1 - Math.cos(Math.PI * j)),
      xx = 0;
      xx < qt;
      xx++
    )
      (Pe[Ee] = Math.min(255, Math.floor(0.85 * 64 + 0.5 * 64 * j))),
        (Pe[Ee + 1] = Math.min(255, Math.floor(0.85 * 128 + 0.5 * 128 * j))),
        (Pe[Ee + 2] = Math.min(255, Math.floor(0.85 * 96 + 0.5 * 96 * j))),
        (Pe[Ee + 3] = 255),
        (Ee += 4);
  for (
    Qt.putImageData(Zt, 0, 0),
    sadg = Xe.toDataURL(),
    Xe = document.createElement("canvas"),
    Xe.width = qt,
    Xe.height = je,
    Qt = Xe.getContext("2d", { willReadFrequently: !0 }),
    Zt = Qt.getImageData(0, 0, qt, je),
    Pe = Zt.data,
    Pe.length,
    Ee = 0,
    yy = 0;
    yy < je;
    yy++
  )
    for (
      j = (je - 1 - yy) / (je - 1),
      j = 0.5 * (1 - Math.cos(Math.PI * j)),
      xx = 0;
      xx < qt;
      xx++
    )
      (Pe[Ee] = Math.min(255, Math.floor(1.5 * 48 + 0.95 * 48 * j))),
        (Pe[Ee + 1] = Math.min(255, Math.floor(1.5 * 114 + 0.95 * 98 * j))),
        (Pe[Ee + 2] = Math.min(255, Math.floor(1.5 * 88 + 0.95 * 87 * j))),
        (Pe[Ee + 3] = 255),
        (Ee += 4);
  for (
    Qt.putImageData(Zt, 0, 0),
    sadu = Xe.toDataURL(),
    Xe = document.createElement("canvas"),
    Xe.width = qt,
    Xe.height = je,
    Qt = Xe.getContext("2d", { willReadFrequently: !0 }),
    Zt = Qt.getImageData(0, 0, qt, je),
    Pe = Zt.data,
    Pe.length,
    Ee = 0,
    yy = 0;
    yy < je;
    yy++
  )
    for (
      j = yy / (je - 1), j = 0.5 * (1 - Math.cos(Math.PI * j)), xx = 0;
      xx < qt;
      xx++
    )
      (Pe[Ee] = Math.floor(0.1 * 48 + 0.75 * 48 * j)),
        (Pe[Ee + 1] = Math.floor(0.1 * 70 + 0.75 * 70 * j)),
        (Pe[Ee + 2] = Math.floor(0.1 * 64 + 0.75 * 64 * j)),
        (Pe[Ee + 3] = 255),
        (Ee += 4);
  for (
    Qt.putImageData(Zt, 0, 0),
    sadd = Xe.toDataURL(),
    sadg.length > 32 &&
    sadu.length > 32 &&
    sadd.length > 32 &&
    wm(
      ".sadg1 { background-image:url(" +
      sadg +
      "); }  .sadu1 { background-image:url(" +
      sadu +
      "); }  .sadd1 { background-image:url(" +
      sadd +
      "); }"
    ),
    Xe.width = qt,
    Xe.height = je,
    Qt = Xe.getContext("2d", { willReadFrequently: !0 }),
    Zt = Qt.getImageData(0, 0, qt, je),
    Pe = Zt.data,
    Pe.length,
    Ee = 0,
    yy = 0;
    yy < je;
    yy++
  )
    for (
      j = (je - 1 - yy) / (je - 1),
      j = 0.5 * (1 - Math.cos(Math.PI * j)),
      xx = 0;
      xx < qt;
      xx++
    )
      (Pe[Ee] = Math.min(255, Math.floor(0.85 * 52 + 0.5 * 52 * j))),
        (Pe[Ee + 1] = Math.min(255, Math.floor(0.85 * 96 + 0.5 * 96 * j))),
        (Pe[Ee + 2] = Math.min(255, Math.floor(0.85 * 144 + 0.5 * 144 * j))),
        (Pe[Ee + 3] = 255),
        (Ee += 4);
  for (
    Qt.putImageData(Zt, 0, 0),
    sadg = Xe.toDataURL(),
    Xe = document.createElement("canvas"),
    Xe.width = qt,
    Xe.height = je,
    Qt = Xe.getContext("2d", { willReadFrequently: !0 }),
    Zt = Qt.getImageData(0, 0, qt, je),
    Pe = Zt.data,
    Pe.length,
    Ee = 0,
    yy = 0;
    yy < je;
    yy++
  )
    for (
      j = (je - 1 - yy) / (je - 1),
      j = 0.5 * (1 - Math.cos(Math.PI * j)),
      xx = 0;
      xx < qt;
      xx++
    )
      (Pe[Ee] = Math.min(255, Math.floor(1.5 * 48 + 0.95 * 48 * j))),
        (Pe[Ee + 1] = Math.min(255, Math.floor(1.5 * 88 + 0.95 * 87 * j))),
        (Pe[Ee + 2] = Math.min(255, Math.floor(1.5 * 114 + 0.95 * 98 * j))),
        (Pe[Ee + 3] = 255),
        (Ee += 4);
  for (
    Qt.putImageData(Zt, 0, 0),
    sadu = Xe.toDataURL(),
    Xe = document.createElement("canvas"),
    Xe.width = qt,
    Xe.height = je,
    Qt = Xe.getContext("2d", { willReadFrequently: !0 }),
    Zt = Qt.getImageData(0, 0, qt, je),
    Pe = Zt.data,
    Pe.length,
    Ee = 0,
    yy = 0;
    yy < je;
    yy++
  )
    for (
      j = yy / (je - 1), j = 0.5 * (1 - Math.cos(Math.PI * j)), xx = 0;
      xx < qt;
      xx++
    )
      (Pe[Ee] = Math.floor(0.1 * 48 + 0.75 * 48 * j)),
        (Pe[Ee + 1] = Math.floor(0.1 * 54 + 0.75 * 54 * j)),
        (Pe[Ee + 2] = Math.floor(0.1 * 70 + 0.75 * 70 * j)),
        (Pe[Ee + 3] = 255),
        (Ee += 4);
  Qt.putImageData(Zt, 0, 0),
    (sadd = Xe.toDataURL()),
    sadg.length > 32 &&
    sadu.length > 32 &&
    sadd.length > 32 &&
    wm(
      ".sadg2 { background-image:url(" +
      sadg +
      "); }  .sadu2 { background-image:url(" +
      sadu +
      "); }  .sadd2 { background-image:url(" +
      sadd +
      "); }"
    );
  function wm(r) {
    var e = document.createElement("style");
    document.getElementsByTagName("head")[0].appendChild(e),
      (e.type = "text/css"),
      e.styleSheet
        ? (e.styleSheet.cssText = r)
        : e.appendChild(document.createTextNode(r));
  }
  function dl(r) {
    let t = "",
      a = !1;
    for (let o = 0; o < r.length; o++) {
      const h = r.charCodeAt(o);
      if (h < 32 || h > 127) {
        a = !0;
        break;
      }
    }
    if (a) {
      for (let o = 0; o < r.length; o++) {
        const h = r.charCodeAt(o);
        t += h < 32 || h > 127 ? " " : String.fromCharCode(h);
      }
      return t;
    }
    return r;
  }
  const yt = document.createElement("div");
  (yt.id = "statBox"),
    (yt.className = "nsi"),
    (yt.style.position = "fixed"),
    (yt.style.left = "8px"),
    (yt.style.bottom = "4px"),
    (yt.style.width = "280px"),
    (yt.style.height = "37px"),
    (yt.style.color = "#fff"),
    (yt.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
    (yt.style.fontSize = "12px"),
    (yt.style.overflow = "hidden"),
    (yt.style.opacity = 0.5),
    (yt.style.zIndex = 7),
    (yt.style.display = "none"),
    (yt.style.cursor = "default"),
    (yt.style.lineHeight = "150%"),
    trf(yt, agpu),
    document.documentElement.appendChild(yt),
    (window.yt = yt);
  const wt = document.createElement("div");
  (wt.className = "nsi"),
    (wt.style.position = "fixed"),
    (wt.style.left = "8px"),
    (wt.style.top = "4px"),
    (wt.style.width = "300px"),
    (wt.style.height = "228px"),
    (wt.style.color = "#fff"),
    (wt.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
    (wt.style.fontSize = "13px"),
    (wt.style.overflow = "hidden"),
    (wt.style.wordWrap = "break-word"),
    (wt.style.opacity = 0.5),
    (wt.style.zIndex = 7),
    (wt.style.display = "none"),
    (wt.style.cursor = "default"),
    trf(wt, agpu),
    document.body.appendChild(wt),
    (window.wt = wt),
    (nick.oninput = function () {
      var r = this.value,
        e = dl(r);
      e.length > 24 && (e = e.substr(0, 24)),
        r != e && (this.value = e),
        r.toLowerCase() == "bonkers" &&
        ((bonkz = !0), (etcoh.style.display = "inline"), $c());
    }),
    (victory.oninput = function () {
      var r = this.value,
        e = dl(r);
      e.length > 140 && (e = e.substr(0, 140)), r != e && (this.value = e);
    }),
    nick.focus();
  function $c() {
    hacos || bonkz ? (grqh.style.top = "160px") : (grqh.style.top = "16px");
  }
  const a2 = function () {
    if (!wumsts || rank <= 0 || slither_count <= 0 || !playing) return;
    wumsts = !1;
    const r = slither.sct + slither.rsc,
      e =
        Math.floor((G.fpsls[r] + slither.fam / G.fmlts[r] - 1) * 15 - 5) / 1;
    let t = o2(e);
    yt.innerHTML = t;
  },
    o2 = function (r) {
      const e = l2();
      let t = `<span style="font-size: 14px;"><span style="opacity: .4;">${e.yl}: </span>`;
      return (
        (t += `<span style="opacity: .8; font-weight: bold;">${r}</span></span>`),
        (t += `<BR><span style="opacity: .3;">${e.rstr}: </span>`),
        (t += `<span style="opacity: .35;">${rank}</span>`),
        (t += `<span style="opacity: .3;"> ${e.ofstr} </span>`),
        (t += `<span style="opacity: .35;">${slither_count}</span>`),
        t
      );
    },
    l2 = function () {
      return { yl: "Your length", ofstr: "of", rstr: "Your rank" };
    },
    Mm = function () {
      fps++;
      const r = mc.getContext("2d");
      if (animating) {
        if (slither && ggl) {
          fdglo.scale.x = fdglo.scale.y = gsc;
          fdlo.scale.x = fdlo.scale.y = gsc;
          prlo.scale.x = prlo.scale.y = gsc;
          g2lo.scale.x = g2lo.scale.y = gsc;
          prglo.scale.x = prglo.scale.y = gsc;
          suglo.scale.x = suglo.scale.y = gsc;
          shilo.scale.x = shilo.scale.y = gsc;
          slilo.scale.x = slilo.scale.y = gsc;
          sfilo.scale.x = sfilo.scale.y = gsc;
          sdilo.scale.x = sdilo.scale.y = gsc;
        }
        var t,
          a,
          l,
          o,
          h,
          c = view_xx,
          u = view_yy;
        if (
          (slither != null &&
            (fvtg > 0 &&
              (fvtg--,
                (fvx = fvxs[fvpos]),
                (fvy = fvys[fvpos]),
                (fvxs[fvpos] = 0),
                (fvys[fvpos] = 0),
                fvpos++,
                fvpos >= vfc && (fvpos = 0)),
              follow_view &&
              ((view_xx = slither.xx + slither.fx + fvx),
                (view_yy = slither.yy + slither.fy + fvy)),
              choosing_skin &&
              ((view_xx -= slither.pts.length * 5),
                building_skin
                  ? (view_yy -= bskoy)
                  : selecting_cosmetic && (view_yy -= secosoy)),
              (view_ang = Math.atan2(view_yy - grd, view_xx - grd)),
              (view_dist = Math.sqrt(
                (view_xx - grd) * (view_xx - grd) +
                (view_yy - grd) * (view_yy - grd)
              )),
              (bpx1 = view_xx - (mww2 / gsc + 84)),
              (bpy1 = view_yy - (mhh2 / gsc + 84)),
              (bpx2 = view_xx + (mww2 / gsc + 84)),
              (bpy2 = view_yy + (mhh2 / gsc + 84)),
              (fpx1 = view_xx - (mww2 / gsc + 24)),
              (fpy1 = view_yy - (mhh2 / gsc + 24)),
              (fpx2 = view_xx + (mww2 / gsc + 24)),
              (fpy2 = view_yy + (mhh2 / gsc + 24)),
              (apx1 = view_xx - (mww2 / gsc + 210)),
              (apy1 = view_yy - (mhh2 / gsc + 210)),
              (apx2 = view_xx + (mww2 / gsc + 210)),
              (apy2 = view_yy + (mhh2 / gsc + 210))),
            (G.bgx2 -= (view_xx - c) / oa),
            (G.bgy2 -= (view_yy - u) / la),
            (G.bgx2 %= 1),
            G.bgx2 < 0 && (G.bgx2 += 1),
            (G.bgy2 %= 1),
            G.bgy2 < 0 && (G.bgy2 += 1),
            (window.fe.zoom || slither && (window.targetGsc = 0.64285 + 0.514285714 / Math.max(1, (slither.sct + 16) / 36))),
            (window.gsc += (window.targetGsc - window.gsc) * (1 - Math.pow(window.fe.zoom ? 0.85 : 0.99, vfr * 0.48))),
            ggl
              ? r.clearRect(0, 0, mww, mhh)
              : zs.ggbg && (high_quality || gla > 0)
                ? (r.save(),
                  (r.fillStyle = "#000000"),
                  r.fillRect(0, 0, mww, mhh),
                  (r.globalAlpha = 0.3),
                  r.drawImage(zs.gbgmc, 0, 0),
                  r.restore())
                : ((r.fillStyle = "#000000"), r.fillRect(0, 0, mww, mhh)),
            ggl
              ? bgee &&
              ((bgee.tileScale.x = gsc),
                (bgee.tileScale.y = gsc),
                (bgee.tilePosition.x = bgee.width / 2 + G.bgx2 * oa * gsc),
                (bgee.tilePosition.y = bgee.height / 2 + G.bgy2 * la * gsc))
              : zs.bgp2 &&
              (r.save(),
                (r.fillStyle = zs.bgp2),
                r.translate(mww2, mhh2),
                r.scale(gsc, gsc),
                r.translate(G.bgx2 * oa, G.bgy2 * la),
                (r.globalAlpha = 1),
                r.fillRect(
                  (-mww * 3) / gsc,
                  (-mhh * 3) / gsc,
                  (mww * 5) / gsc,
                  (mhh * 5) / gsc
                ),
                r.restore()),
            ggl)
        )
          for (var d, f, p = preys.length - 1; p >= 0; p--) {
            const Ht = preys[p];
            (d = Ht.pri), (f = Ht.gpri);
            let L = Ht.xx + Ht.fx,
              Cr = Ht.yy + Ht.fy;
            if (Ht.eaten) {
              var y = Ht.eaten_by,
                g = Math.pow(Ht.eaten_fr, 2);
              (L +=
                (y.xx +
                  y.fx +
                  Math.cos(y.ang + y.fa) * (43 - g * 24) * (1 - g) -
                  L) *
                g),
                (Cr +=
                  (y.yy +
                    y.fy +
                    Math.sin(y.ang + y.fa) * (43 - g * 24) * (1 - g) -
                    Cr) *
                  g);
            }
            (O = L - view_xx),
              (H = Cr - view_yy),
              (d.alpha =
                0.5 +
                0.5 * Ht.fr * (0.5 + 0.5 * Math.cos(Ht.gfr / 13)) * Ht.fr),
              (d.scale.x = Ht.rad),
              (d.scale.y = Ht.rad),
              (d.x = O),
              (d.y = H),
              (h = O * O + H * H),
              (fs = 1 + 0.08 * Ht.rad),
              (O = O * fs),
              (H = H * fs),
              (l = 0.4 * gla * (1 - h / (176e3 + h))),
              Ht.rad != 1 && (l *= Math.pow(Ht.rad, 0.25)),
              (f.alpha = high_quality ? l * Ht.fr : 0),
              (f.scale.x = 1.5 * Ht.rad),
              (f.scale.y = 1.5 * Ht.rad),
              (f.x = O),
              (f.y = H);
          }
        else {
          if (high_quality || gla > 0) {
            var _ = 1.75;
            gla != 1 && (_ = 1.75 * gla), r.save();
            for (var p = foods_c - 1; p >= 0; p--) {
              var m = foods[p];
              m.rx >= fpx1 &&
                m.ry >= fpy1 &&
                m.rx <= fpx2 &&
                m.ry <= fpy2 &&
                (m.rad == 1
                  ? ((J = mww2 + gsc * (m.rx - view_xx) - m.ofw2),
                    (F = mhh2 + gsc * (m.ry - view_yy) - m.ofh2),
                    (r.globalAlpha = _ * m.fr),
                    r.drawImage(m.ofi, J, F))
                  : ((J = mww2 + gsc * (m.rx - view_xx) - m.ofw2 * m.rad),
                    (F = mhh2 + gsc * (m.ry - view_yy) - m.ofh2 * m.rad),
                    (r.globalAlpha = _ * m.fr),
                    r.drawImage(
                      m.ofi,
                      0,
                      0,
                      m.ofw,
                      m.ofh,
                      J,
                      F,
                      m.ofw * m.rad,
                      m.ofh * m.rad
                    )));
            }
            r.restore();
          }
          if (
            (r.save(),
              (r.globalCompositeOperation = "lighter"),
              high_quality || gla > 0)
          ) {
            var _ = 0.75;
            gla != 1 && (_ = 0.75 * gla);
            var w = 0.75;
            gla != 1 && (w = 1 - 0.25 * gla);
            for (var p = foods_c - 1; p >= 0; p--) {
              var m = foods[p];
              m.rx >= fpx1 &&
                m.ry >= fpy1 &&
                m.rx <= fpx2 &&
                m.ry <= fpy2 &&
                (m.rad == 1
                  ? ((J = mww2 + gsc * (m.rx - view_xx) - m.fw2),
                    (F = mhh2 + gsc * (m.ry - view_yy) - m.fh2),
                    (r.globalAlpha = w * m.fr),
                    r.drawImage(m.fi, J, F),
                    (r.globalAlpha =
                      _ * (0.5 + 0.5 * Math.cos(m.gfr / 13)) * m.fr),
                    r.drawImage(m.fi, J, F))
                  : ((J = mww2 + gsc * (m.rx - view_xx) - m.fw2 * m.rad),
                    (F = mhh2 + gsc * (m.ry - view_yy) - m.fh2 * m.rad),
                    (r.globalAlpha = w * m.fr),
                    r.drawImage(
                      m.fi,
                      0,
                      0,
                      m.fw,
                      m.fh,
                      J,
                      F,
                      m.fw * m.rad,
                      m.fh * m.rad
                    ),
                    (r.globalAlpha =
                      _ * (0.5 + 0.5 * Math.cos(m.gfr / 13)) * m.fr),
                    r.drawImage(
                      m.fi,
                      0,
                      0,
                      m.fw,
                      m.fh,
                      J,
                      F,
                      m.fw * m.rad,
                      m.fh * m.rad
                    )));
            }
          } else
            for (var p = foods_c - 1; p >= 0; p--) {
              var m = foods[p];
              m.rx >= fpx1 &&
                m.ry >= fpy1 &&
                m.rx <= fpx2 &&
                m.ry <= fpy2 &&
                (m.rad == 1
                  ? ((J = mww2 + gsc * (m.rx - view_xx) - m.fw2),
                    (F = mhh2 + gsc * (m.ry - view_yy) - m.fh2),
                    (r.globalAlpha = m.fr),
                    r.drawImage(m.fi, J, F))
                  : ((J = mww2 + gsc * (m.rx - view_xx) - m.fw2 * m.rad),
                    (F = mhh2 + gsc * (m.ry - view_yy) - m.fh2 * m.rad),
                    (r.globalAlpha = m.fr),
                    r.drawImage(
                      m.fi,
                      0,
                      0,
                      m.fw,
                      m.fh,
                      J,
                      F,
                      m.fw * m.rad,
                      m.fh * m.rad
                    )));
            }
          r.restore(), r.save(), (r.globalCompositeOperation = "lighter");
          for (var p = preys.length - 1; p >= 0; p--) {
            const L = preys[p];
            let Cr = L.xx + L.fx,
              wl = L.yy + L.fy;
            if (
              ((O = mww2 + gsc * (Cr - view_xx)),
                (H = mhh2 + gsc * (wl - view_yy)),
                O >= -50 && H >= -50 && O <= mwwp50 && H <= mhhp50)
            ) {
              if (L.eaten) {
                var y = L.eaten_by,
                  g = Math.pow(L.eaten_fr, 2);
                (Cr +=
                  (y.xx +
                    y.fx +
                    Math.cos(y.ang + y.fa) * (43 - g * 24) * (1 - g) -
                    Cr) *
                  g),
                  (wl +=
                    (y.yy +
                      y.fy +
                      Math.sin(y.ang + y.fa) * (43 - g * 24) * (1 - g) -
                      wl) *
                    g),
                  (O = mww2 + gsc * (Cr - view_xx)),
                  (H = mhh2 + gsc * (wl - view_yy));
              }
              L.rad == 1
                ? ((J = O - L.fw2),
                  (F = H - L.fh2),
                  (r.globalAlpha = 0.75 * L.fr),
                  r.drawImage(L.fi, J, F),
                  (r.globalAlpha =
                    0.75 * (0.5 + 0.5 * Math.cos(L.gfr / 13)) * L.fr),
                  r.drawImage(L.fi, J, F))
                : ((J = O - L.fw2 * L.rad),
                  (F = H - L.fh2 * L.rad),
                  (r.globalAlpha = 0.75 * L.fr),
                  r.drawImage(
                    L.fi,
                    0,
                    0,
                    L.fw,
                    L.fh,
                    J,
                    F,
                    L.fw * L.rad,
                    L.fh * L.rad
                  ),
                  (r.globalAlpha =
                    0.75 * (0.5 + 0.5 * Math.cos(L.gfr / 13)) * L.fr),
                  r.drawImage(
                    L.fi,
                    0,
                    0,
                    L.fw,
                    L.fh,
                    J,
                    F,
                    L.fw * L.rad,
                    L.fh * L.rad
                  ));
            }
          }
          r.restore();
        }
        r.save(), (r.strokeStyle = "#90C098");
        for (
          var x, M, b, T, C, A, R, k, W, D, I, y, p = slithers.length - 1;
          p >= 0;
          p--
        )
          if (
            ((y = slithers[p]),
              (C = y.xx + y.fx),
              (A = y.yy + y.fy + 40),
              y.na > 0 &&
              (ggl ||
                (C >= bpx1 - 100 && A >= bpy1 && C <= bpx2 + 100 && A <= bpy2)))
          )
            if (
              (y == slither &&
                (y.fnfr++,
                  y.fnfr > 200 && ((y.na -= 0.004), y.na < 0 && (y.na = 0))),
                (x = y.xx + y.fx),
                (M = y.yy + y.fy),
                ggl)
            ) {
              var Z = y.nko;
              Z &&
                ((Z.alpha = 0.5 * y.na * y.alive_amt * (1 - y.dead_amt)),
                  (Z.scale.x = Z.scale.y = 1 + (gsc - 1) * 0.5),
                  (Z.x = (x - view_xx) * gsc),
                  (Z.y = (M + 8 + 16 * y.sc - view_yy) * gsc + 7));
            } else
              r.save(),
                (r.globalAlpha = 0.5 * y.na * y.alive_amt * (1 - y.dead_amt)),
                (r.font = "15px Arial, Helvetica Neue, Helvetica, sans-serif"),
                (r.fillStyle = y.csw),
                (r.textBaseline = "middle"),
                (r.textAlign = "center"),
                (x = mww2 + (x - view_xx) * gsc),
                (M = mhh2 + (M - view_yy) * gsc),
                r.fillText(y.nk, x, M + 32 + 11 * y.sc * gsc),
                r.restore();
        for (var p = slithers.length - 1; p >= 0; p--)
          for (y = slithers[p], y.iiv = !1, S = y.pts.length - 1; S >= 0; S--)
            if (
              ((B = y.pts[S]),
                (O = B.xx + B.fx),
                (H = B.yy + B.fy),
                ggl || (O >= bpx1 && H >= bpy1 && O <= bpx2 && H <= bpy2))
            ) {
              y.iiv = !0;
              break;
            }
        sgsdr = 0;
        for (var p = slithers.length - 1; p >= 0; p--)
          if (((y = slithers[p]), y.iiv)) {
            (b = y.xx + y.fx),
              (T = y.yy + y.fy),
              testing &&
              shifty &&
              ((r.fillStyle = "#607080"),
                r.save(),
                r.translate(
                  mww / 2 + (b - view_xx) * gsc,
                  mhh / 2 + (T - view_yy) * gsc
                ),
                r.fillRect(-8, -8, 16, 16),
                r.restore()),
              (O = b),
              (H = T),
              (I = y.ehang);
            var V = y.sc,
              z = 29 * V,
              $ = y.cfl,
              B = y.pts[y.pts.length - 1];
            if (render_mode == 1) {
              r.save(),
                r.beginPath(),
                r.moveTo(
                  mww2 + (O - view_xx) * gsc,
                  mhh2 + (H - view_yy) * gsc
                );
              for (var re = !1, qe, S = y.pts.length - 1; S >= 0; S--) {
                (qe = B),
                  (B = y.pts[S]),
                  (as = O),
                  (rr = H),
                  (O = B.xx),
                  (H = B.yy);
                var J = B.fx,
                  F = B.fy;
                if ($ > 0) {
                  if (
                    ((O += J),
                      (H += F),
                      (lax = ax),
                      (lay = ay),
                      (ax = (O + as) / 2),
                      (ay = (H + rr) / 2),
                      re || ((lax = ax), (lay = ay)),
                      $ < 1)
                  ) {
                    var g = 1 - $;
                    (as += (lax - as) * g),
                      (rr += (lay - rr) * g),
                      (ax += (lax - ax) * g),
                      (ay += (lay - ay) * g);
                  }
                  re ? $-- : ($ -= y.chl + y.fchl),
                    re
                      ? r.quadraticCurveTo(
                        mww2 + (as - view_xx) * gsc,
                        mhh2 + (rr - view_yy) * gsc,
                        mww2 + (ax - view_xx) * gsc,
                        mhh2 + (ay - view_yy) * gsc
                      )
                      : (r.lineTo(
                        mww2 + (ax - view_xx) * gsc,
                        mhh2 + (ay - view_yy) * gsc
                      ),
                        (re = !0));
                }
              }
              if (
                (r.save(),
                  (r.lineJoin = "round"),
                  (r.lineCap = "round"),
                  doiosh)
              ) {
                if (y.sp > y.fsp) {
                  var S =
                    y.alive_amt *
                    (1 - y.dead_amt) *
                    Math.max(0, Math.min(1, (y.sp - y.ssp) / (y.msp - y.ssp)));
                  r.save(),
                    (r.strokeStyle = y.cs),
                    (r.globalAlpha = 0.3 * S),
                    (r.lineWidth = (z + 6) * gsc),
                    r.stroke(),
                    (r.lineWidth = (z + 9) * gsc),
                    r.stroke(),
                    (r.lineWidth = (z + 12) * gsc),
                    r.stroke(),
                    r.restore();
                }
                (r.globalAlpha = 1 * y.alive_amt * (1 - y.dead_amt)),
                  (r.strokeStyle = "#000000"),
                  (r.lineWidth = (z + 5) * gsc),
                  r.stroke(),
                  (r.strokeStyle = y.cs);
              } else {
                if (y.sp > y.fsp) {
                  var S =
                    y.alive_amt *
                    (1 - y.dead_amt) *
                    Math.max(0, Math.min(1, (y.sp - y.ssp) / (y.msp - y.ssp)));
                  r.save(),
                    (r.lineWidth = (z - 2) * gsc),
                    (r.shadowBlur = 30 * gsc),
                    (r.shadowColor =
                      "rgba(" +
                      y.rr +
                      "," +
                      y.gg +
                      "," +
                      y.bb +
                      ", " +
                      Math.round(1e4 * S) / 1e4 +
                      ")"),
                    r.stroke(),
                    r.stroke(),
                    r.restore();
                }
                (r.globalAlpha = 0.4 * y.alive_amt * (1 - y.dead_amt)),
                  (r.strokeStyle = "#000000"),
                  (r.lineWidth = (z + 5) * gsc),
                  r.stroke(),
                  (r.strokeStyle = y.cs),
                  (r.lineWidth = z * gsc),
                  (r.strokeStyle = "#000000"),
                  (r.globalAlpha = 1 * y.alive_amt * (1 - y.dead_amt)),
                  r.stroke(),
                  (r.strokeStyle = y.cs);
              }
              if (
                ((r.globalAlpha = 0.8 * y.alive_amt * (1 - y.dead_amt)),
                  (r.lineWidth = z * gsc),
                  r.stroke(),
                  r.restore(),
                  (r.strokeStyle = y.cs),
                  y.dead)
              ) {
                var ht =
                  (0.5 + 0.5 * Math.abs(Math.sin(5 * Math.PI * y.dead_amt))) *
                  Math.sin(Math.PI * y.dead_amt);
                r.save(),
                  (r.lineJoin = "round"),
                  (r.lineCap = "round"),
                  (r.globalCompositeOperation = "lighter"),
                  (r.lineWidth = (z - 3) * gsc),
                  (r.globalAlpha = ht),
                  (r.strokeStyle = "#FFCC99"),
                  r.stroke(),
                  r.restore();
              }
              r.restore();
            }
            if (render_mode == 2) {
              z *= 0.5;
              var Re,
                it,
                Ui,
                Ms,
                dt,
                ns,
                Di,
                li,
                Ue = 0;
              (O = b),
                (H = T),
                (Di = O),
                (li = H),
                (ax = O),
                (ay = H),
                (Ue = 0);
              var rs = y.drez,
                bs = 0,
                Ss = 0.25;
              rs && (Ss = 0.125),
                high_quality && (Ss *= 0.5),
                (n = (y.chl + y.fchl) % Ss),
                n < 0 && (n += Ss),
                (n = Ss - n),
                y.sep != y.wsep &&
                (y.sep < y.wsep
                  ? ((y.sep += 0.0035), y.sep >= y.wsep && (y.sep = y.wsep))
                  : y.sep > y.wsep &&
                  ((y.sep -= 0.0035), y.sep <= y.wsep && (y.sep = y.wsep)));
              var hi = y.sep * qsm;
              rs && (hi *= 0.333);
              var oi = Kt[y.cv] || Kt[0];
              if (!oi) continue;
              var Fi = oi.kmcs,
                wr = oi.kmos,
                Sr = oi.kfo?.t,
                Et = Fi.length,
                Ut = Et * 2,
                ds = oi.klp,
                O,
                H,
                ke,
                ct,
                Gi,
                Fs,
                B,
                ye,
                Yt,
                qe,
                dt,
                ns,
                Di,
                li,
                ts,
                Qe,
                R,
                k,
                qr = 0,
                Re,
                Ms,
                Ui,
                Ms,
                C,
                A,
                W,
                D,
                us,
                Ts;
              (C = 0), (A = 0);
              var S,
                g,
                K,
                Me,
                U,
                X = 0,
                bn,
                Mi,
                Ti = y.msl,
                Oi = 6 / (y.sep / 6);
              rs && (Oi *= 2);
              var yl = Oi,
                ut = 1 / Oi,
                hi = Ti / Oi,
                kt = 0;
              (B = y.pts[y.pts.length - 1]),
                (O = B.xx + B.fx),
                (H = B.yy + B.fy),
                (ts = Math.sqrt(Math.pow(b - O, 2) + Math.pow(T - H, 2))),
                (R = (b - O) / ts),
                (k = (T - H) / ts),
                (Mi = ts / Ti);
              var Nt = y.gptz,
                Be,
                Cs,
                ci,
                Ci,
                ps = 0;
              for (
                Yt = y.pts[y.pts.length - 2],
                ye = y.pts[y.pts.length - 1],
                O = b,
                H = T,
                ke = ye.xx + ye.fx,
                ct = ye.yy + ye.fy,
                Yt && ((Gi = Yt.xx + Yt.fx), (Fs = Yt.yy + Yt.fy)),
                ts > Ti && ((O = ke + R * Ti), (H = ct + k * Ti)),
                dt = O + (ke - O) * 0.5,
                ns = H + (ct - H) * 0.5,
                Mi < 1 &&
                ((dt += (O - dt) * (1 - Mi)), (ns += (H - ns) * (1 - Mi))),
                Di = Gi + (ke - Gi) * 0.5,
                li = Fs + (ct - Fs) * 0.5,
                Qe = Math.sqrt(Math.pow(b - dt, 2) + Math.pow(T - ns, 2)),
                g = hi,
                K = 1,
                Be = fa(y, ps, b, T),
                ps++,
                Be.d = 0,
                Cs = Be,
                X++;
                g < Qe;

              ) {
                if (
                  ((C = b - K * R * hi),
                    (A = T - K * k * hi),
                    (Be = fa(y, ps, C, A)),
                    ps++,
                    (ts = hi),
                    (Be.d = ts),
                    (Cs = Be),
                    X++,
                    kt == 1)
                ) {
                  kt = 2;
                  break;
                }
                ($ -= ut),
                  $ <= 0
                    ? ((kt = 1),
                      (K += (ut + $) / ut),
                      (g += (hi * (ut + $)) / ut))
                    : (K++, (g += hi));
              }
              if (((U = (g - Qe) / Ti), kt <= 1)) {
                if (($ >= -1e-4 && $ <= 0 && ($ = 0), $ >= 0 || kt == 1)) {
                  for (
                    Mi < 1 &&
                    ((ke += (Di - ke) * 0.5 * (1 - Mi)),
                      (ct += (li - ct) * 0.5 * (1 - Mi))),
                    testing &&
                    shifty &&
                    (r.save(),
                      (r.fillStyle = "#0000FF"),
                      r.translate(
                        mww / 2 + (ke - view_xx) * gsc,
                        mhh / 2 + (ct - view_yy) * gsc
                      ),
                      r.fillRect(-2, -2, 4, 4),
                      r.restore()),
                    K = 0.5 + Mi - Qe / Ti;
                    U >= 0 && U < K;

                  ) {
                    if (
                      ((g = U / K),
                        (Re = dt + (ke - dt) * g),
                        (it = ns + (ct - ns) * g),
                        (Ui = ke + (Di - ke) * g),
                        (Ms = ct + (li - ct) * g),
                        (us = Re + (Ui - Re) * g),
                        (Ts = it + (Ms - it) * g),
                        (Be = fa(y, ps, us, Ts)),
                        ps++,
                        (ts = Math.sqrt(
                          Math.pow(Be.xx - Cs.xx, 2) + Math.pow(Be.yy - Cs.yy, 2)
                        )),
                        (Be.d = ts),
                        (Cs = Be),
                        X++,
                        kt == 1)
                    ) {
                      kt = 2;
                      break;
                    }
                    ($ -= ut),
                      $ <= 0 ? ((kt = 1), (U += ut + $), ($ = 0)) : (U += ut);
                  }
                  U -= K;
                }
                $ >= -1e-4 && $ <= 0 && ($ = 0);
              }
              var Mr = y.pts.length;
              if (testing && shifty)
                for (S = y.pts.length - 1; S >= 0; S--) {
                  var B = y.pts[S];
                  (O = B.xx + B.fx),
                    (H = B.yy + B.fy),
                    r.save(),
                    B.dying
                      ? (r.fillStyle = "#FF0000")
                      : (r.fillStyle = "#FF00FF"),
                    (r.globalAlpha = 1 - B.da),
                    r.translate(
                      mww / 2 + (O - view_xx) * gsc,
                      mhh / 2 + (H - view_yy) * gsc
                    ),
                    r.fillRect(-4, -4, 8, 8),
                    r.restore();
                }
              if (kt <= 1) {
                if ($ >= 0 || kt == 1) {
                  var Ra = !1,
                    xl = 0;
                  B = y.pts[Mr - 1];
                  for (var S = y.pts.length - 1; S >= 2; S--) {
                    for (
                      Mr = S,
                      qe = B,
                      Yt = y.pts[S - 2],
                      ye = y.pts[S - 1],
                      B = y.pts[S],
                      O = B.xx + B.fx,
                      H = B.yy + B.fy,
                      ke = ye.xx + ye.fx,
                      ct = ye.yy + ye.fy,
                      Gi = Yt.xx + Yt.fx,
                      Fs = Yt.yy + Yt.fy,
                      testing &&
                      shifty &&
                      ((r.fillStyle = "#fff"),
                        r.save(),
                        r.translate(
                          mww / 2 + (O - view_xx) * gsc,
                          mhh / 2 + (H - view_yy) * gsc
                        ),
                        r.fillRect(-2, -2, 4, 4),
                        r.restore()),
                      dt = O + (ke - O) * 0.5,
                      ns = H + (ct - H) * 0.5,
                      Di = ke + (Gi - ke) * 0.5,
                      li = ct + (Fs - ct) * 0.5,
                      K = B.ltn + B.fltn,
                      bn = yl * 2 + 2,
                      (B.smu != qe.smu || B.fsmu != qe.fsmu) &&
                      ((U *= (qe.smu + qe.fsmu) / (B.smu + B.fsmu)),
                        (Oi = yl * (B.smu + B.fsmu)),
                        (ut = 1 / Oi),
                        (hi = Ti / Oi)),
                      $ -= xl * ut;
                      U < K;

                    ) {
                      if (
                        ((g = U / K),
                          (Re = dt + (ke - dt) * g),
                          (it = ns + (ct - ns) * g),
                          (Ui = ke + (Di - ke) * g),
                          (Ms = ct + (li - ct) * g),
                          (us = Re + (Ui - Re) * g),
                          (Ts = it + (Ms - it) * g),
                          (Be = fa(y, ps, us, Ts)),
                          ps++,
                          X <= bn &&
                          ((ts = Math.sqrt(
                            Math.pow(Be.xx - Cs.xx, 2) +
                            Math.pow(Be.yy - Cs.yy, 2)
                          )),
                            (Be.d = ts),
                            (Cs = Be),
                            X++),
                          kt == 1)
                      ) {
                        (kt = 2), (S = -9999);
                        break;
                      }
                      ($ -= ut), $ <= 0 ? ((kt = 1), (U += ut + $)) : (U += ut);
                    }
                    (U -= K),
                      (xl = U / ut),
                      ($ += U),
                      (Ra = !0);
                  }
                }
                Ra && ($ -= U);
              }
              if (
                kt <= 1 &&
                ($ >= -1e-4 && $ <= 0 && ($ = 0), $ >= 0 || kt == 1)
              )
                for (
                  B = y.pts[Mr - 1],
                  ye = y.pts[Mr - 2],
                  B && ((O = B.xx + B.fx), (H = B.yy + B.fy)),
                  ke = ye.xx + ye.fx,
                  ct = ye.yy + ye.fy;
                  $ >= 0 || kt == 1;

                ) {
                  if (
                    ((us = ke - (O - ke) * (U - 0.5)),
                      (Ts = ct - (H - ct) * (U - 0.5)),
                      (Be = fa(y, ps, us, Ts)),
                      ps++,
                      X <= bn &&
                      ((ts = Math.sqrt(
                        Math.pow(Be.xx - Cs.xx, 2) + Math.pow(Be.yy - Cs.yy, 2)
                      )),
                        (Be.d = ts),
                        (Cs = Be),
                        X++),
                      kt == 1)
                  ) {
                    (kt = 2), (S = -9999);
                    break;
                  }
                  ($ -= ut),
                    $ <= 0 ? ((kt = 1), (U += ut + $)) : (U += ut),
                    $ >= -1e-4 && $ <= 0 && ($ = 0);
                }
              if (
                ((g = X - 1),
                  g >= Nt.length && (g = Nt.length),
                  choosing_skin && (g = 0),
                  g >= 3)
              ) {
                for (qr = 0, S = 0; S < g - 1; S++) (Be = Nt[S]), (qr += Be.d);
                for (
                  Cs = Nt[0],
                  Ci = Nt[0],
                  K = qr / (g - 2),
                  S = 1,
                  Me = 1,
                  v = K,
                  S = 0;
                  S < g;
                  S++
                )
                  (Nt[S].ox = Nt[S].xx), (Nt[S].oy = Nt[S].yy);
                for (S = 1; S < g; S++) {
                  for (Be = Nt[S]; ;)
                    if (((ci = Nt[Me]), v < ci.d)) {
                      (Be.xx = Ci.ox + ((ci.ox - Ci.ox) * v) / ci.d),
                        (Be.yy = Ci.oy + ((ci.oy - Ci.oy) * v) / ci.d),
                        (Be.xx += (Be.ox - Be.xx) * Math.pow(S / g, 2)),
                        (Be.yy += (Be.oy - Be.yy) * Math.pow(S / g, 2)),
                        (v += K);
                      break;
                    } else if (((v -= ci.d), (Ci = ci), Me++, Me >= g)) {
                      S = g + 1;
                      break;
                    }
                  Cs = Be;
                }
              }
              var as, rr;
              for (S = 0; S < ps; S++)
                testing &&
                  shifty &&
                  (r.save(),
                    (r.fillStyle = "#00FF00"),
                    r.translate(
                      mww / 2 + (Nt[S].xx - view_xx) * gsc,
                      mhh / 2 + (Nt[S].yy - view_yy) * gsc
                    ),
                    r.fillRect(-1, -1, 2, 2),
                    r.restore()),
                  (O = Nt[S].xx),
                  (H = Nt[S].yy),
                  (Ps[Ue] = O),
                  (Es[Ue] = H),
                  (Nr[Ue] = 0),
                  rs && (bs--, bs <= 0 && (bs = 3)),
                  O >= bpx1 &&
                  H >= bpy1 &&
                  O <= bpx2 &&
                  H <= bpy2 &&
                  (rs && bs != 3 ? (xs[Ue] = 1) : (xs[Ue] = 2)),
                  Ue >= 1 &&
                  ((C = O - as), (A = H - rr), (Nr[Ue] = Math.atan2(A, C))),
                  (as = O),
                  (rr = H),
                  Ue++;
              ps >= 2 && (Nr[0] = Nr[1]);
              var Te = 4;
              rs && (Te = 12), r.save(), r.translate(mww2, mhh2);
              var Ye = (gsc * z * 52) / 32,
                ft = (gsc * z * 62) / 32,
                ze = y.alive_amt * (1 - y.dead_amt);
              if (((ze *= ze), (K = 1), y.tsp > y.fsp)) {
                K =
                  y.alive_amt *
                  (1 - y.dead_amt) *
                  Math.max(0, Math.min(1, (y.tsp - y.ssp) / (y.msp - y.ssp)));
                var Gs = K * 0.37,
                  Ys = Math.pow(K, 0.5),
                  Ce = 1.5 * gsc * z * (1 + (62 / 32 - 1) * Ys),
                  Tr = oi.kfmc;
                if (!ggl) {
                  if (
                    (r.save(), (r.globalCompositeOperation = "lighter"), y.rbcs)
                  ) {
                    var gs = y.rbcs,
                      de = gs.length,
                      ms;
                    for (S = Ue - 1; S >= 0; S--)
                      if (xs[S] == 2) {
                        ms = Kt[gs[S % de]];
                        if (!ms) continue;
                        if (
                          ((O = Ps[S]),
                            (H = Es[S]),
                            (Tr = ms.kfmc),
                            r.save(),
                            (r.globalAlpha =
                              ze *
                              Ys *
                              0.38 *
                              (0.6 + 0.4 * Math.cos(S / Te - 1.15 * y.sfr))),
                            r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                            S < 4)
                        ) {
                          var ne = Ce * (1 + (4 - S) * y.swell);
                          r.drawImage(Tr, -ne, -ne, 2 * ne, 2 * ne);
                        } else r.drawImage(Tr, -Ce, -Ce, 2 * Ce, 2 * Ce);
                        r.restore();
                      }
                  } else
                    for (S = Ue - 1; S >= 0; S--)
                      if (xs[S] == 2) {
                        if (
                          ((O = Ps[S]),
                            (H = Es[S]),
                            r.save(),
                            (r.globalAlpha =
                              ze *
                              Ys *
                              0.38 *
                              (0.6 + 0.4 * Math.cos(S / Te - 1.15 * y.sfr))),
                            r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                            S < 4)
                        ) {
                          var ne = Ce * (1 + (4 - S) * y.swell);
                          r.drawImage(Tr, -ne, -ne, 2 * ne, 2 * ne);
                        } else r.drawImage(Tr, -Ce, -Ce, 2 * Ce, 2 * Ce);
                        r.restore();
                      }
                  r.restore();
                }
                K = 1 - K;
              }
              var td = ze * K;
              if (high_quality || gla > 0) {
                var vl = td;
                if ((gla != 1 && (vl = td * gla), (r.globalAlpha = vl), !ggl)) {
                  for (S = Ue - 1; S >= 0; S--)
                    if (xs[S] == 2) {
                      if (
                        ((O = Ps[S]),
                          (H = Es[S]),
                          r.save(),
                          r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                          r.drawImage(be.komc, -Ye, -Ye, 2 * Ye, 2 * Ye),
                          S < 9)
                      ) {
                        if (((r.globalAlpha = ze * (1 - S / 9)), S < 4)) {
                          var ne = ft * (1 + (4 - S) * y.swell);
                          r.drawImage(be.ksmc, -ne, -ne, 2 * ne, 2 * ne);
                        } else r.drawImage(be.ksmc, -ft, -ft, 2 * ft, 2 * ft);
                        r.globalAlpha = ze;
                      }
                      r.restore();
                    }
                }
              }
              if (((r.globalAlpha = td), y.rbcs)) {
                var gs = y.rbcs,
                  bl = y.fdhc,
                  Vm = y.fdtc,
                  wn = y.fdl,
                  Sn,
                  de = gs.length,
                  ms;
                if (ggl) {
                  var jm = y.sgs,
                    Xm = y.shs,
                    sd = y.shs2,
                    Ia = y.sgsv,
                    id = y.sfs,
                    rd = y.sfus,
                    qm = y.sds,
                    Rt = null,
                    It = null,
                    Bt = null,
                    ls = null,
                    hs = null,
                    $s = null;
                  if (Ue > y.lsgvc)
                    for (S = y.sgs.length; S < Ue; S++) {
                      if (
                        ((hs = new Ke(Sr)),
                          hs.anchor.set(0.5),
                          (hs.visible = !1),
                          rd.push(hs),
                          (ls = new Ke(Sr)),
                          ls.anchor.set(0.5),
                          (ls.visible = !1),
                          id.push(ls),
                          (Rt = new Ke(wr[0].t)),
                          Rt.anchor.set(0.5),
                          (Rt.visible = !1),
                          jm.push(Rt),
                          bl && S < wn && Kt[bl])
                      ) {
                        var Mn = new Ke(Kt[bl].kmos[0].t);
                        Mn.anchor.set(0.5),
                          (Mn.scale.x = Mn.scale.y = 1.04),
                          S < 6
                            ? (Mn.alpha = 1)
                            : (Mn.alpha = 1 - (S - 6) / (wn - 6)),
                          Rt.addChild(Mn);
                      }
                      (It = new Ke(be.kso.t)),
                        It.anchor.set(0.5),
                        (It.visible = !1),
                        Xm.push(It),
                        (Bt = new Ke(be.kso.t)),
                        Bt.anchor.set(0.5),
                        (Bt.visible = !1),
                        sd.push(Bt),
                        ($s = new Ke(be.kdo.t)),
                        $s.anchor.set(0.5),
                        ($s.visible = !1),
                        qm.push($s),
                        Ia.push(!1),
                        y.uglo.addChildAt(hs, 0),
                        y.shlo.addChildAt(It, 0),
                        y.sglo.addChildAt(Bt, 0),
                        y.sglo.addChildAt(Rt, 0),
                        y.sflo.addChildAt(ls, 0),
                        y.sdlo.addChildAt($s, 0);
                    }
                  else if (Ue < y.lsgvc)
                    for (
                      g = y.lsgvc - Ue, S = y.lsgvc - 1;
                      S >= 0 &&
                      ((y.sgs[S].visible = !1),
                        (y.shs[S].visible = !1),
                        (y.shs2[S].visible = !1),
                        (y.sfs[S].visible = !1),
                        (y.sfus[S].visible = !1),
                        (y.sds[S].visible = !1),
                        (y.sgsv[S] = !1),
                        g--,
                        !(g <= 0));
                      S--
                    );
                  for (
                    y.lsgvc = Ue,
                    y.tsp > y.fsp
                      ? y.sflo.visible ||
                      ((y.sflo.visible = !0), (y.uglo.visible = !0))
                      : y.sflo.visible &&
                      ((y.sflo.visible = !1), (y.uglo.visible = !1)),
                    y.dead_amt > 0
                      ? y.sdlo.visible || (y.sdlo.visible = !0)
                      : y.sdlo.visible && (y.sdlo.visible = !1),
                    fj = Ue - 1,
                    S = fj;
                    S >= 0;
                    S--
                  )
                    if (((Bt = sd[S]), xs[S] == 2)) {
                      if (((g = S - 4), g < 0)) Bt.alpha = 0;
                      else if (g < Ue) {
                        if (((W = C), (D = A), (C = Ps[g]), (A = Es[g]), g < 9))
                          if (
                            ((K = 0.6 + (0.76 - 0.6) * (g / 9)),
                              (Bt.alpha = ze * (g / 9)),
                              g < 4)
                          ) {
                            var Ds = 1 + (4 - g) * y.swell;
                            (Bt.scale.x = Ds * y.sc * K),
                              (Bt.scale.y = Ds * y.sc * K);
                          } else
                            (Bt.scale.x = y.sc * K), (Bt.scale.y = y.sc * K);
                        else
                          C > W ? (Qe = C - W) : (Qe = W - C),
                            A > D ? (Qe += A - D) : (Qe += D - A),
                            (Qe /= 6),
                            Qe > 1 && (Qe = 1),
                            (Bt.alpha = ze * Qe),
                            (Bt.scale.x = y.sc * 0.88),
                            (Bt.scale.y = y.sc * 0.88);
                        (Bt.x = C - view_xx), (Bt.y = A - view_yy);
                      }
                    } else Bt.alpha = 0;
                  if (y.tsp > y.fsp) {
                    var Te = 4;
                    for (
                      g = 1,
                      rs && ((Te = 12), (g = 0.5)),
                      fj = Ue - 1,
                      Qe = 1,
                      S = fj;
                      S >= 0;
                      S--
                    ) {
                      if (
                        ((ls = id[S]),
                          (hs = rd[S]),
                          S != fj &&
                          (C > W ? (Qe = C - W) : (Qe = W - C),
                            A > D ? (Qe += A - D) : (Qe += D - A),
                            rs ? (Qe /= 3) : (Qe /= 6),
                            Qe > 1 && (Qe = 1)),
                          (W = C),
                          (D = A),
                          (C = Ps[S]),
                          (A = Es[S]),
                          (hs.alpha =
                            Qe *
                            ze *
                            Gs *
                            0.6 *
                            g *
                            (0.6 + 0.4 * Math.cos(S / Te - y.sfr))),
                          S < 4)
                      ) {
                        var Ds = 1 + (4 - S) * y.swell;
                        (hs.scale.x = Ds * y.sc * 1.5),
                          (hs.scale.y = Ds * y.sc * 1.5);
                      } else
                        (hs.scale.x = y.sc * 1.5), (hs.scale.y = y.sc * 1.5);
                      if (
                        ((hs.x = C - view_xx),
                          (hs.y = A - view_yy),
                          (ls.alpha =
                            Qe *
                            ze *
                            Gs *
                            0.4 *
                            g *
                            (0.5 + 0.5 * Math.cos(S / Te - y.sfr))),
                          S < 4)
                      ) {
                        var Ds = 1 + (4 - S) * y.swell;
                        (ls.scale.x = Ds * y.sc * 1.3),
                          (ls.scale.y = Ds * y.sc * 1.3);
                      } else
                        (ls.scale.x = y.sc * 1.3), (ls.scale.y = y.sc * 1.3);
                      (ls.x = C - view_xx), (ls.y = A - view_yy);
                    }
                  }
                  for (fj = Ue - 1, fjm4 = fj - 4, S = fj; S >= 0; S--)
                    if (
                      ((Rt = jm[S]),
                        (It = Xm[S]),
                        (Bt = sd[S]),
                        (ls = id[S]),
                        (hs = rd[S]),
                        ($s = qm[S]),
                        xs[S] >= 1)
                    ) {
                      if (
                        ((O = Ps[S]),
                          (H = Es[S]),
                          (g = 0),
                          y.cusk ||
                          (ds
                            ? ((g = S % Ut), g >= Et && (g = Ut - (g + 1)))
                            : (g = S % Et)),
                          (ms = Kt[gs[S % de]]),
                          ms && (Ia[S] ||
                            ((Rt.visible = !0),
                              (It.visible = !0),
                              (Bt.visible = !0),
                              (ls.visible = !0),
                              (hs.visible = !0),
                              (Ia[S] = !0),
                              (Rt.texture = ms.kmos[g].t),
                              (ls.texture = ms.kfo.t),
                              (hs.texture = ms.kfo.t))),
                          ms && xs[S] >= 2)
                      )
                        if (((g = S - 4), g < 0 && (g = 0), g < 9)) {
                          if (((It.alpha = ze * (1 - g / 9)), S < 4)) {
                            var Ds = 1 + (4 - S) * y.swell;
                            (It.scale.x = Ds * y.sc * 0.88),
                              (It.scale.y = Ds * y.sc * 0.88);
                          } else
                            (It.scale.x = y.sc * 0.88),
                              (It.scale.y = y.sc * 0.88);
                          (It.x = O - view_xx), (It.y = H - view_yy);
                        } else
                          S >= fjm4
                            ? ((It.alpha = 1),
                              (It.scale.x = y.sc * 0.88),
                              (It.scale.y = y.sc * 0.88),
                              (It.x = O - view_xx),
                              (It.y = H - view_yy))
                            : (It.alpha = 0);
                      else It.alpha = 0;
                      if (((Rt.alpha = ze), (Rt.rotation = Nr[S]), S < 4)) {
                        var Ds = 1 + (4 - S) * y.swell;
                        (Rt.scale.x = Ds * y.sc * 0.62),
                          (Rt.scale.y = Ds * y.sc * 0.62);
                      } else
                        (Rt.scale.x = y.sc * 0.62), (Rt.scale.y = y.sc * 0.62);
                      if (
                        ((Rt.x = O - view_xx),
                          (Rt.y = H - view_yy),
                          sgsdr++,
                          y.dead)
                      ) {
                        var ht =
                          (0.15 +
                            0.15 *
                            Math.abs(Math.sin(5 * Math.PI * y.dead_amt))) *
                          Math.sin(Math.PI * y.dead_amt);
                        ($s.scale.x = (Rt.scale.x * _t) / 64),
                          ($s.scale.y = (Rt.scale.y * _t) / 64),
                          ($s.x = Rt.x),
                          ($s.y = Rt.y),
                          ($s.visible = !0),
                          ($s.alpha =
                            ht *
                            (0.6 + 0.4 * Math.cos(S / 4 - 15 * y.dead_amt)));
                      }
                    } else
                      Ia[S] &&
                        ((Rt.visible = !1),
                          (It.visible = !1),
                          (Bt.visible = !1),
                          (ls.visible = !1),
                          (hs.visible = !1),
                          ($s.visible = !1),
                          (Ia[S] = !1));
                } else
                  for (S = Ue - 1; S >= 0; S--)
                    if (xs[S] >= 1) {
                      if (
                        ((O = Ps[S]),
                          (H = Es[S]),
                          S >= 4 && ((g = S - 4), xs[g] == 2))
                      ) {
                        if (
                          ((C = Ps[g]),
                            (A = Es[g]),
                            r.save(),
                            r.translate((C - view_xx) * gsc, (A - view_yy) * gsc),
                            g < 9)
                        )
                          if (((r.globalAlpha = ze * (g / 9)), g < 4)) {
                            var ne = ft * (1 + (4 - g) * y.swell);
                            r.drawImage(be.ksmc, -ne, -ne, 2 * ne, 2 * ne);
                          } else r.drawImage(be.ksmc, -ft, -ft, 2 * ft, 2 * ft);
                        else
                          (r.globalAlpha = ze),
                            r.drawImage(be.ksmc, -ft, -ft, 2 * ft, 2 * ft);
                        r.restore();
                      }
                      r.save(),
                        (r.globalAlpha = ze),
                        r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                        nsr || r.rotate(Nr[S]);
                      var g = 0;
                      ms = Kt[gs[S % de]];
                      if (!ms) { r.restore(); continue; }
                      if (
                        (y.cusk ||
                          (ds
                            ? ((g = S % Ut), g >= Et && (g = Ut - (g + 1)))
                            : (g = S % Et)),
                          S < 4)
                      ) {
                        var ne = z * (1 + (4 - S) * y.swell);
                        r.drawImage(
                          ms.kmcs[g],
                          -gsc * ne,
                          -gsc * ne,
                          gsc * 2 * ne,
                          gsc * 2 * ne
                        );
                      } else
                        r.drawImage(
                          ms.kmcs[g],
                          -gsc * z,
                          -gsc * z,
                          gsc * 2 * z,
                          gsc * 2 * z
                        );
                      if (bl && S < wn && Kt[bl]) {
                        (Sn = 1 - S / wn),
                          (ms = Kt[bl]),
                          (r.globalAlpha = ze * Sn);
                        var ne = (1 + 0.05 * Sn) * z * (1 + (4 - S) * y.swell);
                        r.drawImage(
                          ms.kmcs[0],
                          -gsc * ne,
                          -gsc * ne,
                          gsc * 2 * ne,
                          gsc * 2 * ne
                        );
                      }
                      if (Vm && S > Ue - wn && Kt[Vm]) {
                        (Sn = 1 - (Ue - S) / wn),
                          (ms = Kt[Vm]),
                          (r.globalAlpha = ze * Sn);
                        var ne = (1 + 0.05 * Sn) * z * (1 + (4 - S) * y.swell);
                        r.drawImage(
                          ms.kmcs[0],
                          -gsc * ne,
                          -gsc * ne,
                          gsc * 2 * ne,
                          gsc * 2 * ne
                        );
                      }
                      r.restore();
                    }
                if (!ggl && y.tsp > y.fsp && (high_quality || gla > 0)) {
                  r.save(), (r.globalCompositeOperation = "lighter");
                  var Te = 4;
                  rs && (Te = 12);
                  var Ce = z * 2;
                  for (S = Ue - 1; S >= 0; S--)
                    if (xs[S] == 2) {
                      (O = Ps[S]),
                        (H = Es[S]),
                        r.save(),
                        r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                        (r.globalAlpha =
                          ze *
                          Gs *
                          gla *
                          (0.5 + 0.5 * Math.cos(S / Te - y.sfr)));
                      var g = 0;
                      var _kti = Kt[gs[S % de]];
                      if (!_kti) { r.restore(); continue; }
                      if (
                        (y.cusk ||
                          (ds
                            ? ((g = S % Ut), g >= Et && (g = Ut - (g + 1)))
                            : (g = S % Et)),
                          S < 4)
                      ) {
                        var ne = Ce * (1 + (4 - S) * y.swell);
                        r.drawImage(
                          _kti.kfmc,
                          -gsc * ne,
                          -gsc * ne,
                          gsc * 2 * ne,
                          gsc * 2 * ne
                        );
                      } else
                        r.drawImage(
                          _kti.kfmc,
                          -gsc * Ce,
                          -gsc * Ce,
                          gsc * 2 * Ce,
                          gsc * 2 * Ce
                        );
                      r.restore();
                    }
                  r.restore();
                }
              } else {
                for (S = Ue - 1; S >= 0; S--)
                  if (xs[S] >= 1) {
                    if (
                      ((O = Ps[S]),
                        (H = Es[S]),
                        S >= 4 && ((g = S - 4), xs[g] == 2))
                    ) {
                      if (
                        ((C = Ps[g]),
                          (A = Es[g]),
                          r.save(),
                          r.translate((C - view_xx) * gsc, (A - view_yy) * gsc),
                          g < 9)
                      )
                        if (((r.globalAlpha = ze * (g / 9)), g < 4)) {
                          var ne = ft * (1 + (4 - g) * y.swell);
                          r.drawImage(be.ksmc, -ne, -ne, 2 * ne, 2 * ne);
                        } else r.drawImage(be.ksmc, -ft, -ft, 2 * ft, 2 * ft);
                      else
                        (r.globalAlpha = ze),
                          r.drawImage(be.ksmc, -ft, -ft, 2 * ft, 2 * ft);
                      r.restore();
                    }
                    r.save(),
                      (r.globalAlpha = ze),
                      r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                      nsr || r.rotate(Nr[S]);
                    var g = 0;
                    if (
                      (y.cusk ||
                        (ds
                          ? ((g = S % Ut), g >= Et && (g = Ut - (g + 1)))
                          : (g = S % Et)),
                        S < 4)
                    ) {
                      var ne = z * (1 + (4 - S) * y.swell);
                      r.drawImage(
                        Fi[g],
                        -gsc * ne,
                        -gsc * ne,
                        gsc * 2 * ne,
                        gsc * 2 * ne
                      );
                    } else
                      r.drawImage(
                        Fi[g],
                        -gsc * z,
                        -gsc * z,
                        gsc * 2 * z,
                        gsc * 2 * z
                      );
                    r.restore();
                  }
                if (y.tsp > y.fsp && (high_quality || gla > 0)) {
                  r.save(), (r.globalCompositeOperation = "lighter");
                  var Te = 4;
                  rs && (Te = 12);
                  var Ce = z * 2;
                  for (S = Ue - 1; S >= 0; S--)
                    if (xs[S] >= 1) {
                      (O = Ps[S]), (H = Es[S]);
                      var g = 0;
                      if (
                        (y.cusk ||
                          (ds
                            ? ((g = S % Ut), g >= Et && (g = Ut - (g + 1)))
                            : (g = S % Et)),
                          r.save(),
                          r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                          (r.globalAlpha =
                            ze *
                            Gs *
                            gla *
                            (0.5 + 0.5 * Math.cos(S / Te - y.sfr))),
                          S < 4)
                      ) {
                        var ne = Ce * (1 + (4 - S) * y.swell);
                        r.drawImage(
                          oi.kfmc,
                          -gsc * ne,
                          -gsc * ne,
                          gsc * 2 * ne,
                          gsc * 2 * ne
                        );
                      } else
                        r.drawImage(
                          oi.kfmc,
                          -gsc * Ce,
                          -gsc * Ce,
                          gsc * 2 * Ce,
                          gsc * 2 * Ce
                        );
                      r.restore();
                    }
                  r.restore();
                }
              }
              if (y.antenna)
                if (
                  ((C = Math.cos(y.ang)),
                    (A = Math.sin(y.ang)),
                    (ax = b - C * 8 * y.sc),
                    (ay = T - A * 8 * y.sc),
                    Ue >= 2 &&
                    ax >= apx1 &&
                    ay >= apy1 &&
                    ax <= apx2 &&
                    ay <= apy2)
                ) {
                  (y.atx[0] = ax), (y.aty[0] = ay);
                  var K = y.sc * gsc;
                  if (((fj = y.atx.length - 1), choosing_skin))
                    for (var S = 1; S <= fj; S++)
                      (y.atvx[S] -= 0.3),
                        (y.atvy[S] += Math.cos(fr / 23 - (7 * S) / fj) * 0.14);
                  else if (!y.antenna_shown) {
                    y.antenna_shown = !0;
                    for (var S = 1; S <= fj; S++)
                      (y.atx[S] = ax - C * S * 4 * y.sc),
                        (y.aty[S] = ay - A * S * 4 * y.sc);
                  }
                  for (var S = 1; S <= fj; S++)
                    (xx = y.atx[S - 1]),
                      (yy = y.aty[S - 1]),
                      (xx += Math.random() * 2 - 1),
                      (yy += Math.random() * 2 - 1),
                      (C = y.atx[S] - xx),
                      (A = y.aty[S] - yy),
                      C >= -4 && A >= -4 && C < 4 && A < 4
                        ? (ang = at2lt[((A * 32 + 128) << 8) | (C * 32 + 128)])
                        : C >= -8 && A >= -8 && C < 8 && A < 8
                          ? (ang = at2lt[((A * 16 + 128) << 8) | (C * 16 + 128)])
                          : C >= -16 && A >= -16 && C < 16 && A < 16
                            ? (ang = at2lt[((A * 8 + 128) << 8) | (C * 8 + 128)])
                            : C >= -127 && A >= -127 && C < 127 && A < 127
                              ? (ang = at2lt[((A + 128) << 8) | (C + 128)])
                              : (ang = Math.atan2(A, C)),
                      (xx += Math.cos(ang) * 4 * y.sc),
                      (yy += Math.sin(ang) * 4 * y.sc),
                      (y.atvx[S] += (xx - y.atx[S]) * 0.1),
                      (y.atvy[S] += (yy - y.aty[S]) * 0.1),
                      (y.atx[S] += y.atvx[S]),
                      (y.aty[S] += y.atvy[S]),
                      (y.atvx[S] *= 0.88),
                      (y.atvy[S] *= 0.88),
                      (C = y.atx[S] - y.atx[S - 1]),
                      (A = y.aty[S] - y.aty[S - 1]),
                      (ts = Math.sqrt(C * C + A * A)),
                      ts > 4 * y.sc &&
                      (C >= -4 && A >= -4 && C < 4 && A < 4
                        ? (ang =
                          at2lt[((A * 32 + 128) << 8) | (C * 32 + 128)])
                        : C >= -8 && A >= -8 && C < 8 && A < 8
                          ? (ang =
                            at2lt[((A * 16 + 128) << 8) | (C * 16 + 128)])
                          : C >= -16 && A >= -16 && C < 16 && A < 16
                            ? (ang = at2lt[((A * 8 + 128) << 8) | (C * 8 + 128)])
                            : C >= -127 && A >= -127 && C < 127 && A < 127
                              ? (ang = at2lt[((A + 128) << 8) | (C + 128)])
                              : (ang = Math.atan2(A, C)),
                        (y.atx[S] = y.atx[S - 1] + Math.cos(ang) * 4 * y.sc),
                        (y.aty[S] = y.aty[S - 1] + Math.sin(ang) * 4 * y.sc));
                  (r.globalAlpha = ze),
                    (r.strokeStyle = y.atc1),
                    (r.lineWidth = 5 * K),
                    (r.lineCap = "round"),
                    (r.lineJoin = "round"),
                    r.beginPath(),
                    (fj = y.atx.length - 1),
                    (C = (y.atx[fj] - view_xx) * gsc),
                    (A = (y.aty[fj] - view_yy) * gsc),
                    r.moveTo(C, A);
                  for (var S = fj - 1; S >= 1; S--)
                    (xx = (y.atx[S] - view_xx) * gsc),
                      (yy = (y.aty[S] - view_yy) * gsc),
                      Math.abs(xx - C) + Math.abs(yy - A) >= 1 &&
                      ((C = xx), (A = yy), r.lineTo(C, A));
                  (xx = ((y.atx[1] + y.atx[0]) * 0.5 - view_xx) * gsc),
                    (yy = ((y.aty[1] + y.aty[0]) * 0.5 - view_yy) * gsc),
                    Math.abs(xx - C) + Math.abs(yy - A) >= 1 &&
                    ((C = xx), (A = yy), r.lineTo(C, A)),
                    r.stroke(),
                    (r.globalAlpha = y.atia * ze),
                    (r.strokeStyle = y.atc2),
                    (r.lineWidth = 4 * K),
                    r.beginPath(),
                    (fj = y.atx.length - 1),
                    (C = (y.atx[fj] - view_xx) * gsc),
                    (A = (y.aty[fj] - view_yy) * gsc),
                    r.moveTo(C, A);
                  for (var S = fj - 1; S >= 0; S--)
                    (xx = (y.atx[S] - view_xx) * gsc),
                      (yy = (y.aty[S] - view_yy) * gsc),
                      Math.abs(xx - C) + Math.abs(yy - A) >= 1 &&
                      ((C = xx), (A = yy), r.lineTo(C, A));
                  r.stroke(),
                    y.atwg &&
                    ((r.lineWidth = 3 * K),
                      r.stroke(),
                      (r.lineWidth = 2 * K),
                      r.stroke()),
                    (r.globalAlpha = ze * y.blba),
                    y.abrot
                      ? (r.save(),
                        r.translate(
                          (y.atx[fj] - view_xx) * gsc,
                          (y.aty[fj] - view_yy) * gsc
                        ),
                        (vang =
                          Math.atan2(
                            y.aty[fj] - y.aty[fj - 1],
                            y.atx[fj] - y.atx[fj - 1]
                          ) - y.atba),
                        (vang < 0 || vang >= pi2) && (vang %= pi2),
                        vang < -Math.PI
                          ? (vang += pi2)
                          : vang > Math.PI && (vang -= pi2),
                        (y.atba = (y.atba + vang * 0.15) % pi2),
                        r.rotate(y.atba),
                        r.drawImage(
                          y.bulb,
                          y.blbx * y.bsc * K,
                          y.blby * y.bsc * K,
                          y.blbw * y.bsc * K,
                          y.blbh * y.bsc * K
                        ),
                        r.restore())
                      : r.drawImage(
                        y.bulb,
                        (y.atx[fj] - view_xx + y.blbx * y.bsc * y.sc) * gsc,
                        (y.aty[fj] - view_yy + y.blby * y.bsc * y.sc) * gsc,
                        y.blbw * y.bsc * K,
                        y.blbh * y.bsc * K
                      ),
                    y.apbs &&
                    ((r.globalAlpha = 0.5 * ze),
                      (r.lineWidth = 3 * K),
                      r.stroke(),
                      (r.lineWidth = 2 * K),
                      r.stroke());
                } else y.antenna_shown && (y.antenna_shown = !1);
              if (!ggl && y.dead) {
                r.save(), (r.globalCompositeOperation = "lighter");
                var ht =
                  (0.15 +
                    0.15 * Math.abs(Math.sin(5 * Math.PI * y.dead_amt))) *
                  Math.sin(Math.PI * y.dead_amt),
                  Ba = gsc * z;
                for (S = Ue - 1; S >= 0; S--)
                  if (xs[S] == 2) {
                    if (
                      ((O = Ps[S]),
                        (H = Es[S]),
                        r.save(),
                        (r.globalAlpha =
                          ht * (0.6 + 0.4 * Math.cos(S / 4 - 15 * y.dead_amt))),
                        r.translate((O - view_xx) * gsc, (H - view_yy) * gsc),
                        S < 4)
                    ) {
                      var ne = Ba * (1 + (4 - S) * y.swell);
                      r.drawImage(be.kdmc, -ne, -ne, 2 * ne, 2 * ne);
                    } else r.drawImage(be.kdmc, -Ba, -Ba, 2 * Ba, 2 * Ba);
                    r.restore();
                  }
                r.restore();
              }
              r.restore();
            }
            if (y.one_eye) {
              var Mt = 3 * V,
                pt = Math.cos(I) * Mt,
                gt = Math.sin(I) * Mt,
                Ai = V * y.ebisz;
              ggl
                ? ((y.ebi.x = pt + b - view_xx),
                  (y.ebi.y = gt + T - view_yy),
                  (y.ebi.scale.x = y.ebi.scale.y = Ai / 64))
                : r.drawImage(
                  y.ebi,
                  0,
                  0,
                  y.ebiw,
                  y.ebih,
                  mww2 + (pt + b - Ai / 2 - view_xx) * gsc,
                  mhh2 + (gt + T - Ai / 2 - view_yy) * gsc,
                  Ai * gsc,
                  Ai * gsc
                );
              var pt = Math.cos(I) * (Mt + 0.15) + y.rex * V,
                gt = Math.sin(I) * (Mt + 0.15) + y.rey * V,
                Ai = V * y.episz;
              ggl
                ? ((y.epi.x = pt + b - view_xx),
                  (y.epi.y = gt + T - view_yy),
                  (y.epi.scale.x = y.epi.scale.y = Ai / 48))
                : r.drawImage(
                  y.epi,
                  0,
                  0,
                  y.epiw,
                  y.epih,
                  mww2 + (pt + b - Ai / 2 - view_xx) * gsc,
                  mhh2 + (gt + T - Ai / 2 - view_yy) * gsc,
                  Ai * gsc,
                  Ai * gsc
                );
            } else {
              var Mt = y.ed * V,
                Ks = y.esp * V;
              if (!y.eac) {
                var pt =
                  Math.cos(I) * Mt + Math.cos(I - Math.PI / 2) * (Ks + 0.5),
                  gt =
                    Math.sin(I) * Mt + Math.sin(I - Math.PI / 2) * (Ks + 0.5);
                if (ggl) {
                  var Fa = y.lefteye;
                  (Fa.alpha = y.eca * y.alive_amt),
                    (Fa.x = pt + b - view_xx),
                    (Fa.y = gt + T - view_yy),
                    (Fa.scale.x = Fa.scale.y = (y.er * V) / 36);
                } else
                  (r.fillStyle = y.ec),
                    y.eo > 0 &&
                    ((r.lineWidth = y.eo * gsc), (r.strokeStyle = "#000000")),
                    (r.globalAlpha = y.eca * y.alive_amt),
                    r.beginPath(),
                    r.arc(
                      mww2 + (pt + b - view_xx) * gsc,
                      mhh2 + (gt + T - view_yy) * gsc,
                      y.er * V * gsc,
                      0,
                      pi2
                    ),
                    r.closePath(),
                    y.eo > 0 && r.stroke(),
                    r.fill();
                var pt =
                  Math.cos(I) * (Mt + 0.5) +
                  y.rex * V +
                  Math.cos(I - Math.PI / 2) * Ks,
                  gt =
                    Math.sin(I) * (Mt + 0.5) +
                    y.rey * V +
                    Math.sin(I - Math.PI / 2) * Ks;
                if (ggl) {
                  var Ga = y.leftpupil;
                  (Ga.alpha = y.ppa),
                    (Ga.x = pt + b - view_xx),
                    (Ga.y = gt + T - view_yy),
                    (Ga.scale.x = Ga.scale.y = (y.pr * V) / 21);
                } else
                  (r.globalAlpha = y.ppa),
                    (r.fillStyle = y.ppc),
                    r.beginPath(),
                    r.arc(
                      mww2 + (pt + b - view_xx) * gsc,
                      mhh2 + (gt + T - view_yy) * gsc,
                      y.pr * V * gsc,
                      0,
                      pi2
                    ),
                    r.closePath(),
                    r.fill();
                var pt =
                  Math.cos(I) * Mt + Math.cos(I + Math.PI / 2) * (Ks + 0.5),
                  gt =
                    Math.sin(I) * Mt + Math.sin(I + Math.PI / 2) * (Ks + 0.5);
                if (ggl) {
                  var Da = y.righteye;
                  (Da.alpha = y.eca * y.alive_amt),
                    (Da.x = pt + b - view_xx),
                    (Da.y = gt + T - view_yy),
                    (Da.scale.x = Da.scale.y = (y.er * V) / 36);
                } else
                  (r.fillStyle = y.ec),
                    y.eo > 0 &&
                    ((r.lineWidth = y.eo * gsc), (r.strokeStyle = "#000000")),
                    (r.globalAlpha = y.eca * y.alive_amt),
                    r.beginPath(),
                    r.arc(
                      mww2 + (pt + b - view_xx) * gsc,
                      mhh2 + (gt + T - view_yy) * gsc,
                      y.er * V * gsc,
                      0,
                      pi2
                    ),
                    r.closePath(),
                    y.eo > 0 && r.stroke(),
                    r.fill();
                var pt =
                  Math.cos(I) * (Mt + 0.5) +
                  y.rex * V +
                  Math.cos(I + Math.PI / 2) * Ks,
                  gt =
                    Math.sin(I) * (Mt + 0.5) +
                    y.rey * V +
                    Math.sin(I + Math.PI / 2) * Ks;
                if (ggl) {
                  var Ua = y.rightpupil;
                  (Ua.alpha = y.ppa),
                    (Ua.x = pt + b - view_xx),
                    (Ua.y = gt + T - view_yy),
                    (Ua.scale.x = Ua.scale.y = (y.pr * V) / 21);
                } else
                  (r.globalAlpha = y.ppa),
                    (r.fillStyle = y.ppc),
                    r.beginPath(),
                    r.arc(
                      mww2 + (pt + b - view_xx) * gsc,
                      mhh2 + (gt + T - view_yy) * gsc,
                      y.pr * V * gsc,
                      0,
                      pi2
                    ),
                    r.closePath(),
                    r.fill();
                if (y.accessory != -1) {
                  var S = y.accessory;
                  if (S >= 0 && S < Zw) {
                    var pt = Math.cos(I) * Mt,
                      gt = Math.sin(I) * Mt,
                      nr = sr[S],
                      Tn = nr.img;
                    if (Tn == null)
                      (Tn = document.createElement("img")),
                        (sr[S].img = Tn),
                        (Tn.onload = function () {
                          for (var Sl = sr.length - 1; Sl >= 0; Sl--)
                            if (sr[Sl].img == this) {
                              var nd = sr[Sl];
                              (nd.ww = this.width),
                                (nd.hh = this.height),
                                (nd.loaded = !0);
                              break;
                            }
                        }),
                        (Tn.src = sr[S].u);
                    else if (nr.loaded) {
                      var K = y.sc * gsc * nr.sc;
                      r.save(),
                        r.translate(
                          mww2 + (pt + b - view_xx) * gsc,
                          mhh2 + (gt + T - view_yy) * gsc
                        ),
                        r.rotate(I),
                        (r.globalAlpha = ze),
                        r.drawImage(
                          Tn,
                          0,
                          0,
                          nr.ww,
                          nr.hh,
                          -K * nr.px,
                          -K * nr.py,
                          K * nr.ww,
                          K * nr.hh
                        ),
                        r.restore();
                    }
                  }
                }
              }
              if (y.jyt) {
                var K = y.sc * gsc * 0.25,
                  Mt = -3 * V,
                  Ks = 7 * V,
                  pt =
                    Math.cos(I) * (Mt + 0.5) +
                    y.rex * V +
                    Math.cos(I - Math.PI / 2) * Ks,
                  gt =
                    Math.sin(I) * (Mt + 0.5) +
                    y.rey * V +
                    Math.sin(I - Math.PI / 2) * Ks;
                r.save(),
                  r.translate(
                    mww2 + (pt + b - view_xx) * gsc,
                    mhh2 + (gt + T - view_yy) * gsc
                  ),
                  r.rotate(I),
                  r.drawImage(be.ecmc, -24 * K, -24 * K, 48 * K, 48 * K),
                  r.restore();
                var pt =
                  Math.cos(I) * (Mt + 0.5) +
                  y.rex * V +
                  Math.cos(I + Math.PI / 2) * Ks,
                  gt =
                    Math.sin(I) * (Mt + 0.5) +
                    y.rey * V +
                    Math.sin(I + Math.PI / 2) * Ks;
                r.save(),
                  r.translate(
                    mww2 + (pt + b - view_xx) * gsc,
                    mhh2 + (gt + T - view_yy) * gsc
                  ),
                  r.rotate(I),
                  r.drawImage(be.ecmc, -24 * K, -24 * K, 48 * K, 48 * K),
                  r.restore();
                var Mt = 5 * V,
                  pt = Math.cos(I) * (Mt + 0.5) + y.rex * V,
                  gt = Math.sin(I) * (Mt + 0.5) + y.rey * V;
                (K = y.sc * gsc * 0.16),
                  r.save(),
                  r.translate(
                    mww2 + (pt + b - view_xx) * gsc,
                    mhh2 + (gt + T - view_yy) * gsc
                  ),
                  r.rotate(I),
                  r.drawImage(be.jmou, -40 * K, -65 * K, 79 * K, 130 * K),
                  r.restore();
              }
            }
            if (((r.globalAlpha = 1), y.slg)) {
              var K = y.sc * gsc * 0.25;
              if (ggl) {
                var C =
                  Math.cos(I) * 13 * V +
                  Math.cos(I - Math.PI / 2) * (6 * V + 0.5),
                  A =
                    Math.sin(I) * 13 * V +
                    Math.sin(I - Math.PI / 2) * (6 * V + 0.5);
                (y.stem1.x = C + b - view_xx),
                  (y.stem1.y = A + T - view_yy),
                  (y.stem1.scale.x = y.stem1.scale.y = K),
                  (y.stem1.rotation = I - 0.4);
                var C =
                  Math.cos(I) * 13 * V +
                  Math.cos(I + Math.PI / 2) * (6 * V + 0.5),
                  A =
                    Math.sin(I) * 13 * V +
                    Math.sin(I + Math.PI / 2) * (6 * V + 0.5);
                (y.stem2.x = C + b - view_xx),
                  (y.stem2.y = A + T - view_yy),
                  (y.stem2.scale.x = y.stem2.scale.y = K),
                  (y.stem2.rotation = I + 0.4);
              } else {
                r.save();
                var C =
                  Math.cos(I) * 13 * V +
                  Math.cos(I - Math.PI / 2) * (6 * V + 0.5),
                  A =
                    Math.sin(I) * 13 * V +
                    Math.sin(I - Math.PI / 2) * (6 * V + 0.5);
                r.translate(
                  mww2 + (C + b - view_xx) * gsc,
                  mhh2 + (A + T - view_yy) * gsc
                ),
                  r.rotate(I - 0.4),
                  r.drawImage(be.sest, -28 * K, -44 * K, 105 * K, 88 * K),
                  r.restore(),
                  r.save();
                var C =
                  Math.cos(I) * 13 * V +
                  Math.cos(I + Math.PI / 2) * (6 * V + 0.5),
                  A =
                    Math.sin(I) * 13 * V +
                    Math.sin(I + Math.PI / 2) * (6 * V + 0.5);
                r.translate(
                  mww2 + (C + b - view_xx) * gsc,
                  mhh2 + (A + T - view_yy) * gsc
                ),
                  r.rotate(I + 0.4),
                  r.drawImage(be.sest, -28 * K, -44 * K, 105 * K, 88 * K),
                  r.restore();
              }
            }
          }
        if (ggl) {
          var _ = 1,
            w = 0.75;
          fdsdr = 0;
          for (var p = foods_c - 1; p >= 0; p--) {
            var m = foods[p],
              di = m.fi,
              Li = m.ofi,
              Ni = m.gfi,
              Hi = m.g2fi;
            if (m.rx >= fpx1 && m.ry >= fpy1 && m.rx <= fpx2 && m.ry <= fpy2) {
              let Cn = m.rx - view_xx,
                An = m.ry - view_yy;
              (Li.x = Cn),
                (Li.y = An),
                (di.x = Cn),
                (di.y = An),
                fdsdr++,
                (o = Cn * Cn + An * An),
                o > 1e6 || !high_quality
                  ? ((Ni.alpha = 0), (Hi.alpha = 0))
                  : ((fs = 1 + 0.064 * m.rad),
                    (a = 0.21 * gla * (1 - o / (44600 + o))),
                    m.rad != 1 && (a *= m.rad),
                    (Ni.alpha = a * (0.7 + 0.3 * Math.cos(m.gfr / 13)) * m.fr),
                    (Ni.x = Cn * fs),
                    (Ni.y = An * fs),
                    (fs = 1 + 0.21 * m.rad),
                    (J = Cn * fs),
                    (F = An * fs),
                    (a = 0.085 * gla * (1 - o / (16500 + o))),
                    m.rad != 1 && (a *= m.rad),
                    (Hi.alpha = a * (0.7 + 0.3 * Math.cos(m.gfr / 13)) * m.fr),
                    (Hi.x = J),
                    (Hi.y = F)),
                m.fr == 1 && m.rad == 1
                  ? ((Li.alpha = _),
                    (di.alpha = 0.25 + w * (0.5 + 0.5 * Math.cos(m.gfr / 13))),
                    (Li.scale.x = 0.0165 + m.sz * 0.03),
                    (Li.scale.y = 0.0165 + m.sz * 0.03),
                    (di.scale.x = 0.04 + m.sz / 15),
                    (di.scale.y = 0.04 + m.sz / 15),
                    (Ni.scale.x = m.sz / 5),
                    (Ni.scale.y = m.sz / 5),
                    (Hi.scale.x = m.sz / 2),
                    (Hi.scale.y = m.sz / 2))
                  : ((Li.alpha = _ * m.fr),
                    (di.alpha =
                      0.25 + w * (0.5 + 0.5 * Math.cos(m.gfr / 13)) * m.fr),
                    (Li.scale.x = 0.0165 + m.sz * 0.03 * m.rad),
                    (Li.scale.y = 0.0165 + m.sz * 0.03 * m.rad),
                    (di.scale.x = 0.04 + (m.sz / 15) * m.rad),
                    (di.scale.y = 0.04 + (m.sz / 15) * m.rad),
                    (Ni.scale.x = (m.sz / 5) * m.rad),
                    (Ni.scale.y = (m.sz / 5) * m.rad),
                    (Hi.scale.x = (m.sz / 2) * m.rad),
                    (Hi.scale.y = (m.sz / 2) * m.rad)),
                di.visible ||
                ((di.visible = !0),
                  (Li.visible = !0),
                  (Ni.visible = !0),
                  (Hi.visible = !0));
            } else
              di.visible &&
                ((di.visible = !1),
                  (Li.visible = !1),
                  (Ni.visible = !1),
                  (Hi.visible = !1));
          }
        } else {
          if (high_quality || gla > 0) {
            r.save(), (r.globalCompositeOperation = "lighter");
            for (var p = foods_c - 1; p >= 0; p--) {
              var m = foods[p];
              m.rx >= fpx1 &&
                m.ry >= fpy1 &&
                m.rx <= fpx2 &&
                m.ry <= fpy2 &&
                ((C = m.rx - view_xx),
                  (A = m.ry - view_yy),
                  (o = C * C + A * A),
                  (fs = 1 + 0.06 * m.rad),
                  (J = C * fs),
                  (F = A * fs),
                  (a = 0.005 + 0.09 * (1 - o / (86e3 + o))),
                  m.rad != 1 && (a *= Math.pow(m.rad, 0.25)),
                  gla != 1 && (a *= gla),
                  (J = J * gsc + mww2),
                  (F = F * gsc + mhh2),
                  m.rad == 1
                    ? ((J -= m.gfw2),
                      (F -= m.gfh2),
                      (r.globalAlpha = a * m.fr),
                      r.drawImage(m.gfi, J, F),
                      (r.globalAlpha =
                        a * (0.5 + 0.5 * Math.cos(m.gfr / 13)) * m.fr),
                      r.drawImage(m.gfi, J, F))
                    : ((J -= m.gfw2 * m.rad),
                      (F -= m.gfh2 * m.rad),
                      (r.globalAlpha = a * m.fr),
                      r.drawImage(
                        m.gfi,
                        0,
                        0,
                        m.gfw,
                        m.gfh,
                        J,
                        F,
                        m.gfw * m.rad,
                        m.gfh * m.rad
                      ),
                      (r.globalAlpha =
                        a * (0.5 + 0.5 * Math.cos(m.gfr / 13)) * m.fr),
                      r.drawImage(
                        m.gfi,
                        0,
                        0,
                        m.gfw,
                        m.gfh,
                        J,
                        F,
                        m.gfw * m.rad,
                        m.gfh * m.rad
                      )),
                  (fs = 1 + 0.32 * m.rad),
                  (J = C * fs),
                  (F = A * fs),
                  (a = 0.085 * (1 - o / (16500 + o))),
                  m.rad != 1 && (a *= Math.pow(m.rad, 0.25)),
                  gla != 1 && (a *= gla),
                  (J = J * gsc + mww2),
                  (F = F * gsc + mhh2),
                  m.rad == 1
                    ? ((J -= m.g2fw2),
                      (F -= m.g2fh2),
                      (r.globalAlpha = a * m.fr),
                      r.drawImage(m.g2fi, J, F),
                      (r.globalAlpha =
                        a * (0.5 + 0.5 * Math.cos(m.gfr / 13)) * m.fr),
                      r.drawImage(m.g2fi, J, F))
                    : ((J -= m.g2fw2 * m.rad),
                      (F -= m.g2fh2 * m.rad),
                      (r.globalAlpha = a * m.fr),
                      r.drawImage(
                        m.g2fi,
                        0,
                        0,
                        m.g2fw,
                        m.g2fh,
                        J,
                        F,
                        m.g2fw * m.rad,
                        m.g2fh * m.rad
                      ),
                      (r.globalAlpha =
                        a * (0.5 + 0.5 * Math.cos(m.gfr / 13)) * m.fr),
                      r.drawImage(
                        m.g2fi,
                        0,
                        0,
                        m.g2fw,
                        m.g2fh,
                        J,
                        F,
                        m.g2fw * m.rad,
                        m.g2fh * m.rad
                      )));
            }
            r.restore();
          }
          r.save(), (r.globalCompositeOperation = "lighter");
          for (var p = preys.length - 1; p >= 0; p--) {
            const L = preys[p];
            if (((C = L.xx + L.fx), (A = L.yy + L.fy), L.eaten)) {
              var y = L.eaten_by,
                g = Math.pow(L.eaten_fr, 2);
              (C +=
                (y.xx +
                  y.fx +
                  Math.cos(y.ang + y.fa) * (43 - g * 24) * (1 - g) -
                  C) *
                g),
                (A +=
                  (y.yy +
                    y.fy +
                    Math.sin(y.ang + y.fa) * (43 - g * 24) * (1 - g) -
                    A) *
                  g);
            }
            (C -= view_xx),
              (A -= view_yy),
              (h = C * C + A * A),
              (fs = 1 + 0.08 * L.rad),
              (O = C * fs),
              (H = A * fs),
              (l = 0.4 * (1 - h / (176e3 + h))),
              L.rad != 1 && (l *= Math.pow(L.rad, 0.25)),
              (O = O * gsc + mww2),
              (H = H * gsc + mhh2),
              L.rad == 1
                ? O >= -150 &&
                H >= -150 &&
                O <= mwwp150 &&
                H <= mhhp150 &&
                ((O -= L.gfw2),
                  (H -= L.gfh2),
                  (r.globalAlpha = l * L.fr),
                  r.drawImage(L.gfi, O, H),
                  (r.globalAlpha =
                    l * (0.5 + 0.5 * Math.cos(L.gfr / 13)) * L.fr),
                  r.drawImage(L.gfi, O, H))
                : O >= -150 &&
                H >= -150 &&
                O <= mwwp150 &&
                H <= mhhp150 &&
                ((O -= L.gfw2 * L.rad),
                  (H -= L.gfh2 * L.rad),
                  (r.globalAlpha = l * L.fr),
                  r.drawImage(
                    L.gfi,
                    0,
                    0,
                    L.gfw,
                    L.gfh,
                    O,
                    H,
                    L.gfw * L.rad,
                    L.gfh * L.rad
                  ),
                  (r.globalAlpha =
                    l * (0.5 + 0.5 * Math.cos(L.gfr / 13)) * L.fr),
                  r.drawImage(
                    L.gfi,
                    0,
                    0,
                    L.gfw,
                    L.gfh,
                    O,
                    H,
                    L.gfw * L.rad,
                    L.gfh * L.rad
                  )),
              (fs = 1 + 0.32 * L.rad),
              (O = C * fs),
              (H = A * fs),
              (l = 0.35 * (1 - h / (46500 + h))),
              L.rad != 1 && (l *= Math.pow(L.rad, 0.25)),
              (t = L.rad * 2),
              (O = O * gsc + mww2),
              (H = H * gsc + mhh2),
              O >= -150 &&
              H >= -150 &&
              O <= mwwp150 &&
              H <= mhhp150 &&
              ((O -= L.gfw2 * t),
                (H -= L.gfh2 * t),
                (r.globalAlpha = l * L.fr),
                r.drawImage(
                  L.gfi,
                  0,
                  0,
                  L.gfw,
                  L.gfh,
                  O,
                  H,
                  L.gfw * t,
                  L.gfh * t
                ),
                (r.globalAlpha = l * (0.5 + 0.5 * Math.cos(L.gfr / 13)) * L.fr),
                r.drawImage(
                  L.gfi,
                  0,
                  0,
                  L.gfw,
                  L.gfh,
                  O,
                  H,
                  L.gfw * t,
                  L.gfh * t
                ));
          }
          r.restore();
        }
        if (Math.abs(grd - view_dist) < 4e3) {
          for (
            r.save(),
            r.lineWidth = 23 * gsc,
            r.strokeStyle = "#800000",
            r.fillStyle = "#300000",
            r.beginPath(),
            xx = grd + Math.cos(view_ang - 2e3 / grd) * grd * 0.98,
            yy = grd + Math.sin(view_ang - 2e3 / grd) * grd * 0.98,
            r.moveTo(
              mww2 + (xx - view_xx) * gsc,
              mhh2 + (yy - view_yy) * gsc
            ),
            S = -2e3;
            S <= 2e3;
            S += 100
          )
            (xx = grd + Math.cos(view_ang + S / grd) * grd * 0.98),
              (yy = grd + Math.sin(view_ang + S / grd) * grd * 0.98),
              r.lineTo(
                mww2 + (xx - view_xx) * gsc,
                mhh2 + (yy - view_yy) * gsc
              );
          (xx = grd + Math.cos(view_ang + 2e3 / grd) * (grd + 4e3)),
            (yy = grd + Math.sin(view_ang + 2e3 / grd) * (grd + 4e3)),
            r.lineTo(mww2 + (xx - view_xx) * gsc, mhh2 + (yy - view_yy) * gsc),
            (xx = grd + Math.cos(view_ang - 2e3 / grd) * (grd + 4e3)),
            (yy = grd + Math.sin(view_ang - 2e3 / grd) * (grd + 4e3)),
            r.lineTo(mww2 + (xx - view_xx) * gsc, mhh2 + (yy - view_yy) * gsc),
            r.closePath(),
            r.stroke(),
            r.fill(),
            r.restore();
        }
        h2(r), a2(), r.restore();
      }
    },
    h2 = function (r) {
      choosing_skin ||
        Math.abs(flux_grd - view_dist) >= 4e3 ||
        (r.save(),
          (r.lineWidth = 23 * gsc),
          (r.strokeStyle = "#800000"),
          (r.fillStyle = "#300000"),
          (r.globalAlpha = 0.8),
          r.beginPath(),
          r.arc(
            mww2 + (grd - view_xx) * gsc,
            mhh2 + (grd - view_yy) * gsc,
            flux_grd * gsc,
            0,
            2 * Math.PI
          ),
          r.arc(
            mww2 + (grd - view_xx) * gsc,
            mhh2 + (grd - view_yy) * gsc,
            (flux_grd + 4e3) * gsc,
            0,
            2 * Math.PI,
            !0
          ),
          r.closePath(),
          r.fill(),
          r.beginPath(),
          r.arc(
            mww2 + (grd - view_xx) * gsc,
            mhh2 + (grd - view_yy) * gsc,
            flux_grd * gsc,
            0,
            2 * Math.PI
          ),
          r.stroke(),
          r.restore());
    };
  function Tm() {
    (llgmtm = Date.now()),
      (login_iv = setInterval(p2, 25)),
      ggl && (Ca.app.canvas.style.opacity = 0),
      (mc.style.opacity = 0),
      (mc.style.display = "inline"),
      (at.style.opacity =
        ot.style.opacity =
        st.style.opacity =
        lt.style.opacity =
        yt.style.opacity =
        wt.style.opacity =
        0),
      (loch.style.opacity = 0),
      (lb_fr = -1);
  }
  function Cm(r, e, t, a, l, o, h, c) {
    var u = {};
    (u.id = r),
      (u.xx = e),
      (u.yy = t),
      Ii(u, a, c),
      (a = u.cv),
      (u.fnfr = 0),
      (u.na = 1),
      (u.chl = 0),
      (u.tsp = 0),
      (u.sfr = 0),
      (u.gptz = []),
      (u.accessory = -1),
      (u.rr = Math.min(255, At[a] + Math.floor(Math.random() * 20))),
      (u.gg = Math.min(255, Wt[a] + Math.floor(Math.random() * 20))),
      (u.bb = Math.min(255, Vt[a] + Math.floor(Math.random() * 20)));
    var d = "00" + Math.min(255, Math.max(0, Math.round(u.rr))).toString(16),
      f = "00" + Math.min(255, Math.max(0, Math.round(u.gg))).toString(16),
      p = "00" + Math.min(255, Math.max(0, Math.round(u.bb))).toString(16);
    (d = d.substr(d.length - 2)),
      (f = f.substr(f.length - 2)),
      (p = p.substr(p.length - 2)),
      (u.cs = "#" + d + f + p);
    var g = 0.4;
    (d = "00" + Math.min(255, Math.max(0, Math.round(u.rr * g))).toString(16)),
      (f =
        "00" + Math.min(255, Math.max(0, Math.round(u.gg * g))).toString(16)),
      (p =
        "00" + Math.min(255, Math.max(0, Math.round(u.bb * g))).toString(16)),
      (d = d.substr(d.length - 2)),
      (f = f.substr(f.length - 2)),
      (p = p.substr(p.length - 2)),
      (u.cs04 = "#" + d + f + p);
    var g = 1.5;
    return (
      (d =
        "00" +
        Math.min(255, Math.max(0, Math.round((255 + u.rr) * 0.5))).toString(
          16
        )),
      (f =
        "00" +
        Math.min(255, Math.max(0, Math.round((255 + u.gg) * 0.5))).toString(
          16
        )),
      (p =
        "00" +
        Math.min(255, Math.max(0, Math.round((255 + u.bb) * 0.5))).toString(
          16
        )),
      (d = d.substr(d.length - 2)),
      (f = f.substr(f.length - 2)),
      (p = p.substr(p.length - 2)),
      (u.csw = "#" + d + f + p),
      (u.sc = 1),
      (u.ssp = G.nsp1 + G.nsp2 * u.sc),
      (u.fsp = u.ssp + 0.1),
      (u.msp = G.nsp3),
      (u.fxs = new Float32Array(is)),
      (u.fys = new Float32Array(is)),
      (u.fchls = new Float32Array(is)),
      (u.fpos = 0),
      (u.ftg = 0),
      (u.fx = 0),
      (u.fy = 0),
      (u.fchl = 0),
      (u.fas = new Float32Array(er)),
      (u.fapos = 0),
      (u.fatg = 0),
      (u.fa = 0),
      (u.ehang = l),
      (u.wehang = l),
      (u.ehl = 1),
      (u.msl = h),
      (u.fam = 0),
      (u.rsc = 0),
      (u.ang = l),
      (u.eang = l),
      (u.wang = l),
      (u.rex = 0),
      (u.rey = 0),
      (u.sp = 2),
      o
        ? ((u.pts = o), (u.sct = o.length), o[0].dying && u.sct--)
        : ((u.pts = []), (u.sct = 0)),
      (u.flpos = 0),
      (u.fls = new Float32Array(tr)),
      (u.fl = 0),
      (u.fltg = 0),
      (u.tl = u.sct + u.fam),
      (u.cfl = u.tl - 0.5),
      (u.scang = 1),
      (u.dead_amt = 0),
      (u.alive_amt = 0),
      slithers.splice(0, 0, u),
      (os["s" + u.id] = u),
      u
    );
  }
  function Ta(r) {
    var e = r.tl;
    r.tl = r.sct + r.fam;
    for (var t = r.tl - e, a = r.flpos, l = 0; l < tr; l++)
      (r.fls[a] -= t * G.lfas[l]), a++, a >= tr && (a = 0);
    (r.fl = r.fls[r.flpos]), (r.fltg = tr), r == slither && (wumsts = !0);
  }
  function gn() {
    (Xt.style.left = Math.round(ww / 2 - Xt.offsetWidth / 2) + "px"),
      building_skin
        ? (Xt.style.top = Math.round(hh / 2 + 120 + 94 * skoboym) + "px")
        : selecting_cosmetic
          ? (Xt.style.top = Math.round(hh / 2 + 120 + 94 * secosoym) + "px")
          : (Xt.style.top = Math.round(hh / 2 + 120) + "px"),
      (Dt.style.left =
        Math.round(ww / 2 - Dt.offsetWidth / 2 - Xt.offsetWidth - 62) + "px"),
      (Dt.style.top = Math.round(hh / 2 + 120 + 94 * skoboym) + "px");
  }
  csk.onclick = function () {
    if (!playing && dead_mtm == -1) {
      G.resetGame(),
        (G.cst = 0),
        G.recalcSepMults(),
        (choosing_skin = !0),
        (pskh.style.opacity = 0),
        (nskh.style.opacity = 0),
        (bskh.style.opacity = 0),
        (scosh.style.opacity = 0),
        (Xt.style.opacity = 0),
        (Dt.style.opacity = 0),
        (pskh.style.display = "inline"),
        (nskh.style.display = "inline"),
        (bskh.style.display = "inline"),
        hacos && (scosh.style.display = "inline"),
        (Xt.style.display = "inline"),
        (Dt.style.display = "none"),
        gn(),
        (nick.disabled = !0),
        G.mscps == 0 && G.setMscps(300);
      for (var r = [], e = 27; e >= 1; e--) {
        var t = grd / 2 - e * 10,
          a = grd / 2,
          l = { xx: t, yy: a, fx: 0, fy: 0, fltn: 0, da: 0, ltn: 1 };
        (l.fxs = new Float32Array(nt)),
          (l.fys = new Float32Array(nt)),
          (l.fltns = new Float32Array(nt)),
          (l.fsmus = new Float32Array(nt)),
          (l.fpos = 0),
          (l.ftg = 0),
          (l.smu = 1),
          (l.fsmu = 0),
          (l.ebx = 10),
          (l.eby = 0),
          r.push(l);
      }
      var o = 0;
      try {
        var h = localStorage.snakercv;
        h == "" + Number(h) && (o = Number(h));
      } catch { }
      var c = null,
        u = !1,
        d = "";
      try {
        (u = localStorage.want_custom_skin == "1"),
          (d = localStorage.custom_skin);
      } catch { }
      if (u && d && d.length > 0) {
        (d = ("" + d).split(",")), (c = new Uint8Array(d.length));
        for (var e = 0; e < d.length; e++) c[e] = Number(d[e]);
      }
      var f = Cm(1, grd / 2, grd / 2, o, 0, r, G.default_msl, c);
      (view_xx = grd / 2 - (22 / 2 - 0.5) * 10),
        (view_yy = grd / 2),
        (slither = f);
      try {
        var p = localStorage.cosmetic;
        p == "" + Number(p) && (slither.accessory = Number(p));
      } catch { }
      (f.nk = ""),
        (f.ip = ""),
        (f.onk = ""),
        (f.eang = f.wang = f.ang),
        (f.sp = 4.8),
        (f.spang = f.sp / G.spangdv),
        f.spang > 1 && (f.spang = 1),
        (f.sc = 1),
        (f.scang = 1),
        (f.ssp = G.nsp1 + G.nsp2 * f.sc),
        (f.fsp = f.ssp + 0.1),
        (f.wsep = 6 * f.sc);
      var g = nsep / gsc;
      f.wsep < g && (f.wsep = g),
        (f.sep = f.wsep),
        (f.sep = f.wsep = 18.25),
        Ta(f),
        (f.alive_amt = 1),
        (f.rex = 1.66),
        (ws = {}),
        (ws.send = function (_) { }),
        (ws.close = function () { }),
        (connected = !0),
        (playing = !0),
        (window._uiHidden = false),
        (window._uiMul = 1),
        (high_quality = G.want_quality != 0),
        (gla = G.want_quality != 0 ? 1 : 0),
        (wdfg = 0),
        (qsm = G.want_quality != 0 ? 1 : 1.7),
        Tm(),
        (at.style.display = "none"),
        (ot.style.display = "none"),
        (st.style.display = "none"),
        (lt.style.display = "none"),
        (yt.style.display = "none"),
        (wt.style.display = "none"),
        (loch.style.display = "none");
    }
    return !1;
  };
  class c2 {
    constructor() {
      (this.etcobs = []),
        (this.entering_code = !1),
        (this.ending_enter_code = !1),
        (this.etc_ww = 705),
        (this.etc_hh = 67),
        (this.etcbx = 0),
        (this.etcdx = this.etc_ww / 2 - 54 / 2),
        (this.etcods = []),
        (this.ever_showed_entercode = !1),
        (this.checking_code = !1),
        (this.want_open_cosmetics = !1),
        (this.etca = 0),
        (this.etcba = 0),
        (this.etcbaa = 1),
        (this.etcsv = 0),
        (this.etcsrv = 0),
        (this.etcsa = 0),
        (this.etcshk = !1),
        (this.etcshkv = 0),
        this.init();
    }
    init() {
      (this.etco = document.getElementById("etco")),
        (this.etco.onclick = () => {
          if (
            (this.etco_sp_ii ||
              ((this.etco_sp_ii = document.createElement("img")),
                (this.etco_sp_ii.width = 100),
                (this.etco_sp_ii.height = 100)),
              !playing && dead_mtm == -1)
          ) {
            if (
              (G.resetGame(),
                (this.entering_code = !0),
                (this.ending_enter_code = !1),
                !this.ever_showed_entercode)
            ) {
              this.ever_showed_entercode = !0;
              for (var c = this.etcobs.length - 1; c >= 0; c--)
                c == 10
                  ? (this.etcobs[c].ii.src = "http://slither.io/s/codedel.png")
                  : (this.etcobs[c].ii.src =
                    "http://slither.io/s/code" + c + ".png");
              this.etco_sp_ii.src = "http://slither.io/s/spinner.png";
              for (var c = 0; c <= 11; c++) {
                var u = document.createElement("img");
                (u.width = 54), (u.height = 67);
                var d = c;
                c == 10 ? (d = "h") : c == 11 && (d = "b"),
                  (u.onload = function () {
                    for (var g = this.etcdis.length - 1; g >= 0; g--) {
                      var _ = this.etcdis[g];
                      _.ii == this && (_.loaded = !0);
                    }
                  });
                var f = {};
                (f.ii = u),
                  (f.loaded = !1),
                  this.etcdis.push(f),
                  (u.src = "http://slither.io/s/cd" + d + ".png");
              }
            }
            (this.etcod.style.display = "inline"),
              this.reposEnterCode(),
              (nick.disabled = !0);
          }
          return !1;
        }),
        (this.etcod = document.getElementById("etcod")),
        (this.etcot = document.createElement("div")),
        this.etcod.appendChild(this.etcot);
      var e = this.etcot;
      (e.style.position = "absolute"),
        (e.style.width = "800px"),
        (e.style.height = "32px"),
        (e.style.textAlign = "center"),
        (e.style.color = "#fff"),
        (e.style.fontWeight = "bold"),
        (e.style.textAlign = "center"),
        (e.style.fontFamily = 'Arial, "Helvetica Neue", Helvetica, sans-serif'),
        (e.style.fontSize = "18px"),
        (e.textContent = "if you have a code, enter it here!"),
        (e.className = "nsi");
      for (var t = 0; t <= 10; t++) {
        var a = document.createElement("a");
        (a.draggable = !1), (a.href = "#"), (a.className = "btn btnt");
        var l = document.createElement("img");
        (l.width = 135),
          (l.height = 135),
          (l.className = "nsi"),
          (l.style.position = "absolute"),
          (l.draggable = !1),
          (l.style.opacity = 0),
          etcod.appendChild(a),
          a.appendChild(l),
          (a.onclick = function () {
            for (var u, d = this.etcobs.length - 1; d >= 0; d--)
              if (this.etcobs[d].a == this) {
                (u = this.etcobs[d]),
                  u.v == 10
                    ? this.deleteLastCodeDigit()
                    : this.enterCodeDigit(u.v);
                break;
              }
            return !1;
          }),
          (l.onload = function () {
            for (var u, d = this.etcobs.length - 1; d >= 0; d--)
              if (this.etcobs[d].ii == this) {
                (u = this.etcobs[d]), (u.loaded = !0);
                break;
              }
          });
        var h = {};
        (h.ii = l), (h.a = a), (h.alpha = 0), (h.v = t), this.etcobs.push(h);
      }
      var o = "Cancel";
      var h = sl("" + o + "", 47, 20, 34, 1);
      (this.cancel_code_btn = h),
        (this.etcocdiv = h.elem),
        (this.etcocdiv.style.zIndex = 53),
        (this.etcocdiv.style.position = "fixed"),
        (this.etcocdiv.onclick = function () {
          this.entering_code &&
            (checking_code || (stchco(), (ending_enter_code = !0)));
        }),
        this.etcod.appendChild(this.etcocdiv),
        (this.etco_sp_ii = document.createElement("img")),
        (this.etco_sp_ii.width = 100),
        (this.etco_sp_ii.height = 100),
        (this.etco_sp_ii.className = "nsi"),
        (this.etco_sp_ii.style.position = "absolute"),
        (this.etco_sp_ii.draggable = !1),
        (this.etco_sp_ii.style.opacity = 0),
        this.etcod.appendChild(this.etco_sp_ii),
        (this.etcdis = []),
        (this.etcc = document.createElement("canvas")),
        (this.etcc.style.position = "absolute"),
        (this.etcc.width = this.etc_ww),
        (this.etcc.height = this.etc_hh),
        this.etcod.appendChild(this.etcc);
    }
    enterCodeDigit(e) {
      if (
        this.entering_code &&
        !this.checking_code &&
        this.etcods.length < 14
      ) {
        var t = {};
        if (
          ((t.v = e),
            this.etcods.push(t),
            this.etcods.length == 4 || this.etcods.length == 9)
        ) {
          var t = {};
          (t.v = 10), this.etcods.push(t);
        }
        if (this.etcods.length == 14) {
          (want_play = !0), (this.checking_code = !0);
          for (var a = this.etcobs.length - 1; a >= 0; a--)
            this.etcobs[a].a.className = "btn_disabled btnt";
          this.cancel_code_btn.setEnabled(!1);
        }
      }
    }
    deleteLastCodeDigit() {
      this.entering_code &&
        (this.checking_code ||
          (this.etcods.length > 0 &&
            (this.etcods[this.etcods.length - 1].v == 10 &&
              this.etcods.splice(this.etcods.length - 1, 1),
              this.etcods.length > 0 &&
              this.etcods.splice(this.etcods.length - 1, 1))));
    }
    reposEnterCode() {
      var d = hh / 1500;
      d > 1 && (d = 1),
        (this.etcod.style.width = Math.ceil(ww) + "px"),
        (this.etcod.style.height = Math.ceil(hh) + "px");
      var e = Math.round(Math.max(42, (hh - 222) * 0.2)),
        t = Math.round(
          Math.max(
            60,
            0.5 * e + 0.5 * (hh / 2 + 100 * d - 135 / 2 + -1 * d * 155) - 33
          )
        ),
        a = Math.round(
          t * 0.45 + 0.55 * (hh / 2 + 100 * d - 135 / 2 + -1 * d * 155) - 33
        );
      (this.etcot.style.left = Math.round(ww / 2 - 800 / 2) + "px"),
        (this.etcot.style.top = e + "px"),
        (this.etcc.style.left = Math.round(ww / 2 - this.etc_ww / 2) + "px"),
        (this.etcc.style.top = t + "px"),
        (this.etco_sp_ii.style.left = Math.round(ww / 2 - 100 / 2) + "px"),
        (this.etco_sp_ii.style.top = a + "px"),
        this.adjustCodeSpinner();
      for (var l = this.etcobs.length - 1; l >= 0; l--) {
        var o = this.etcobs[l],
          h = 0,
          c = 0,
          u = d;
        l == 0
          ? ((h = 0), (c = 2))
          : l == 1
            ? ((h = -1), (c = -1))
            : l == 2
              ? ((h = 0), (c = -1))
              : l == 3
                ? ((h = 1), (c = -1))
                : l == 4
                  ? ((h = -1), (c = 0))
                  : l == 5
                    ? ((h = 0), (c = 0))
                    : l == 6
                      ? ((h = 1), (c = 0))
                      : l == 7
                        ? ((h = -1), (c = 1))
                        : l == 8
                          ? ((h = 0), (c = 1))
                          : l == 9
                            ? ((h = 1), (c = 1))
                            : l == 10 && ((h = 1), (c = 2), (u *= 0.75)),
          (o.ii.style.left = Math.round(ww / 2 - 135 / 2 + h * d * 155) + "px"),
          (o.ii.style.top =
            Math.round(hh / 2 + 100 * d - 135 / 2 + c * d * 155) + "px"),
          trf(o.ii, "scale(" + u + "," + u + ")");
      }
      var d = hh / 750;
      d > 1 && (d = 1),
        trf(this.etcc, "scale(" + d + "," + d + ")"),
        (this.etcocdiv.style.left =
          Math.round(ww / 2 - this.etcocdiv.offsetWidth / 2) + "px"),
        (this.etcocdiv.style.bottom = Math.round(d * 64) + "px");
    }
    stchco() {
      checking_code = !1;
      for (var e = St.etcobs.length - 1; e >= 0; e--)
        St.etcobs[e].a.className = "btn btnt";
      this.cancel_code_btn.setEnabled(!0), G.resetGame();
    }
    adjustCodeSpinner() {
      var e = hh / 1500;
      e > 1 && (e = 1),
        trf(
          this.etco_sp_ii,
          "scale(" +
          e +
          "," +
          e +
          ") rotate(" +
          Math.round((36e3 * this.etcsrv) / 12) / 100 +
          "deg)"
        );
    }
    update() {
      if (this.entering_code || this.ending_enter_code) {
        for (var e = this.etcobs.length - 1; e >= 0; e--) {
          var t = this.etcobs[e];
          t.loaded &&
            (this.checking_code
              ? t.alpha != 0.25 &&
              ((t.alpha -= vfr * 0.02),
                t.alpha <= 0.25 && (t.alpha = 0.25),
                (t.ii.style.opacity = t.alpha))
              : t.alpha != 1 &&
              ((t.alpha += vfr * 0.02),
                t.alpha >= 1 && (t.alpha = 1),
                (t.ii.style.opacity = t.alpha)));
        }
        if (
          (this.ending_enter_code
            ? ((this.etca -= vfr * 0.03),
              this.etca <= 0 &&
              ((this.etca = 0),
                (this.etcbx = 0),
                (this.etcdx = etc_ww / 2 - 54 / 2),
                (this.etcods = []),
                (this.ending_enter_code = !1),
                (this.entering_code = !1),
                (this.etcod.style.display = "none"),
                (nick.disabled = !1),
                nick.focus(),
                this.want_open_cosmetics &&
                ((this.want_open_cosmetics = !1),
                  csk.onclick(),
                  scos.onclick())),
              (this.etcod.style.opacity = this.etca))
            : this.entering_code &&
            this.etca != 1 &&
            ((this.etca += vfr * 0.03),
              this.etca >= 1 && (this.etca = 1),
              (this.etcod.style.opacity = this.etca)),
            (this.etcba += vfr * 0.1),
            this.etcba >= pi2 && (this.etcba -= pi2),
            this.etcshk &&
            ((this.etcshkv += vfr * 0.014),
              this.etcshkv >= 1 && ((this.etcshkv = 1), (this.etcshk = !1)),
              (this.etcc.style.left =
                Math.round(
                  (Math.sin(Math.PI * this.etcshkv * 8) *
                    32 *
                    Math.sin(Math.PI * this.etcshkv) +
                    ww / 2 -
                    this.etc_ww / 2) *
                  10
                ) /
                10 +
                "px")),
            this.checking_code || this.etcsa > 0)
        ) {
          (this.etcsv += vfr * 0.0075),
            this.etcsv >= 1 && (this.etcsv -= 1),
            this.checking_code
              ? ((this.etcsa += vfr * 0.02),
                this.etcsa >= 1 && (this.etcsa = 1))
              : ((this.etcsa -= vfr * 0.05),
                this.etcsa <= 0 && (this.etcsa = 0)),
            (this.etco_sp_ii.style.opacity = this.etcsa);
          var a = this.etcsrv;
          (this.etcsrv = Math.round(this.etcsv * 12)),
            this.etcsrv != a && this.adjustCodeSpinner();
        }
        this.etcods.length == 14
          ? this.etcbaa != 0 &&
          ((this.etcbaa -= vfr * 0.05), this.etcbaa <= 0 && (this.etcbaa = 0))
          : this.etcbaa != 1 &&
          ((this.etcbaa += vfr * 0.05),
            this.etcbaa >= 1 && (this.etcbaa = 1));
        var l = this.etcc.getContext("2d");
        l.save(), l.clearRect(0, 0, this.etc_ww, this.etc_hh);
        var o = Math.min(13, this.etcods.length);
        (this.etcbx += (o * 47 - this.etcbx) * 0.2),
          (this.etcdx +=
            (this.etc_ww / 2 - 54 / 2 - (47 * o) / 2 - this.etcdx) * 0.1),
          (l.globalAlpha = 1),
          l.translate(this.etcdx, 0);
        for (var e = 0; e < this.etcods.length; e++) {
          var h = this.etcods[e].v;
          this.etcdis[h].loaded &&
            l.drawImage(this.etcdis[h].ii, e * 47, 0, 54, 67);
        }
        this.etcdis[11].loaded &&
          ((l.globalAlpha = etcbaa * (0.5 + 0.4 * Math.cos(etcba))),
            l.drawImage(this.etcdis[11].ii, this.etcbx, 0, 54, 67)),
          l.restore();
      }
    }
  }
  const St = new c2(),
    Jt = { spinner_shown: !1, ss_a: 0, ss_sh: 0 },
    es = document.createElement("canvas");
  (es.width = 128),
    (es.height = 128),
    (es.style.position = "fixed"),
    (es.style.left = "0px"),
    (es.style.top = "0px"),
    (es.style.zIndex = 8388607),
    (es.style.display = "none"),
    document.body.appendChild(es);
  class f2 {
    constructor() {
      (this.app = null), (this.root = null);
    }
    async initialize() {
      ggl && (await this.initializePixi()),
        this.resize(),
        window.addEventListener("resize", () => this.resize());
    }
    async initializePixi() {
      const e = new ju();
      (this.app = e),
        await e.init({
          background: "#202020",
          resizeTo: window,
          antialias: !0,
        });
      for (var t = 8, a, l = 0; l < texture_sheets.length; l++) {
        var o = texture_sheets[l],
          h = o.cc,
          c = h.getContext("2d");
        a = new RectanglePacker(o.width, o.height, t);
        for (var u = [], d = textures.length - 1; d >= 0; d--) {
          var f = textures[d];
          f.sheet == l && u.push(f);
        }
        for (var d = u.length - 1; d >= 0; d--) {
          var f = u[d];
          a.insertRectangle(f.cc.width, f.cc.height, d);
        }
        a.packRectangles(!0);
        for (var p, d = u.length - 1; d >= 0; d--) {
          var g = a.getRectangleId(d);
          if (g == -1);
          else {
            p = a.getRectangle(d, null);
            var f = u[g];
            (f.r = p), c.drawImage(f.cc, p.x, p.y);
          }
        }
        o.t = te.from(o.cc);
        for (var d = u.length - 1; d >= 0; d--) {
          var f = u[d];
          p = f.r;
          var _ = new Le(p.x, p.y, p.width, p.height);
          f.t = new te({ source: o.t.source, frame: _ });
        }
      }
      document.body.appendChild(e.canvas),
        (e.canvas.style.position = "fixed"),
        (e.canvas.style.left = "0px"),
        (e.canvas.style.top = "0px"),
        (e.canvas.style.opacity = 0);
      var m;
      try {
        var w = "http://slither.io/s2/";
        m = await Ur.load(w + "bg54.jpg");
      } catch { }
      (bgee = new uv({
        texture: m,
        width: e.screen.width,
        height: e.screen.height,
      })),
        bgee.anchor.set(0.5, 0.5),
        (this.root = new Ne()),
        e.stage.addChild(this.root),
        this.root.addChild(bgee),
        (fdlo = new Ne()),
        this.root.addChild(fdlo),
        (fdglo = new Ne()),
        (fdglo.blendMode = "add"),
        this.root.addChild(fdglo),
        (nmlo = new Ne()),
        this.root.addChild(nmlo),
        (prlo = new Ne()),
        (prlo.blendMode = "add"),
        this.root.addChild(prlo),
        (suglo = new Ne()),
        (suglo.blendMode = "add"),
        this.root.addChild(suglo),
        (shilo = new Ne()),
        this.root.addChild(shilo),
        (slilo = new Ne()),
        this.root.addChild(slilo),
        (sfilo = new Ne()),
        (sfilo.blendMode = "add"),
        this.root.addChild(sfilo),
        (sdilo = new Ne()),
        (sdilo.blendMode = "add"),
        this.root.addChild(sdilo),
        (g2lo = new Ne()),
        (g2lo.blendMode = "add"),
        this.root.addChild(g2lo),
        (prglo = new Ne()),
        (prglo.blendMode = "add"),
        this.root.addChild(prglo),
        e.ticker.add((x) => { }),
        dg("Initialized");
    }
    resize() {
      if (
        ((ww = Math.ceil(window.innerWidth)),
          (hh = Math.ceil(window.innerHeight)),
          ww != lww || hh != lhh)
      ) {
        (lww = ww),
          (lhh = hh),
          (Bs.style.width = ww + "px"),
          (Bs.style.height = hh + "px"),
          (Ze.style.left = Math.round(ww / 2 - Se.svlww / 2) + "px"),
          (Ze.style.top = Math.round(hh / 2 - Se.svlhh / 2) + "px"),
          ggl && this.app.renderer && this.app.renderer.resize(ww, hh);
        var e = 0;
        St.reposEnterCode(),
          (loch.style.bottom = 16 + e + "px"),
          (yt.style.bottom = 4 + e + "px"),
          (at.style.right = "4px"),
          (ot.style.right = "4px"),
          (st.style.right = "64px"),
          (lt.style.right = hl + 64 + 16 + "px"),
          (loch.style.right = "16px"),
          (plq.style.right = "10px"),
          (clq.style.left = Math.floor(ww / 2 - 130) + "px"),
          (login.style.width = ww + "px"),
          (grqh.style.right = "20px"),
          (etcoh.style.right = "20px"),
          (csrvh.style.right = "20px"),
          $c(),
          (pskh.style.left = Math.round(ww * 0.25 - 44) + "px"),
          (nskh.style.left = Math.round(ww * 0.75 - 44) + "px"),
          gn(),
          (pskh.style.top = Math.round(hh / 2 - 44) + "px"),
          (nskh.style.top = Math.round(hh / 2 - 44) + "px"),
          (es.style.left = ww / 2 - 64 + "px"),
          (es.style.top = hh / 2 - 64 + "px"),
          gm(),
          al();
        var t = 1800,
          a = Math.sqrt(ww * ww + hh * hh),
          l = Math.ceil((ww * t) / a),
          o = Math.ceil((hh * t) / a);
        l > 1500 && ((o = Math.ceil((o * 1500) / l)), (l = 1500)),
          o > 1500 && ((l = Math.ceil((l * 1500) / o)), (o = 1500)),
          hh < 560 ? (lgbsc = Math.max(50, hh) / 560) : (lgbsc = 1);
        var h = Math.round(lgbsc * lgcsc * 1e5) / 1e5;
        if (h == 1) trf(login, ""), (login.style.top = "0px");
        else {
          var c = Math.round(hh * (1 - lgbsc) * 1e5) / 1e5;
          (login.style.top = -c + "px"),
            trf(login, "scale(" + h + "," + h + ")");
        }
        (mww != l || mhh != o) &&
          ((mww = l),
            (mhh = o),
            (mc.width = mww),
            (mc.height = mhh),
            (mwwp50 = mww + 50),
            (mhhp50 = mhh + 50),
            (mwwp150 = mww + 150),
            (mhhp150 = mhh + 150),
            (mww2 = mww / 2),
            (mhh2 = mhh / 2),
            rm()),
          (csc = Math.min(ww / mww, hh / mhh)),
          trf(mc, "scale(" + csc + "," + csc + ")"),
          (mc.style.left = Math.floor(ww / 2 - mww / 2) + "px"),
          (mc.style.top = Math.floor(hh / 2 - mhh / 2) + "px");
      }
      ggl &&
        (this.root &&
          ((this.root.scale.x = csc),
            (this.root.scale.y = csc),
            (this.root.x = ww / 2),
            (this.root.y = hh / 2)),
          bgee && ((bgee.width = 8 + ww / csc), (bgee.height = 8 + hh / csc))),
        Mm();
    }
  }
  const Ca = new f2();
  Ca.initialize();
  const Xs = { tip_pos: -1, tip_fr: 1.9 };
  function p2() {
    const r = Date.now(),
      e = (r - llgmtm) / 25;
    if (
      ((llgmtm = r),
        (login_fr += 0.0625 * e),
        choosing_skin && (login_fr += 0.06 * e),
        login_fr >= 1)
    )
      (login_fr = 1),
        (login.style.display = "none"),
        (cskh.style.display = "none"),
        (csrvh.style.display = "none"),
        (etcoh.style.display = "none"),
        (grqh.style.display = "none"),
        (plq.style.display = "none"),
        (clq.style.display = "none"),
        (login.style.opacity = 1),
        (cskh.style.opacity = 1),
        (csrvh.style.opacity = 1),
        (etcoh.style.opacity = 1),
        (grqh.style.opacity = 1),
        (plq.style.opacity = 1),
        (clq.style.opacity = 1),
        (pskh.style.opacity = 1),
        (nskh.style.opacity = 1),
        (bskh.style.opacity = 1),
        (scosh.style.opacity = 1),
        (Xt.style.opacity = 1),
        (Dt.style.opacity = 1),
        (Xs.tip_fr = -1),
        (Zc.style.display = "none"),
        ggl && (Ca.app.canvas.style.opacity = 1),
        (mc.style.opacity = 1),
        (loch.style.opacity = mmal * (window._uiMul ?? 1)),
        clearInterval(login_iv),
        (login_iv = -1),
        Ve.showlogo_iv != -1 &&
        ((Xs.lga = 1), (Xs.lgss = 1), (Xs.ncka = 1), Wc(!0));
    else {
      lgcsc = 1 + 0.1 * Math.pow(login_fr, 2);
      const t = Math.round(lgbsc * lgcsc * 1e5) / 1e5;
      trf(login, "scale(" + t + "," + t + ")"),
        (login.style.opacity = 1 - login_fr),
        (cskh.style.opacity = 1 - login_fr),
        (csrvh.style.opacity = 1 - login_fr),
        (etcoh.style.opacity = 1 - login_fr),
        (grqh.style.opacity = 1 - login_fr),
        (plq.style.opacity = 1 - login_fr),
        (clq.style.opacity = 1 - login_fr),
        (pskh.style.opacity = login_fr),
        (nskh.style.opacity = login_fr),
        (bskh.style.opacity = login_fr),
        (scosh.style.opacity = login_fr),
        (Xt.style.opacity = login_fr),
        (Dt.style.opacity = login_fr),
        ggl && (Ca.app.canvas.style.opacity = login_fr),
        (mc.style.opacity = login_fr),
        (loch.style.opacity = login_fr * mmal * (window._uiMul ?? 1));
    }
  }
  let ul = "Play";
  const Kc = sl("" + ul + "", 47, 20, 34, 1),
    _n = Kc,
    yn = Kc.elem;
  (yn.style.position = "relative"),
    (yn.style.display = "inline-block"),
    (yn.style.marginTop = "20px"),
    (yn.style.marginBottom = "50px");
  const Pm = document.getElementById("playh");
  (Pm.style.opacity = 0), Pm.appendChild(yn);
  const Zc = document.getElementById("tips");
  let Aa = [
    "Use the TAB key to hide the UI elements!",
    "Eat to grow longer!",
    "Don't run into other players!",
    "When longer, hold the mouse for a speed boost!",
  ];
  (Kc.elem.onclick = function () {
    want_play ||
      _n.disabled ||
      St.entering_code ||
      ((want_play = !0),
        (play_btn_click_mtm = Date.now()),
        _n.setEnabled(!1),
        (nick.disabled = !0),
        (Jt.spinner_shown = !0),
        (es.style.display = "inline"),
        play_count++);
  });
  function g2(r) {
    if (login_fr != 1 && Xs.tip_fr != -1) {
      (Xs.tip_fr += r * 0.017),
        Xs.tip_fr >= pi2 &&
        ((Xs.tip_fr -= pi2),
          Xs.tip_pos++,
          Xs.tip_pos >= Aa.length && (Xs.tip_pos = 0),
          (Zc.textContent = Aa[Xs.tip_pos]));
      const e = 0.5 - 0.5 * Math.cos(Xs.tip_fr);
      Zc.style.opacity = Math.round(Math.pow(e, 0.5) * 1e5) / 1e5;
    }
  }
  function fl(r, e) {
    var t = r / 2;
    if (t != mmrad || e) {
      (mmrad = t), (mmsz = r), (mmdata = new Uint8Array(r * r));
      for (var a = mmsz * mmsz - 1; a >= 0; a--) mmdata[a] = 0;
      (loch.style.width = loch.style.height = t * 2 + 24 + "px"),
        (sid_tf.style.width = t * 2 + 24 + "px"),
        (sid_tf.style.top = t * 2 + 24 - 7 + "px"),
        real_sid > 0
          ? (sid_tf.textContent = "server " + real_sid + (window.fe_ping > 0 ? " (" + window.fe_ping + "ms)" : ""))
          : (sid_tf.textContent = "");
      var l = 12 + t,
        o = 12 + t;
      const c = document.createElement("canvas");
      c.width = c.height = t * 2 + 24;
      var h = c.getContext("2d");
      h.save(),
        (h.fillStyle = "#202630"),
        (h.shadowBlur = 12),
        (h.shadowOffsetY = 3),
        (h.shadowColor = "#000000"),
        h.beginPath(),
        h.arc(l, o, t, 0, pi2),
        h.fill(),
        h.restore(),
        (h.fillStyle = "#404650"),
        h.beginPath(),
        h.moveTo(t + 12, t + 12),
        h.arc(l, o, t, 0, Math.PI / 2),
        h.lineTo(l, o),
        h.fill(),
        h.beginPath(),
        h.moveTo(l, o),
        h.arc(l, o, t, Math.PI, (3 * Math.PI) / 2),
        h.lineTo(l, o),
        h.fill(),
        (h.strokeStyle = "#202630"),
        (h.lineWidth = 1),
        h.beginPath(),
        h.moveTo(l, o - t),
        h.lineTo(l, o + t),
        h.stroke(),
        h.beginPath(),
        h.moveTo(l - t, o),
        h.lineTo(l + t, o),
        h.stroke(),
        (loc.src = c.toDataURL()),
        (loc.className = "nsi"),
        (loc.style.position = "absolute"),
        (loc.style.left = "0px"),
        (loc.style.top = "0px"),
        (loc.style.opacity = 0.45),
        (loc.style.zIndex = 11),
        trf(loc, agpu),
        (asmc.width = t * 2),
        (asmc.height = t * 2),
        (asmc.className = "nsi"),
        (asmc.style.position = "absolute"),
        (asmc.style.left = asmc.style.top = "12px"),
        (asmc.style.zIndex = 12),
        (asmc.style.opacity = mmsta),
        (asmc2.width = t * 2),
        (asmc2.height = t * 2),
        (asmc2.className = "nsi"),
        (asmc2.style.position = "absolute"),
        (asmc2.style.left = asmc2.style.top = "12px"),
        (asmc2.style.zIndex = 13),
        (asmc2.style.opacity = mmsta);
    }
  }
  const pl = [64, 32, 16, 8, 4, 2, 1];
  function Qc() {
    if (waiting_for_sos)
      if (sos_ready_after_mtm >= 0 && Date.now() > sos_ready_after_mtm)
        waiting_for_sos = !1;
      else if (sos_loaded_at_mtm >= 0 && Date.now() - sos_loaded_at_mtm > 7e3)
        waiting_for_sos = !1;
      else return;
    if (
      (G.resetGame(),
        (want_play = !1),
        (connecting = !0),
        (start_connect_mtm = Date.now()),
        (fbso = null),
        !forcing)
    ) {
      cm();
      if (fbso != null) {
        bso = fbso;
      } else {
        var firstValid = sos.find(function(s) { return !s.tainted; }) || sos[0];
        bso = sos.reduce(function(best, s) {
          return !s.tainted && s.ptm < best.ptm ? s : best;
        }, firstValid);
      }
    }
    forcing && fobso != null && (bso = fobso);
    (ws = new WebSocket("ws://" + bso.ip + ":" + bso.po + "/slither")),
      (ws.binaryType = "arraybuffer"),
      (window.ws = ws),
      (ws.onmessage = function (t) {
        if (ws == this) {
          var a = new Uint8Array(t.data);
          if (((rdps += a.length), apkps++, want_seq)) {
            var l = (a[0] << 8) | a[1];
            l - 1 != lseq &&
              l != 0 &&
              testing &&
              console.log("sequence error! " + l + " != " + lseq),
              (lseq = l);
          } else
            want_etm_s &&
              ((lptm = cptm), (cptm = Date.now()), (a[0] << 8) | a[1]);
          var o, h;
          if ((want_etm_s ? (o = 2) : (o = 0), a[o] < 32))
            for (var c = a.length; o < c;) {
              a[o] < 32
                ? ((h = (a[o] << 8) | a[o + 1]), (o += 2))
                : ((h = a[o] - 32), o++);
              var u = a.subarray(o, o + h);
              (o += h), gotPacket(u);
            }
          else {
            var u = a.subarray(o, a.length);
            gotPacket(u);
          }
        }
      }),
      (window.gotPacket = function (t) {
        pkps++, testing && (pkpspc[t[0]]++, (rdpspc[t[0]] += t.length));
        var a, l, o, h, c, u;
        if (
          ((l = t[0]),
            (a = String.fromCharCode(l)),
            (h = t.length),
            (c = t.length),
            (u = t.length - 1),
            (o = 1),
            a == "a")
        ) {
          (connecting = !1),
            (connected = !0),
            (playing = !0),
            (window._uiHidden = false),
            (window._uiMul = 1),
            fobso != null && ((fobso = null), (forcing = !1)),
            (play_btn_click_mtm = -1),
            (grd = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2]),
            (o += 3);
          var d = (t[o] << 8) | t[o + 1];
          (o += 2),
            (G.sector_size = (t[o] << 8) | t[o + 1]),
            (G.ssd256 = G.sector_size / 256),
            (o += 2),
            (G.sector_count_along_edge = (t[o] << 8) | t[o + 1]),
            (o += 2),
            (G.spangdv = t[o] / 10),
            o++,
            (G.nsp1 = ((t[o] << 8) | t[o + 1]) / 100),
            (o += 2),
            (G.nsp2 = ((t[o] << 8) | t[o + 1]) / 100),
            (o += 2),
            (G.nsp3 = ((t[o] << 8) | t[o + 1]) / 100),
            (o += 2),
            (G.mamu = ((t[o] << 8) | t[o + 1]) / 1e3),
            (o += 2),
            (G.mamu2 = ((t[o] << 8) | t[o + 1]) / 1e3),
            (o += 2),
            (G.cst = ((t[o] << 8) | t[o + 1]) / 1e3),
            (o += 2),
            o < h && ((protocol_version = t[o]), o++),
            o < h && ((G.default_msl = t[o]), o++),
            o < h
              ? ((real_sid = (t[o] << 8) | t[o + 1]), (o += 2))
              : (real_sid = 0),
            o < h
              ? ((flux_grd = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2]),
                (o += 3))
              : (flux_grd = grd * 0.98),
            (real_flux_grd = flux_grd);
          for (var f = 0; f < Hr; f++) flux_grds[f] = flux_grd;
          o < h && (t[o], o++),
            o < h && (t[o], o++),
            G.recalcSepMults(),
            G.setMscps(d),
            fl(24, !0),
            (at.style.display = "inline"),
            (ot.style.display = "inline"),
            (st.style.display = "inline"),
            (lt.style.display = "inline"),
            (yt.style.display = "inline"),
            (wt.style.display = "inline"),
            (loch.style.display = "inline"),
            Tm();
        } else if (
          a == "e" ||
          a == "E" ||
          a == "3" ||
          a == "4" ||
          a == "5" ||
          a == "d" ||
          a == "7"
        ) {
          var p,
            g = (t[o] << 8) | t[o + 1];
          if (
            protocol_version >= 14 &&
            (a == "d" ||
              a == "7" ||
              (u <= 2 &&
                (a == "e" || a == "E" || a == "3" || a == "4" || a == "5")))
          )
            p = slither;
          else {
            var g = (t[o] << 8) | t[o + 1];
            (o += 2), (p = os["s" + g]);
          }
          var _ = -1,
            m = -1,
            w = -1,
            x = -1;
          if (
            (protocol_version >= 14
              ? c == 6
                ? (a == "e" ? (_ = 1) : (_ = 2),
                  (m = (t[o] * 2 * Math.PI) / 256),
                  o++,
                  (w = (t[o] * 2 * Math.PI) / 256),
                  o++,
                  (x = t[o] / 18),
                  o++)
                : c == 5 || c == 3
                  ? a == "e"
                    ? ((m = (t[o] * 2 * Math.PI) / 256),
                      o++,
                      (x = t[o] / 18),
                      o++)
                    : a == "E"
                      ? ((_ = 1),
                        (w = (t[o] * 2 * Math.PI) / 256),
                        o++,
                        (x = t[o] / 18),
                        o++)
                      : a == "4"
                        ? ((_ = 2),
                          (w = (t[o] * 2 * Math.PI) / 256),
                          o++,
                          (x = t[o] / 18),
                          o++)
                        : a == "3"
                          ? ((_ = 1),
                            (m = (t[o] * 2 * Math.PI) / 256),
                            o++,
                            (w = (t[o] * 2 * Math.PI) / 256),
                            o++)
                          : a == "5" &&
                          ((_ = 2),
                            (m = (t[o] * 2 * Math.PI) / 256),
                            o++,
                            (w = (t[o] * 2 * Math.PI) / 256),
                            o++)
                  : (c == 4 || c == 2) &&
                  (a == "e"
                    ? ((m = (t[o] * 2 * Math.PI) / 256), o++)
                    : a == "E"
                      ? ((_ = 1), (w = (t[o] * 2 * Math.PI) / 256), o++)
                      : a == "4"
                        ? ((_ = 2), (w = (t[o] * 2 * Math.PI) / 256), o++)
                        : a == "3"
                          ? ((x = t[o] / 18), o++)
                          : a == "d"
                            ? ((_ = 1),
                              (m = (t[o] * 2 * Math.PI) / 256),
                              o++,
                              (w = (t[o] * 2 * Math.PI) / 256),
                              o++,
                              (x = t[o] / 18),
                              o++)
                            : a == "7" &&
                            ((_ = 2),
                              (m = (t[o] * 2 * Math.PI) / 256),
                              o++,
                              (w = (t[o] * 2 * Math.PI) / 256),
                              o++,
                              (x = t[o] / 18),
                              o++))
              : protocol_version >= 6
                ? c == 6
                  ? (a == "e" ? (_ = 1) : (_ = 2),
                    (m = (t[o] * 2 * Math.PI) / 256),
                    o++,
                    (w = (t[o] * 2 * Math.PI) / 256),
                    o++,
                    (x = t[o] / 18),
                    o++)
                  : c == 5
                    ? a == "e"
                      ? ((m = (t[o] * 2 * Math.PI) / 256),
                        o++,
                        (x = t[o] / 18),
                        o++)
                      : a == "E"
                        ? ((_ = 1),
                          (w = (t[o] * 2 * Math.PI) / 256),
                          o++,
                          (x = t[o] / 18),
                          o++)
                        : a == "4"
                          ? ((_ = 2),
                            (w = (t[o] * 2 * Math.PI) / 256),
                            o++,
                            (x = t[o] / 18),
                            o++)
                          : a == "3"
                            ? ((_ = 1),
                              (m = (t[o] * 2 * Math.PI) / 256),
                              o++,
                              (w = (t[o] * 2 * Math.PI) / 256),
                              o++)
                            : a == "5" &&
                            ((_ = 2),
                              (m = (t[o] * 2 * Math.PI) / 256),
                              o++,
                              (w = (t[o] * 2 * Math.PI) / 256),
                              o++)
                    : c == 4 &&
                    (a == "e"
                      ? ((m = (t[o] * 2 * Math.PI) / 256), o++)
                      : a == "E"
                        ? ((_ = 1), (w = (t[o] * 2 * Math.PI) / 256), o++)
                        : a == "4"
                          ? ((_ = 2), (w = (t[o] * 2 * Math.PI) / 256), o++)
                          : a == "3" && ((x = t[o] / 18), o++))
                : protocol_version >= 3
                  ? (a != "3" &&
                    (c == 8 ||
                      c == 7 ||
                      (c == 6 && a != "3") ||
                      (c == 5 && a != "3")) &&
                    (a == "e" ? (_ = 1) : (_ = 2)),
                    (c == 8 ||
                      c == 7 ||
                      (c == 5 && a == "3") ||
                      (c == 6 && a == "3")) &&
                    ((m = (((t[o] << 8) | t[o + 1]) * 2 * Math.PI) / 65535),
                      (o += 2)),
                    (c == 8 ||
                      c == 7 ||
                      (c == 5 && a != "3") ||
                      (c == 6 && a != "3")) &&
                    ((w = (((t[o] << 8) | t[o + 1]) * 2 * Math.PI) / 65535),
                      (o += 2)),
                    (c == 8 || c == 6 || c == 4) && ((x = t[o] / 18), o++))
                  : ((u == 11 || u == 8 || u == 9 || u == 6) &&
                    ((_ = t[o] - 48), o++),
                    (u == 11 || u == 7 || u == 9 || u == 5) &&
                    ((m =
                      (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) *
                        2 *
                        Math.PI) /
                      16777215),
                      (o += 3)),
                    (u == 11 || u == 8 || u == 9 || u == 6) &&
                    ((w =
                      (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) *
                        2 *
                        Math.PI) /
                      16777215),
                      (o += 3)),
                    (u == 11 || u == 7 || u == 8 || u == 4) &&
                    ((x = ((t[o] << 8) | t[o + 1]) / 1e3), (o += 2))),
              p)
          ) {
            if ((_ != -1 && (p.dir = _), m != -1)) {
              var M = (m - p.ang) % pi2;
              M < 0 && (M += pi2), M > Math.PI && (M -= pi2);
              for (var b = p.fapos, T = 0; T < er; T++)
                (p.fas[b] -= M * G.afas[T]), b++, b >= er && (b = 0);
              (p.fatg = er), (p.ang = m);
            }
            w != -1 && ((p.wang = w), p != slither && (p.eang = w)),
              x != -1 &&
              ((p.sp = x),
                (p.spang = p.sp / G.spangdv),
                p.spang > 1 && (p.spang = 1));
          }
        } else if (a == "6") {
          for (var C = ""; o < h;) (C += String.fromCharCode(t[o])), o++;
          _2(C);
        } else if (a == "h") {
          var g = (t[o] << 8) | t[o + 1];
          o += 2;
          var A = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 16777215;
          o += 3;
          var p = os["s" + g];
          p && ((p.fam = A), Ta(p));
        } else if (a == "r") {
          var g = (t[o] << 8) | t[o + 1];
          o += 2;
          var p = os["s" + g];
          if (p) {
            u >= 4 &&
              ((p.fam = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 16777215),
                (o += 3));
            for (var T = 0; T < p.pts.length; T++)
              if (!p.pts[T].dying) {
                (p.pts[T].dying = !0),
                  p.sct--,
                  (p.sc = Math.min(6, 1 + (p.sct - 2) / 106)),
                  (p.scang = 0.13 + 0.87 * Math.pow((7 - p.sc) / 6, 2)),
                  (p.ssp = G.nsp1 + G.nsp2 * p.sc),
                  (p.fsp = p.ssp + 0.1),
                  (p.wsep = 6 * p.sc);
                var R = nsep;
                p.wsep < R && (p.wsep = R);
                break;
              }
            Ta(p);
          }
        } else if (a == "R") (slither.rsc = t[o]), o++;
        else if (a == "B") {
          if (testing) {
            var g = (t[o] << 8) | t[o + 1];
            (o += 2),
              (p = os["s" + g]),
              (U = (t[o] << 8) | t[o + 1]),
              (o += 2),
              (X = (t[o] << 8) | t[o + 1]),
              (o += 2);
            var k = t[o];
            if ((o++, U != p.lpo_xx || X != p.lpo_yy)) {
              var W = U - p.lpo_xx,
                D = X - p.lpo_yy;
              (Math.abs(W) > 1 || Math.abs(D) > 1) &&
                testing &&
                ((W = Math.round(W * 100) / 100),
                  (D = Math.round(D * 100) / 100),
                  p == slither
                    ? console.log(
                      "invalid new point delta for self: " +
                      W +
                      " " +
                      D +
                      " (" +
                      p.lpo_cmd +
                      ", prev " +
                      p.lpo_prev_cmd +
                      ") (sct " +
                      p.sct +
                      " " +
                      k +
                      ") " +
                      p.lpo_dd
                    )
                    : console.log(
                      "invalid new point delta for " +
                      p.nk +
                      ": " +
                      W +
                      " " +
                      D +
                      " (" +
                      p.lpo_cmd +
                      ", prev " +
                      p.lpo_prev_cmd +
                      ") (sct " +
                      p.sct +
                      " " +
                      k +
                      ") " +
                      p.lpo_dd
                    ));
            }
          }
        } else if (
          a == "g" ||
          a == "n" ||
          a == "G" ||
          a == "N" ||
          a == "+" ||
          a == "="
        ) {
          if (!playing) return;
          var I = a == "n" || a == "N" || a == "+",
            p;
          if (protocol_version >= 15)
            if (
              a == "G" ||
              a == "N" ||
              (a == "=" && u == 6) ||
              (a == "+" && u == 9)
            )
              p = slither;
            else {
              var g = (t[o] << 8) | t[o + 1];
              (o += 2), (p = os["s" + g]);
            }
          else if (
            (a == "g" && u == 4) ||
            (a == "G" && u == 2) ||
            (a == "n" && u == 7) ||
            (a == "N" && u == 5)
          )
            p = slither;
          else {
            var g = (t[o] << 8) | t[o + 1];
            (o += 2), (p = os["s" + g]);
          }
          if (p) {
            if (I) p.sct++;
            else
              for (var T = 0; T < p.pts.length; T++)
                if (!p.pts[T].dying) {
                  p.pts[T].dying = !0;
                  break;
                }
            var y = p.pts[p.pts.length - 1],
              Z,
              V,
              z,
              W,
              D,
              $,
              B,
              re,
              qe,
              S,
              J,
              F = Pc.get();
            if (!F)
              (F = {}),
                (F.fxs = new Float32Array(nt)),
                (F.fys = new Float32Array(nt)),
                (F.fltns = new Float32Array(nt)),
                (F.fsmus = new Float32Array(nt));
            else
              for (var f = nt - 1; f >= 0; f--)
                (F.fxs[f] = 0),
                  (F.fys[f] = 0),
                  (F.fltns[f] = 0),
                  (F.fsmus[f] = 0);
            var ht = p.msl;
            if (protocol_version >= 15)
              if (a == "+" || a == "=") {
                var it = (t[o] << 8) | t[o + 1];
                (F.iang = it),
                  (o += 2),
                  (U = (t[o] << 8) | t[o + 1]),
                  (o += 2),
                  (X = (t[o] << 8) | t[o + 1]),
                  (o += 2);
              } else {
                var it;
                (a == "G" && u == 2) ||
                  (a == "N" && u == 5) ||
                  (a == "g" && u == 4) ||
                  (a == "n" && u == 7)
                  ? ((it = (t[o] << 8) | t[o + 1]), (o += 2))
                  : (it = y.iang),
                  (F.iang = it);
                var m = (it * pi2) / 65536;
                (U = y.xx + Math.cos(m) * ht), (X = y.yy + Math.sin(m) * ht);
              }
            else
              protocol_version >= 3
                ? a == "g" || a == "n"
                  ? ((U = (t[o] << 8) | t[o + 1]),
                    (o += 2),
                    (X = (t[o] << 8) | t[o + 1]),
                    (o += 2))
                  : ((U = y.xx + t[o] - 128), o++, (X = y.yy + t[o] - 128), o++)
                : ((U = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5),
                  (o += 3),
                  (X = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5),
                  (o += 3));
            if (
              (I &&
                ((p.fam =
                  ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 16777215),
                  (o += 3)),
                (F.fpos = 0),
                (F.ftg = 0),
                (F.smu = 1),
                (F.fsmu = 0),
                (F.xx = U),
                (F.yy = X),
                (F.fx = 0),
                (F.fy = 0),
                (F.fltn = 0),
                (F.da = 0),
                (F.ltn =
                  Math.sqrt(Math.pow(F.xx - y.xx, 2) + Math.pow(F.yy - y.yy, 2)) /
                  ht),
                (F.ebx = F.xx - y.xx),
                (F.eby = F.yy - y.yy),
                p.pts.push(F),
                p.iiv)
            ) {
              var Ue = p.xx + p.fx,
                rs = p.yy + p.fy;
              (W = Ue - (y.xx + y.fx)),
                (D = rs - (y.yy + y.fy)),
                (J = Math.sqrt(W * W + D * D)),
                J > 1 && ((W /= J), (D /= J)),
                (d2 = F.ltn * ht),
                J < ht ? (d3 = J) : (d3 = d2),
                ($ = y.xx + y.fx + W * d3),
                (B = y.yy + y.fy + D * d3),
                (re = 1 - d3 / d2),
                (W = F.xx - $),
                (D = F.yy - B);
              for (var b = F.fpos, T = 0; T < nt; T++)
                (F.fxs[b] -= W * G.hfas[T]),
                  (F.fys[b] -= D * G.hfas[T]),
                  (F.fltns[b] -= re * G.hfas[T]),
                  b++,
                  b >= nt && (b = 0);
              (F.fx = F.fxs[F.fpos]),
                (F.fy = F.fys[F.fpos]),
                (F.fltn = F.fltns[F.fpos]),
                (F.fsmu = F.fsmus[F.fpos]),
                (F.ftg = nt);
            }
            y = F;
            var bs = 3,
              b = p.pts.length - 3;
            if (b >= 1) {
              (z = p.pts[b]), (n = 0), (V = 0), (qe = 0);
              for (var o = b - 1; o >= 0; o--) {
                if (
                  ((Z = p.pts[o]),
                    n++,
                    ($ = Z.xx),
                    (B = Z.yy),
                    (S = Z.smu),
                    n <= 4 && (V = (G.cst * n) / 4),
                    (Z.xx += (z.xx - Z.xx) * V),
                    (Z.yy += (z.yy - Z.yy) * V),
                    Z.smu != G.smus[bs]
                      ? ((S = Z.smu), (Z.smu = G.smus[bs]), (qe = Z.smu - S))
                      : (qe = 0),
                    bs < G.smuc_m3 && bs++,
                    p.iiv)
                ) {
                  (W = Z.xx - $), (D = Z.yy - B);
                  for (var b = Z.fpos, T = 0; T < nt; T++)
                    (Z.fxs[b] -= W * G.hfas[T]),
                      (Z.fys[b] -= D * G.hfas[T]),
                      (Z.fsmus[b] -= qe * G.hfas[T]),
                      b++,
                      b >= nt && (b = 0);
                  (Z.fx = Z.fxs[Z.fpos]),
                    (Z.fy = Z.fys[Z.fpos]),
                    (Z.fsmu = Z.fsmus[Z.fpos]),
                    (Z.ftg = nt);
                }
                z = Z;
              }
            }
            (p.sc = Math.min(6, 1 + (p.sct - 2) / 106)),
              (p.scang = 0.13 + 0.87 * Math.pow((7 - p.sc) / 6, 2)),
              (p.ssp = G.nsp1 + G.nsp2 * p.sc),
              (p.fsp = p.ssp + 0.1),
              (p.wsep = 6 * p.sc);
            var R = nsep;
            p.wsep < R && (p.wsep = R),
              I && Ta(p),
              p == slither &&
              ((ovxx = slither.xx + slither.fx),
                (ovyy = slither.yy + slither.fy));
            var Ss = (p.sp * (etm / 8)) / 4;
            Ss *= lag_mult;
            var oi = p.chl - 1;
            p.chl = Ss / p.msl;
            var W = U - p.xx,
              D = X - p.yy,
              Fi = p.chl - oi;
            (p.xx = U), (p.yy = X);
            for (var b = p.fpos, T = 0; T < is; T++)
              (p.fxs[b] -= W * G.rfas[T]),
                (p.fys[b] -= D * G.rfas[T]),
                (p.fchls[b] -= Fi * G.rfas[T]),
                b++,
                b >= is && (b = 0);
            if (
              ((p.fx = p.fxs[p.fpos]),
                (p.fy = p.fys[p.fpos]),
                (p.fchl = p.fchls[p.fpos]),
                (p.ftg = is),
                (p.ehl = 0),
                p == slither)
            ) {
              var wr = view_xx,
                Sr = view_yy;
              follow_view &&
                ((view_xx = slither.xx + slither.fx),
                  (view_yy = slither.yy + slither.fy)),
                (G.bgx2 -= ((view_xx - wr) * 1) / oa),
                (G.bgy2 -= ((view_yy - Sr) * 1) / la),
                (G.bgx2 %= 1),
                G.bgx2 < 0 && (G.bgx2 += 1),
                (G.bgy2 %= 1),
                G.bgy2 < 0 && (G.bgy2 += 1);
              for (
                var W = view_xx - ovxx, D = view_yy - ovyy, b = fvpos, T = 0;
                T < vfc;
                T++
              )
                (fvxs[b] -= W * vfas[T]),
                  (fvys[b] -= D * vfas[T]),
                  b++,
                  b >= vfc && (b = 0);
              fvtg = vfc;
            }
          }
        } else if (a == "l") {
          if (!playing) return;
          wumsts = !0;
          var Et = "",
            Ut = "",
            ds = "",
            O = 0,
            H = 0;
          lb_fr == -1 && dead_mtm == -1 && (lb_fr = 0);
          var b,
            ke,
            ct,
            Gi = t[o];
          for (
            o++,
            rank = (t[o] << 8) | t[o + 1],
            rank < best_rank && (best_rank = rank),
            o += 2,
            slither_count = (t[o] << 8) | t[o + 1],
            slither_count > biggest_slither_count &&
            (biggest_slither_count = slither_count),
            o += 2;
            o < h;

          ) {
            var Fs = (t[o] << 8) | t[o + 1];
            o += 2;
            var A = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 16777215;
            o += 3;
            var ye = t[o] % 9;
            o++;
            var Yt = t[o];
            o++, H++;
            for (var dt = "", T = 0; T < Yt; T++)
              (ke = t[o]), (dt += String.fromCharCode(ke)), o++;
            H == Gi ? ((dt = my_nick), (Yt = dt.length)) : ua(dt) || (dt = "");
            for (var ns = "", T = 0; T < Yt; T++)
              (ke = dt.charCodeAt(T)),
                ke == 38
                  ? (ns += "&amp;")
                  : ke == 60
                    ? (ns += "&lt;")
                    : ke == 62
                      ? (ns += "&gt;")
                      : ke == 32
                        ? (ns += "&nbsp;")
                        : (ns += String.fromCharCode(ke));
            (dt = ns),
              O++;
            var _ktye = Kt[ye] || { cs: "#fff" };
            (ct =
              Math.floor((G.fpsls[Fs] + A / G.fmlts[Fs] - 1) * 15 - 5) / 1),
              H == Gi ? (b = 1) : (b = 0.7 * (0.3 + 0.7 * (1 - O / 10))),
              (Et +=
                '<span style="opacity:' +
                b +
                "; color:" +
                _ktye.cs +
                ';">' +
                ct +
                "</span><BR>"),
              (Ut +=
                '<span style="opacity:' +
                b +
                "; color:" +
                _ktye.cs +
                ";" +
                (H == Gi ? "font-weight:bold;" : "") +
                '">' +
                dt +
                "</span><BR>"),
              (ds +=
                '<span style="opacity:' +
                b +
                "; color:" +
                _ktye.cs +
                ';">#' +
                O +
                "</span><BR>");
          }
          (ot.innerHTML = Et), (st.innerHTML = Ut), (lt.innerHTML = ds);
        } else if (a == "v")
          if (t[o] == 2)
            (want_close_socket = !0),
              (want_victory_message = !1),
              (want_hide_victory = 1),
              (hvfr = 0);
          else {
            (dead_mtm = Date.now()), _n.setEnabled(!0);
            var Fs = slither.sct + slither.rsc,
              Di =
                Math.floor(
                  (G.fpsls[Fs] + slither.fam / G.fmlts[Fs] - 1) * 15 - 5
                ) / 1,
              li = "Your final length was";
            var ts = "";
            Di > 1e3 && (ts = "!");
            var C =
              '<span style="opacity: .45;">' +
              li +
              " </span><b>" +
              Di +
              "</b>" +
              ts;
            lastscore.innerHTML = C;
            var Qe = "Play Again";
            _n.setText("" + Qe + ""),
              t[o] == 1
                ? ((nick_holder.style.display = "none"),
                  (playh.style.display = "none"),
                  (smh.style.display = "none"),
                  (victory_holder.style.display = "inline"),
                  (saveh.style.display = "block"),
                  (want_victory_message = !0),
                  (want_victory_focus = !0),
                  (victory.disabled = !1),
                  save_btn.setEnabled(!0))
                : (want_close_socket = !0);
          }
        else if (a == "W") {
          (U = t[o]), o++, (X = t[o]), o++;
          var p = {};
          (p.xx = U), (p.yy = X), sectors.push(p);
        } else if (a == "w") {
          var qr;
          if (
            (protocol_version >= 8
              ? ((qr = 2), (U = t[o]), o++, (X = t[o]), o++)
              : ((qr = t[o]),
                o++,
                (U = (t[o] << 8) | t[o + 1]),
                (o += 2),
                (X = (t[o] << 8) | t[o + 1]),
                (o += 2)),
              qr == 1)
          ) {
            var p = {};
            (p.xx = U), (p.yy = X), sectors.push(p);
          } else {
            cm1 = foods_c - 1;
            for (var f = cm1; f >= 0; f--) {
              var Re = foods[f];
              Re.sx == U &&
                Re.sy == X &&
                (Oo(Re),
                  f == cm1
                    ? ((foods[f] = null), foods_c--, cm1--)
                    : ((foods[f] = foods[cm1]),
                      (foods[cm1] = null),
                      foods_c--,
                      cm1--));
            }
            for (var f = sectors.length - 1; f >= 0; f--) {
              var p = sectors[f];
              p.xx == U && p.yy == X && sectors.splice(f, 1);
            }
          }
        } else if (a == "m") {
          var Fs = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2];
          o += 3;
          var A = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 16777215;
          o += 3;
          var Ui = Math.floor((G.fpsls[Fs] + A / G.fmlts[Fs] - 1) * 15 - 5) / 1,
            Yt = t[o];
          o++;
          for (var Ms = "", f = 0; f < Yt; f++)
            (Ms += String.fromCharCode(t[o])), o++;
          ua(Ms) || (Ms = "");
          for (var us = ""; o < h;) (us += String.fromCharCode(t[o])), o++;
          if (
            (ua(us) || (us = ""),
              (Ms = Ms.split("&")
                .join("&amp;")
                .split("<")
                .join("&lt;")
                .split(">")
                .join("&gt;")),
              (us = us
                .split("&")
                .join("&amp;")
                .split("<")
                .join("&lt;")
                .split(">")
                .join("&gt;")),
              Ui > 0)
          ) {
            var Ts = "";
            us.length > 0 &&
              (Ts +=
                "<span style='font-size:17px;'><b><i><span style='opacity: .5;'>&quot;</span>" +
                us +
                "<span style='opacity: .5;'>&quot;</span></i></b></span><BR><div style='height: 5px;'></div>"),
              Ms.length > 0
                ? (us.length > 0
                  ? (Ts +=
                    "<i><span style='opacity: .5;'>- </span><span style='opacity: .75;'><b>" +
                    Ms +
                    "</b></span><span style='opacity: .5;'>, today's longest</span></i>")
                  : (Ts =
                    "<i><span style='opacity: .5;'>Today's longest was </span><span style='opacity: .75;'><b>" +
                    Ms +
                    "</b></span></i>"),
                  (Ts +=
                    "<br><i><span style='opacity: .5;'>with a length of </span><span style='opacity: .65;'><b>" +
                    Ui +
                    "</b></span></i>"))
                : us.length > 0
                  ? ((Ts +=
                    "<i><span style='opacity: .5;'>- </span><span style='opacity: .5;'>today's longest</span></i>"),
                    (Ts +=
                      "<br><i><span style='opacity: .5;'>with a length of </span><span style='opacity: .65;'><b>" +
                      Ui +
                      "</b></span></i>"))
                  : (Ts +=
                    "<i><span style='opacity: .5;'>Today's longest: </span><span style='opacity: .75;'><b>" +
                    Ui +
                    "</b></span></i>"),
              (wt.innerHTML = Ts);
          }
        } else if (a == "p") {
          var now = Date.now();
          window.fe_ping = now - lpstm;
          if (now - window.fe_pingLastUpdate > 10000 && window.sid_tf && window.real_sid > 0) {
            window.fe_pingLastUpdate = now;
            window.sid_tf.textContent = "server " + window.real_sid + " (" + window.fe_ping + "ms)";
          }
          (wfpr = !1), lagging && ((etm *= lag_mult), (lagging = !1));
        }
        else if (a == "U") {
          var K = (t[o] << 8) | t[o + 1];
          if (
            ((o += 2), K > 512 && (K = 512), mmsz != K && fl(K, !1), !mmgad)
          ) {
            var Me = asmc.getContext("2d");
            Me.clearRect(0, 0, mmsz, mmsz), Me.drawImage(asmc2, 0, 0);
          }
          (mmbfr = 0), (asmc.style.opacity = mmsta), (asmc2.style.opacity = 0);
          var Me = asmc2.getContext("2d");
          Me.clearRect(0, 0, mmsz, mmsz), (Me.fillStyle = "#fff");
          for (var f, b = 0, U = mmsz - 1, X = mmsz - 1; o < h && !(X < 0);)
            if (((b = t[o++]), b >= 128))
              for (
                b -= 128, f = 0;
                f < b && (U--, !(U < 0 && ((U = mmsz - 1), X--, X < 0)));
                f++
              );
            else
              for (
                f = 0;
                f < 7 &&
                ((b & pl[f]) > 0 && Me.fillRect(U, X, 1, 1),
                  U--,
                  !(U < 0 && ((U = mmsz - 1), X--, X < 0)));
                f++
              );
          if (!mmgad) {
            mmgad = !0;
            var Me = asmc.getContext("2d");
            Me.clearRect(0, 0, mmsz, mmsz), Me.drawImage(asmc2, 0, 0);
          }
        } else if (a == "M") {
          var K = (t[o] << 8) | t[o + 1];
          if (
            ((o += 2),
              K > 512 && (K = 512),
              mmsz != K && fl(K, !1),
              mmdata.fill(0),
              mmgad)
          ) {
            var Me = asmc.getContext("2d");
            Me.clearRect(0, 0, mmsz, mmsz), Me.drawImage(asmc2, 0, 0);
          }
          (mmbfr = 0), (asmc.style.opacity = mmsta), (asmc2.style.opacity = 0);
          var Me = asmc2.getContext("2d");
          Me.clearRect(0, 0, mmsz, mmsz), (Me.fillStyle = "#fff");
          for (var f, b = 0, U = mmsz - 1, X = mmsz - 1; o < h && !(X < 0);)
            if (((b = t[o++]), b >= 128))
              for (
                b == 255 ? (b = 126 * t[o++]) : (b -= 128), f = 0;
                f < b && (U--, !(U < 0 && ((U = mmsz - 1), X--, X < 0)));
                f++
              );
            else
              for (
                f = 0;
                f < 7 &&
                ((b & pl[f]) > 0 &&
                  ((mmdata[X * mmsz + U] = 1), Me.fillRect(U, X, 1, 1)),
                  U--,
                  !(U < 0 && ((U = mmsz - 1), X--, X < 0)));
                f++
              );
          if (!mmgad) {
            mmgad = !0;
            var Me = asmc.getContext("2d");
            Me.clearRect(0, 0, mmsz, mmsz), Me.drawImage(asmc2, 0, 0);
          }
        } else if (a == "V") {
          if (mmgad) {
            var Me = asmc.getContext("2d");
            Me.clearRect(0, 0, mmsz, mmsz), Me.drawImage(asmc2, 0, 0);
          }
          (mmbfr = 0), (asmc.style.opacity = mmsta), (asmc2.style.opacity = 0);
          var Me = asmc2.getContext("2d");
          Me.fillStyle = "#fff";
          for (var f, T, b = 0, U = mmsz - 1, X = mmsz - 1; o < h && !(X < 0);)
            if (((b = t[o++]), b >= 128))
              for (
                b == 255 ? (b = 126 * t[o++]) : (b -= 128), f = 0;
                f < b && (U--, !(U < 0 && ((U = mmsz - 1), X--, X < 0)));
                f++
              );
            else
              for (
                f = 0;
                f < 7 &&
                ((b & pl[f]) > 0 &&
                  ((T = X * mmsz + U),
                    mmdata[T] == 1
                      ? ((mmdata[T] = 0), Me.clearRect(U, X, 1, 1))
                      : ((mmdata[T] = 1), Me.fillRect(U, X, 1, 1))),
                  U--,
                  !(U < 0 && ((U = mmsz - 1), X--, X < 0)));
                f++
              );
          if (!mmgad) {
            mmgad = !0;
            var Me = asmc.getContext("2d");
            Me.clearRect(0, 0, mmsz, mmsz), Me.drawImage(asmc2, 0, 0);
          }
        } else if (a == "u") {
          (mmgad = !0), mmsz != 80 && fl(80, !0);
          var Me = asmc.getContext("2d");
          Me.clearRect(0, 0, 80, 80), (Me.fillStyle = "#fff");
          for (var f, b = 0, U = 0, X = 0; o < h && !(X >= 80);)
            if (((b = t[o++]), b >= 128))
              for (
                b -= 128, f = 0;
                f < b && (U++, !(U >= 80 && ((U = 0), X++, X >= 80)));
                f++
              );
            else
              for (
                f = 0;
                f < 7 &&
                ((b & pl[f]) > 0 && Me.fillRect(U, X, 1, 1),
                  U++,
                  !(U >= 80 && ((U = 0), X++, X >= 80)));
                f++
              );
        } else if (a == "i") {
          adm = !0;
          var g = (t[o] << 8) | t[o + 1];
          o += 2;
          var p = os["s" + g];
          if (p) {
            var bn = t[o];
            o++;
            var Mi = t[o];
            o++;
            var Ti = t[o];
            o++;
            var Oi = t[o];
            if ((o++, bn > 0 || Mi > 0 || Ti > 0 || Oi > 0)) {
              var yl = bn + "." + Mi + "." + Ti + "." + Oi;
              p.nk += " - " + yl;
            }
          }
        } else if (a == "o") {
          if (checking_code)
            if (connecting) (connecting = !1), (connected = !0);
            else {
              if (t[o] == 0) (etcshk = !0), (etcshkv = 0);
              else {
                var ut = [];
                try {
                  var hi = localStorage.cocds;
                  hi && (ut = ("" + hi).split(","));
                } catch { }
                var C = "";
                (C += "" + etcods[0].v),
                  (C += "" + etcods[1].v),
                  (C += "" + etcods[2].v),
                  (C += "" + etcods[3].v),
                  (C += "-"),
                  (C += "" + etcods[5].v),
                  (C += "" + etcods[6].v),
                  (C += "" + etcods[7].v),
                  (C += "" + etcods[8].v),
                  (C += "-"),
                  (C += "" + etcods[10].v),
                  (C += "" + etcods[11].v),
                  (C += "" + etcods[12].v),
                  (C += "" + etcods[13].v);
                for (var kt = !0, f = ut.length - 1; f >= 0; f--)
                  if (ut[f] == C) {
                    kt = !1;
                    break;
                  }
                if (kt) {
                  ut.push(C);
                  try {
                    localStorage.cocds = ut.join(",");
                  } catch { }
                  recalculateActivatedCosmetics();
                }
                (ending_enter_code = !0), (want_open_cosmetics = !0);
              }
              stchco();
            }
        } else if (a == "s") {
          if (!playing) return;
          var g = (t[o] << 8) | t[o + 1];
          if (((o += 2), u > 6)) {
            var m =
              (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
              16777215;
            o += 3;
            var _ = t[o] - 48;
            o++;
            var w =
              (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
              16777215;
            o += 3;
            var x = ((t[o] << 8) | t[o + 1]) / 1e3;
            o += 2;
            var A = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 16777215;
            o += 3;
            var ye = t[o];
            o++;
            var Nt = [],
              Be = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5;
            o += 3;
            var Cs = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5;
            o += 3;
            var Yt = t[o];
            o++;
            for (var dt = "", T = 0; T < Yt; T++)
              (dt += String.fromCharCode(t[o])), o++;
            var ci = null;
            if (protocol_version >= 11) {
              var Ci = t[o];
              if ((o++, Ci > 0)) {
                ci = new Uint8Array(Ci);
                for (var T = 0; T < Ci; T++) ci[T] = t[o + T];
              }
              o += Ci;
            }
            protocol_version >= 12 && (t[o], o++);
            var ht = G.default_msl;
            (U = 0), (X = 0);
            for (
              var ps = 0, Mr = 0, Ra = !1, b = 1, F = null, xl = h - 2;
              o < h;

            ) {
              if (((F = Pc.get()), !F))
                (F = {}),
                  (F.fxs = new Float32Array(nt)),
                  (F.fys = new Float32Array(nt)),
                  (F.fltns = new Float32Array(nt)),
                  (F.fsmus = new Float32Array(nt));
              else
                for (var f = 0; f < nt; f++)
                  (F.fxs[f] = 0),
                    (F.fys[f] = 0),
                    (F.fltns[f] = 0),
                    (F.fsmus[f] = 0);
              if (((ps = U), (Mr = X), !Ra))
                (U = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5),
                  (o += 3),
                  (X = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5),
                  (o += 3),
                  (ps = U),
                  (Mr = X),
                  (Ra = !0);
              else if (o == xl && protocol_version >= 15) {
                var it = (t[o] << 8) | t[o + 1];
                (F.iang = it), (o += 2);
                var m = (it * pi2) / 65536;
                (U += Math.cos(m) * ht), (X += Math.sin(m) * ht);
              } else (U += (t[o] - 127) / 2), o++, (X += (t[o] - 127) / 2), o++;
              (F.fpos = 0),
                (F.ftg = 0),
                (F.fsmu = 0),
                (F.xx = U),
                (F.yy = X),
                (F.fx = 0),
                (F.fy = 0),
                (F.fltn = 0),
                (F.da = 0),
                (F.ltn = 1),
                (F.ebx = U - ps),
                (F.eby = X - Mr),
                Nt.push(F);
            }
            for (var T = 0, f = Nt.length - 1; f >= 0; f--)
              T < G.smuc_m3 && ((b = G.smus[T]), T++), (Nt[f].smu = b);
            var p = Cm(g, Be, Cs, ye, m, Nt, ht, ci);
            if (slither == null) {
              (view_xx = U), (view_yy = X), (slither = p);
              try {
                var ke = localStorage.cosmetic;
                ke == "" + Number(ke) && (slither.accessory = Number(ke));
                var savedSkin = localStorage.snakercv;
                if (!p.cusk && savedSkin != null && savedSkin !== "" && savedSkin == "" + Number(savedSkin)) {
                  ye = Number(savedSkin);
                  p.rcv != ye && Ii(p, ye);
                }
              } catch { }
              (slither.md = !1),
                (slither.wmd = !1),
                (p.nk = my_nick),
                (lfsx = -1),
                (lfsy = -1),
                (lfcv = 0),
                (lfvsx = -1),
                (lfvsy = -1),
                (lfesid = -1);
            } else (p.nk = dt), ua(dt) || (p.nk = "");
            if (((p.ip = ""), (p.onk = ""), ggl)) {
              var as = Xw.get();
              as
                ? ((as.visible = !0), (as.text = dt), (as.style.fill = p.csw))
                : ((as = new yv({
                  text: p.nk,
                  style: {
                    fontSize: 15,
                    fill: p.csw,
                    fontFamily:
                      "Arial, Helvetica Neue, Helvetica, sans-serif",
                    align: "center",
                  },
                })),
                  as.anchor.set(0.5, 0)),
                (as.alpha = 1),
                (p.nko = as),
                nmlo.addChild(as);
            }
            (p.eang = p.wang = w),
              (p.sp = x),
              (p.spang = p.sp / G.spangdv),
              p.spang > 1 && (p.spang = 1),
              (p.fam = A),
              (p.sc = Math.min(6, 1 + (p.sct - 2) / 106)),
              (p.scang = 0.13 + 0.87 * Math.pow((7 - p.sc) / 6, 2)),
              (p.ssp = G.nsp1 + G.nsp2 * p.sc),
              (p.fsp = p.ssp + 0.1),
              (p.wsep = 6 * p.sc);
            var R = nsep;
            p.wsep < R && (p.wsep = R), (p.sep = p.wsep), Ta(p);
          } else {
            var rr = t[o] == 1;
            o++;
            for (var f = slithers.length - 1; f >= 0; f--)
              if (slithers[f].id == g) {
                var p = slithers[f];
                (p.id = -1234),
                  rr
                    ? ((p.dead = !0), (p.dead_amt = 0), (p.edir = 0))
                    : G.destroySlitherAtIndex(f),
                  delete os["s" + g];
                break;
              }
          }
        } else if (a == "F")
          if (protocol_version >= 14) {
            var Te = t[o];
            o++;
            var Ye = t[o];
            o++;
            for (
              var ft = Te * G.sector_size,
              ze = Ye * G.sector_size,
              U,
              X,
              Gs,
              Ys,
              ye,
              Ce,
              g,
              Re;
              o < h;

            )
              (ye = t[o]),
                o++,
                (Gs = t[o]),
                o++,
                (Ys = t[o]),
                o++,
                (U = ft + Gs * G.ssd256),
                (X = ze + Ys * G.ssd256),
                (Ce = t[o] / 5),
                o++,
                (g = (Te << 24) | (Ye << 16) | (Gs << 8) | Ys),
                (Re = Ji(g, U, X, Ce, !0, ye)),
                (Re.sx = Te),
                (Re.sy = Ye);
          } else if (protocol_version >= 4)
            for (var Tr = !1, Te, Ye; o < h;) {
              var ye = t[o];
              o++,
                (U = (t[o] << 8) | t[o + 1]),
                (o += 2),
                (X = (t[o] << 8) | t[o + 1]),
                (o += 2);
              var Ce = t[o] / 5;
              o++;
              var g = X * grd * 3 + U,
                Re = Ji(g, U, X, Ce, !0, ye);
              Tr ||
                ((Tr = !0),
                  (Te = Math.floor(U / G.sector_size)),
                  (Ye = Math.floor(X / G.sector_size))),
                (Re.sx = Te),
                (Re.sy = Ye);
            }
          else {
            var Te = (t[o] << 8) | t[o + 1];
            o += 2;
            var Ye = (t[o] << 8) | t[o + 1];
            for (o += 2; o < h;) {
              var g = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2];
              o += 3;
              var ye = t[o];
              o++,
                (U = G.sector_size * (Te + t[o] / 255)),
                o++,
                (X = G.sector_size * (Ye + t[o] / 255)),
                o++;
              var Ce = t[o] / 5;
              o++;
              var Re = Ji(g, U, X, Ce, !0, ye);
              (Re.sx = Te), (Re.sy = Ye);
            }
          }
        else if (a == "b" || a == "f") {
          var g;
          if (protocol_version >= 14) {
            var Te, Ye;
            u >= 5
              ? ((Te = t[o]), o++, (Ye = t[o]), o++, (lfsx = Te), (lfsy = Ye))
              : ((Te = lfsx), (Ye = lfsy));
            var Gs = t[o];
            o++;
            var Ys = t[o];
            o++;
            var U = Te * G.sector_size + Gs * G.ssd256,
              X = Ye * G.sector_size + Ys * G.ssd256;
            g = (Te << 24) | (Ye << 16) | (Gs << 8) | Ys;
            var ye;
            u == 4 || u == 6 ? ((ye = t[o]), o++, (lfcv = ye)) : (ye = lfcv);
            var Ce = t[o] / 5;
            o++;
            var Re = Ji(g, U, X, Ce, a == "b", ye);
            (Re.sx = Te), (Re.sy = Ye);
          } else if (protocol_version >= 4) {
            var ye = t[o];
            if ((o++, u > 4)) {
              (U = (t[o] << 8) | t[o + 1]),
                (o += 2),
                (X = (t[o] << 8) | t[o + 1]),
                (o += 2),
                (g = X * grd * 3 + U);
              var Ce = t[o] / 5;
              o++;
              var Re = Ji(g, U, X, Ce, a == "b", ye);
              (Re.sx = Math.floor(U / G.sector_size)),
                (Re.sy = Math.floor(X / G.sector_size));
            }
          } else if (
            ((g = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2]), (o += 3), u > 4)
          ) {
            var ye = t[o];
            o++;
            var Te = (t[o] << 8) | t[o + 1];
            o += 2;
            var Ye = (t[o] << 8) | t[o + 1];
            (o += 2),
              (U = G.sector_size * (Te + t[o] / 255)),
              o++,
              (X = G.sector_size * (Ye + t[o] / 255)),
              o++;
            var Ce = t[o] / 5;
            o++;
            var Re = Ji(g, U, X, Ce, a == "b", ye);
            (Re.sx = Te), (Re.sy = Ye);
          }
        } else if (a == "c" || a == "C" || a == "<") {
          var g,
            gs = -1,
            Te,
            Ye,
            Gs,
            Ys;
          if (protocol_version >= 14)
            (a == "c" && u == 2) || (a == "<" && u == 4) || (a == "C" && u == 2)
              ? ((Te = lfvsx), (Ye = lfvsy))
              : ((Te = t[o]),
                o++,
                (Ye = t[o]),
                o++,
                (lfvsx = Te),
                (lfvsy = Ye)),
              (Gs = t[o]),
              o++,
              (Ys = t[o]),
              o++,
              (g = (Te << 24) | (Ye << 16) | (Gs << 8) | Ys),
              a == "<"
                ? ((gs = (t[o] << 8) | t[o + 1]), (o += 2), (lfesid = gs))
                : a == "C" && (gs = lfesid);
          else if (protocol_version >= 4) {
            var U = (t[o] << 8) | t[o + 1];
            o += 2;
            var X = (t[o] << 8) | t[o + 1];
            (o += 2),
              (g = X * grd * 3 + U),
              (gs = (t[o] << 8) | t[o + 1]),
              (o += 2);
          } else
            (g = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2]),
              (o += 3),
              (gs = (t[o] << 8) | t[o + 1]),
              (o += 2);
          cm1 = foods_c - 1;
          for (var f = cm1; f >= 0; f--) {
            var Re = foods[f];
            if (Re.id == g) {
              (Re.eaten = !0),
                gs >= 0
                  ? ((Re.eaten_by = os["s" + gs]), (Re.eaten_fr = 0))
                  : (Oo(Re),
                    f == cm1
                      ? ((foods[f] = null), foods_c--, cm1--)
                      : ((foods[f] = foods[cm1]),
                        (foods[cm1] = null),
                        foods_c--,
                        cm1--)),
                (g = -1);
              break;
            }
          }
        } else if (a == "j") {
          var g = (t[o] << 8) | t[o + 1];
          (o += 2),
            (U = 1 + ((t[o] << 8) | t[o + 1]) * 3),
            (o += 2),
            (X = 1 + ((t[o] << 8) | t[o + 1]) * 3),
            (o += 2);
          var de = null;
          for (f = preys.length - 1; f >= 0; f--)
            if (preys[f].id == g) {
              de = preys[f];
              break;
            }
          if (de) {
            var Ss = (de.sp * (etm / 8)) / 4;
            Ss *= lag_mult;
            var $ = de.xx,
              B = de.yy;
            u == 15
              ? ((de.dir = t[o] - 48),
                o++,
                (de.ang =
                  (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                  16777215),
                (o += 3),
                (de.wang =
                  (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                  16777215),
                (o += 3),
                (de.sp = ((t[o] << 8) | t[o + 1]) / 1e3),
                (o += 2))
              : u == 11
                ? ((de.ang =
                  (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                  16777215),
                  (o += 3),
                  (de.sp = ((t[o] << 8) | t[o + 1]) / 1e3),
                  (o += 2))
                : u == 12
                  ? ((de.dir = t[o] - 48),
                    o++,
                    (de.wang =
                      (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                      16777215),
                    (o += 3),
                    (de.sp = ((t[o] << 8) | t[o + 1]) / 1e3),
                    (o += 2))
                  : u == 13
                    ? ((de.dir = t[o] - 48),
                      o++,
                      (de.ang =
                        (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                        16777215),
                      (o += 3),
                      (de.wang =
                        (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                        16777215),
                      (o += 3))
                    : u == 9
                      ? ((de.ang =
                        (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                        16777215),
                        (o += 3))
                      : u == 10
                        ? ((de.dir = t[o] - 48),
                          o++,
                          (de.wang =
                            (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
                            16777215),
                          (o += 3))
                        : u == 8 && ((de.sp = ((t[o] << 8) | t[o + 1]) / 1e3), (o += 2)),
              (de.xx = U + Math.cos(de.ang) * Ss),
              (de.yy = X + Math.sin(de.ang) * Ss);
            for (
              var W = de.xx - $, D = de.yy - B, b = de.fpos, T = 0;
              T < is;
              T++
            )
              (de.fxs[b] -= W * G.rfas[T]),
                (de.fys[b] -= D * G.rfas[T]),
                b++,
                b >= is && (b = 0);
            (de.fx = de.fxs[de.fpos]), (de.fy = de.fys[de.fpos]), (de.ftg = is);
          }
        } else if (a == "y") {
          var g = (t[o] << 8) | t[o + 1];
          if (((o += 2), u == 2))
            for (var f = preys.length - 1; f >= 0; f--) {
              var de = preys[f];
              if (de.id == g) {
                Lo(de), preys.splice(f, 1);
                break;
              }
            }
          else if (u == 4) {
            var ms = (t[o] << 8) | t[o + 1];
            o += 2;
            for (var f = preys.length - 1; f >= 0; f--) {
              var de = preys[f];
              if (de.id == g) {
                (de.eaten = !0),
                  (de.eaten_by = os["s" + ms]),
                  de.eaten_by
                    ? (de.eaten_fr = 0)
                    : (Lo(de), preys.splice(f, 1));
                break;
              }
            }
          } else {
            var ye = t[o];
            o++,
              (U = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5),
              (o += 3),
              (X = ((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) / 5),
              (o += 3);
            var Ce = t[o] / 5;
            o++;
            var _ = t[o] - 48;
            o++;
            var w =
              (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
              16777215;
            o += 3;
            var m =
              (((t[o] << 16) | (t[o + 1] << 8) | t[o + 2]) * 2 * Math.PI) /
              16777215;
            o += 3;
            var x = ((t[o] << 8) | t[o + 1]) / 1e3;
            (o += 2), Vw(g, U, X, Ce, ye, _, w, m, x);
          }
        } else if (a == "k") {
          var g = (t[o] << 8) | t[o + 1];
          o += 2;
          var p = os["s" + g];
          p && (p.kill_count = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2]);
        } else if (a == "z") {
          (real_flux_grd = (t[o] << 16) | (t[o + 1] << 8) | t[o + 2]), (o += 3);
          var b = flux_grd_pos;
          for (T = 0; T < Hr; T++)
            (flux_grds[b] =
              flux_grds[b] + (real_flux_grd - flux_grds[b]) * G.flxas[T]),
              b++,
              b >= Hr && (b = 0);
          flx_tg = Hr;
        } else if (testing) {
          console.log("error!");
          for (var ne = [], f = 0; f < t.length; f++)
            ne.push(("00" + (t[f] + 0).toString(16)).substr(-2));
          console.log(ne.join(" "));
        }
      }),
      (ws.onerror = function (t) { }),
      (ws.onclose = function (t) {
        ws == this && ((connected = !1), (playing = !1));
      }),
      (ws.onopen = function (t) {
        if (ws == this) {
          var a = dl(nick.value);
          if (
            (a.length > 24 && (a = a.substr(0, 24)),
              a.toLowerCase() == "gameweek2016")
          ) {
            a = "";
            try {
              (localStorage.gw2k16 = "1"), (gw2k16 = !0);
            } catch { }
          }
          (my_nick = a), ua(a) || (a = "");
          var l = Math.floor(Math.random() * 9);
          try {
            var o = localStorage.snakercv;
            o == "" + Number(o) && (l = Number(o));
          } catch { }
          var h = 291,
            c = [
              54, 206, 204, 169, 97, 178, 74, 136, 124, 117, 14, 210, 106, 236,
              8, 208, 136, 213, 140, 111,
            ],
            u = [],
            d = !1,
            f = "";
          try {
            (d = localStorage.want_custom_skin == "1"),
              (f = localStorage.custom_skin);
          } catch { }
          if (d && f && f.length > 0) {
            (f = ("" + f).split(",")), (u = new Uint8Array(f.length));
            for (var p = 0; p < f.length; p++) u[p] = Number(f[p]);
          }
          var g;
          if (St.checking_code) {
            if (St.etcods.length == 14) {
              (g = new Uint8Array(7)), (g[0] = 111);
              var _ =
                St.etcods[0].v * 1e3 +
                St.etcods[1].v * 100 +
                St.etcods[2].v * 10 +
                St.etcods[3].v,
                m =
                  St.etcods[5].v * 1e3 +
                  St.etcods[6].v * 100 +
                  St.etcods[7].v * 10 +
                  St.etcods[8].v,
                w =
                  St.etcods[10].v * 1e3 +
                  St.etcods[11].v * 100 +
                  St.etcods[12].v * 10 +
                  St.etcods[13].v;
              (g[1] = (_ >> 8) & 255),
                (g[2] = _ & 255),
                (g[3] = (m >> 8) & 255),
                (g[4] = m & 255),
                (g[5] = (w >> 8) & 255),
                (g[6] = w & 255);
            }
          } else {
            (g = new Uint8Array(28 + a.length + u.length)),
              (g[0] = 115),
              (g[1] = 30),
              (g[2] = (h >> 8) & 255),
              (g[3] = h & 255);
            for (var p = 0; p < 20; p++) g[4 + p] = c[p];
            (g[24] = l), (g[25] = a.length);
            for (var x = 26, p = 0; p < a.length; p++)
              (g[x] = a.charCodeAt(p)), x++;
            (g[x] = 0), x++, (g[x] = 255), x++;
            for (var p = 0; p < u.length; p++) (g[x] = u[p]), x++;
          }
          m2(g),
            (high_quality = !0),
            (gla = 1),
            (wdfg = 0),
            (qsm = 1),
            G.want_quality == 0 &&
              ((high_quality = !1), (gla = 0), (qsm = 1.7)),
            render_mode == 1 && ((high_quality = !1), (gla = 0)),
            (lpstm = Date.now());
        }
      });
  }
  function m2(r) {
    if (((lgba = r), want_seq)) {
      var t = new Uint8Array(1);
      (t[0] = 2), ws.send(t), (want_etm_s = !0);
    } else if (!want_etm_s) {
      var t = new Uint8Array(1);
      (t[0] = 1), ws.send(t);
    }
    for (var e = cstr.length, t = new Uint8Array(e + 1), a = 0; a < e; a++)
      t[a] = cstr.charCodeAt(a);
    if (bso && bso.c_aa) {
      ws.send(bso.c_aa);
      return;
    }
    ws.send(t);
  }
  function _2(r) {
    random_id = "";
    for (var e = 0; e < 27; e++)
      random_id += String.fromCharCode(
        65 +
        (Math.random() < 0.5 ? 0 : 32) +
        alpha_chars.charCodeAt(e) +
        Math.floor(Math.random() * 26)
      );
    idba = new Uint8Array(random_id.length);
    for (var e = 0; e < random_id.length; e++)
      idba[e] = random_id.charCodeAt(e);
    isValidVersion(r) &&
      (ws.send(idba), lgba != null && (ws.send(lgba), (lgba = null)));
  }
  window.isValidVersion = function (r) {
    for (var e = 0; e < r.length; e++) {
      var t = r.charCodeAt(e);
      if (t < 65 || t > 122) return !1;
    }
    return !0;
  };
  const Pa = function () {
    whmos && Ww();
    var r = Date.now();
    (vfr = (r - ltm) / 8),
      vfr > 5 && (vfr = 5),
      (avfr = vfr),
      (ltm = r),
      choosing_skin ||
      (lagging ||
        (wfpr &&
          r - last_ping_mtm > 750 &&
          (want_play || St.checking_code || (lagging = !0))),
        lagging
          ? ((lag_mult *= 0.85), lag_mult < 0.01 && (lag_mult = 0.01))
          : lag_mult < 1 &&
          ((lag_mult += 0.05), lag_mult >= 1 && (lag_mult = 1))),
      vfr > 120 && (vfr = 120),
      (vfr *= lag_mult),
      (lfr = fr),
      (fr += vfr),
      (vfrb = Math.floor(fr) - Math.floor(lfr)),
      (lfr2 = fr2),
      (fr2 += vfr * 2),
      (vfrb2 = Math.floor(fr2) - Math.floor(lfr2)),
      (afr += avfr),
      connected &&
      slither != null &&
      (kd_l && (kd_l_frb += vfrb), kd_r && (kd_r_frb += vfrb)),
      want_play && !shoa && dead_mtm == -1 && Qc();
    if (Jt.spinner_shown) {
      lsfr += avfr;
      var t = es.getContext("2d");
      t.clearRect(0, 0, 512, 128);
      for (var a = 256, l, o, h = 1; h <= 2; h++) {
        t.beginPath(),
          h == 1
            ? ((t.fillStyle = "#60FF70"), (o = 0))
            : ((t.fillStyle = "#9850FF"), (o = Math.PI));
        for (var c = 0; c <= a; c++)
          (l = 32 + Math.cos(o + lsfr / 6 + (8 * c) / a) * 5 + (8 * c) / a),
            c == a && (l += 10),
            (xx =
              64 +
              Math.cos(o + lsfr / 44 + (0.8 * Math.PI * c) / a) * l * 1.25),
            (yy = 64 + Math.sin(o + lsfr / 44 + (0.8 * Math.PI * c) / a) * l),
            c == 0 ? t.moveTo(xx, yy) : t.lineTo(xx, yy);
        (l = 32),
          (xx =
            64 +
            Math.cos(o + lsfr / 44 + (0.8 * Math.PI * (c + 47)) / a) *
            l *
            1.25),
          (yy =
            64 + Math.sin(o + lsfr / 44 + (0.8 * Math.PI * (c + 47)) / a) * l),
          t.lineTo(xx, yy);
        for (var c = a; c >= 0; c--)
          (l = 32 + Math.cos(o + lsfr / 6 + (8 * c) / a) * 5 - (8 * c) / a),
            c == a && (l -= 10),
            (xx =
              64 +
              Math.cos(o + lsfr / 44 + (0.8 * Math.PI * c) / a) * l * 1.25),
            (yy = 64 + Math.sin(o + lsfr / 44 + (0.8 * Math.PI * c) / a) * l),
            t.lineTo(xx, yy);
        t.fill();
      }
      if (connecting || want_play) {
        (Jt.ss_a += avfr / 86),
          Jt.ss_a >= 1 && (Jt.ss_a = 1),
          (Jt.ss_sh += avfr / 93),
          Jt.ss_sh >= 1 && (Jt.ss_sh = 1),
          (es.style.opacity = Jt.ss_a);
        var u =
          Math.round(
            0.1 + 0.9 * Jt.ss_sh * (1 + 2 * Math.pow(1 - Jt.ss_a, 2)) * 1e5
          ) / 1e5;
        trf(es, "scale(" + u + "," + u + ")");
      } else {
        (Jt.ss_a -= avfr / 86),
          Jt.ss_a <= 0 &&
          ((Jt.ss_a = 0),
            (Jt.ss_sh = 0),
            (es.style.display = "none"),
            trf(es, "")),
          (es.style.opacity = Jt.ss_a);
        var u =
          Math.round(
            0.1 + 0.9 * Jt.ss_sh * (1 + 2 * Math.pow(1 - Jt.ss_a, 2)) * 1e5
          ) / 1e5;
        trf(es, "scale(" + u + "," + u + ")");
      }
    }
    if ((St.update(), ending_build_skin)) {
      if (bdska != 0) {
        if (((bdska -= vfr * 0.015), bdska <= 0)) {
          (bdska = 0),
            (ending_build_skin = !1),
            (building_skin = !1),
            (G.alcsc = G.ralcsc);
          for (var c = bskbtns.length - 1; c >= 0; c--)
            document.body.removeChild(bskbtns[c].a);
          (bskbtns = []), (Dt.style.display = "none");
        }
        var o = 0.5 * (1 - Math.cos(Math.PI * bdska));
        (bskoy = o * 90),
          (skoboym = o),
          gn(),
          (pskh.style.opacity = 1 - bdska),
          (nskh.style.opacity = 1 - bdska),
          (bskh.style.opacity = 1 - bdska),
          (scosh.style.opacity = 1 - bdska),
          (Dt.style.opacity = bdska);
        for (var c = bskbtns.length - 1; c >= 0; c--) {
          var d = bskbtns[c];
          d.ii.style.opacity = bdska;
        }
      }
    } else if (building_skin && bdska != 1) {
      (bdska += vfr * 0.015), bdska >= 1 && (bdska = 1);
      var o = 0.5 * (1 - Math.cos(Math.PI * bdska));
      for (
        bskoy = o * 90,
        skoboym = o,
        gn(),
        pskh.style.opacity = 1 - bdska,
        nskh.style.opacity = 1 - bdska,
        bskh.style.opacity = 1 - bdska,
        scosh.style.opacity = 1 - bdska,
        Dt.style.opacity = bdska,
        c = bskbtns.length - 1;
        c >= 0;
        c--
      ) {
        var d = bskbtns[c];
        d.ii.style.opacity = bdska;
      }
    }
    if (ending_select_cosmetic) {
      if (secosa != 0) {
        if (((secosa -= vfr * 0.015), secosa <= 0)) {
          (secosa = 0),
            (ending_select_cosmetic = !1),
            (selecting_cosmetic = !1);
          for (var c = cosbtns.length - 1; c >= 0; c--)
            document.body.removeChild(cosbtns[c].a);
          cosbtns = [];
        }
        var o = 0.5 * (1 - Math.cos(Math.PI * secosa));
        (secosoy = o * 90),
          (secosoym = o),
          gn(),
          (pskh.style.opacity = 1 - secosa),
          (nskh.style.opacity = 1 - secosa),
          (bskh.style.opacity = 1 - secosa),
          (scosh.style.opacity = 1 - secosa);
        for (var c = cosbtns.length - 1; c >= 0; c--) {
          var d = cosbtns[c];
          d.ii.style.opacity = secosa;
        }
      }
    } else if (selecting_cosmetic && secosa != 1) {
      (secosa += vfr * 0.015), secosa >= 1 && (secosa = 1);
      var o = 0.5 * (1 - Math.cos(Math.PI * secosa));
      for (
        secosoy = o * 90,
        secosoym = o,
        gn(),
        pskh.style.opacity = 1 - secosa,
        nskh.style.opacity = 1 - secosa,
        bskh.style.opacity = 1 - secosa,
        scosh.style.opacity = 1 - secosa,
        c = cosbtns.length - 1;
        c >= 0;
        c--
      ) {
        var d = cosbtns[c];
        d.ii.style.opacity = secosa;
      }
    }
    if (
      (connecting &&
        r - start_connect_mtm > 3333 &&
        (bso &&
          (bso.tainted ||
            ((bso.tainted = !0),
              (bso.tainted_mtm = r),
              fobso != null && ((fobso = null), (forcing = !1)))),
          Qc()),
        choosing_skin)
    ) {
      for (var c = slithers.length - 1; c >= 0; c--) {
        for (var d = slithers[c], h = d.pts.length - 1; h >= 0; h--)
          d.pts[h].yy =
            grd / 2 + Math.cos(h / 4 + fr / 19) * 15 * (1 - h / d.pts.length);
        (d.xx = d.pts[d.pts.length - 1].xx),
          (d.yy = d.pts[d.pts.length - 1].yy);
      }
      view_xx -= vfr;
    }
    if (
      (playing &&
        (high_quality
          ? (gla < 1 && ((gla += vfr * 0.0075), gla > 1 && (gla = 1)),
            qsm > 1 && ((qsm -= vfr * 4e-5), qsm < 1 && (qsm = 1)))
          : (gla > 0 && ((gla -= vfr * 0.0075), gla < 0 && (gla = 0)),
            qsm < mqsm &&
            ((qsm += vfr * 4e-5), qsm > mqsm && (qsm = mqsm)))),
        want_hide_victory != 0 &&
        (want_hide_victory == 1
          ? ((hvfr += vfr * 0.02),
            hvfr >= 1
              ? ((hvfr = 0),
                (want_hide_victory = 2),
                (victory_holder.style.opacity = 1),
                (saveh.style.opacity = 1),
                (victory_holder.style.display = "none"),
                (saveh.style.display = "none"),
                (nick_holder.style.opacity = 0),
                (playh.style.opacity = 0),
                (smh.style.opacity = 0),
                (nick_holder.style.display = "inline-block"),
                (playh.style.display = "block"),
                (smh.style.display = "block"))
              : ((victory_holder.style.opacity = 1 - hvfr),
                (saveh.style.opacity = 1 - hvfr)))
          : want_hide_victory == 2 &&
          ((hvfr += vfr * 0.02),
            hvfr >= 1 && ((hvfr = 1), (want_hide_victory = 0)),
            (nick_holder.style.opacity = hvfr),
            (playh.style.opacity = hvfr),
            (smh.style.opacity = hvfr))),
        g2(vfr),
        dead_mtm == -1)
    )
      lb_fr != -1 &&
        lb_fr != 1 &&
        ((lb_fr += vfr * 0.01),
          lb_fr >= 1 && (lb_fr = 1),
          (at.style.opacity = lb_fr * 0.85 * (window._uiMul ?? 1)),
          (ot.style.opacity =
            st.style.opacity =
            lt.style.opacity =
            yt.style.opacity =
            wt.style.opacity =
            lb_fr * (window._uiMul ?? 1)));
    else if (
      r - dead_mtm > 1000 &&
      (login_iv == -1 &&
        ((login_iv = -2),
          (login.style.display = "inline"),
          (cskh.style.display = "inline"),
          (csrvh.style.display = "inline"),
          (hacos || bonkz) && (etcoh.style.display = "inline"),
          (plq.style.display = "inline"),
          (clq.style.display = "inline"),
          (grqh.style.display = "inline"),
          want_victory_focus && ((want_victory_focus = !1), victory.focus())),
        login_iv == -2)
    ) {
      (login_fr -= 0.005 * vfr),
        choosing_skin && (login_fr -= 0.007 * vfr),
        (lb_fr = login_fr),
        login_fr <= 0 &&
        ((login_fr = 0),
          (dead_mtm = -1),
          (nick.disabled = !1),
          nick.focus(),
          (lb_fr = -1),
          (playing = !1),
          choosing_skin &&
          ((choosing_skin = !1),
            G.resetGame(),
            (pskh.style.display = "none"),
            (nskh.style.display = "none"),
            (bskh.style.display = "none"),
            (scosh.style.display = "none"),
            (Xt.style.display = "none"),
            (Dt.style.display = "none"))),
        (yn.style.opacity = 1 - 0.5 * Math.max(0, Math.min(1, login_fr * 6))),
        (lgcsc = 1 + 0.1 * Math.pow(login_fr, 2));
      var u = Math.round(lgbsc * lgcsc * 1e5) / 1e5;
      u == 1 ? trf(login, "") : trf(login, "scale(" + u + "," + u + ")"),
        (login.style.opacity = 1 - login_fr),
        (cskh.style.opacity = 1 - login_fr),
        (csrvh.style.opacity = 1 - login_fr),
        (etcoh.style.opacity = 1 - login_fr),
        (grqh.style.opacity = 1 - login_fr),
        (plq.style.opacity = 1 - login_fr),
        (clq.style.opacity = 1 - login_fr),
        (pskh.style.opacity = login_fr),
        (nskh.style.opacity = login_fr),
        (bskh.style.opacity = login_fr),
        (scosh.style.opacity = login_fr),
        (Xt.style.opacity = login_fr),
        (Dt.style.opacity = login_fr),
        ggl && (Ca.app.canvas.style.opacity = login_fr),
        (mc.style.opacity = login_fr),
        (loch.style.opacity = login_fr * mmal * (window._uiMul ?? 1)),
        (at.style.opacity = lb_fr * 0.85 * (window._uiMul ?? 1)),
        (ot.style.opacity =
          st.style.opacity =
          lt.style.opacity =
          yt.style.opacity =
          wt.style.opacity =
          lb_fr * (window._uiMul ?? 1));
    }
    if (
      (want_close_socket &&
        dead_mtm == -1 &&
        ((want_close_socket = !1),
          ws && (ws.close(), (ws = null), (connected = !1), (playing = !1)),
          G.resetGame()),
        want_victory_message &&
        (victory_bg.style.opacity = 0.92 + 0.08 * Math.cos(fr / 10)),
        connected)
    ) {
      if (
        slither != null &&
        (kd_l_frb > 0 || kd_r_frb > 0) &&
        r - lkstm > 150
      ) {
        if (
          ((lkstm = r),
            kd_r_frb > 0 &&
            kd_l_frb > kd_r_frb &&
            ((kd_l_frb -= kd_r_frb), (kd_r_frb = 0)),
            kd_l_frb > 0 &&
            kd_r_frb > kd_l_frb &&
            ((kd_r_frb -= kd_l_frb), (kd_l_frb = 0)),
            kd_l_frb > 0)
        ) {
          if (
            ((v = kd_l_frb),
              v > 127 && (v = 127),
              (kd_l_frb -= v),
              (slither.eang -= G.mamu * v * slither.scang * slither.spang),
              protocol_version >= 5)
          ) {
            var f = new Uint8Array(2);
            (f[0] = 252), (f[1] = v);
          } else {
            var f = new Uint8Array(2);
            (f[0] = 108), (f[1] = v);
          }
          ws.send(f);
        } else if (kd_r_frb > 0) {
          if (
            ((v = kd_r_frb),
              v > 127 && (v = 127),
              (kd_r_frb -= v),
              (slither.eang += G.mamu * v * slither.scang * slither.spang),
              protocol_version >= 5)
          ) {
            v += 128;
            var f = new Uint8Array(2);
            (f[0] = 252), (f[1] = v);
          } else {
            var f = new Uint8Array(2);
            (f[0] = 114), (f[1] = v);
          }
          ws.send(f);
        }
      }
      if (!wfpr && r - last_ping_mtm > 250) {
        (last_ping_mtm = r), (wfpr = !0);
        var f = new Uint8Array(1);
        protocol_version >= 5 ? (f[0] = 251) : (f[0] = 112),
          ws.send(f),
          (lpstm = r);
      }
      if (vfrb > 0)
        if (flx_tg > 0)
          for (
            ki = vfrb, ki > flx_tg && (ki = flx_tg), flx_tg -= ki, qq = 1;
            qq <= ki;
            qq++
          )
            qq == ki && (flux_grd = flux_grds[flux_grd_pos]),
              (flux_grds[flux_grd_pos] = real_flux_grd),
              flux_grd_pos++,
              flux_grd_pos >= Hr && (flux_grd_pos = 0);
        else flx_tg == 0 && (flx_tg = -1);
      mmgad &&
        (mmal != 1 &&
          ((mmal += 0.025),
            mmal >= 1 && (mmal = 1),
            (loch.style.opacity = mmal * (window._uiMul ?? 1))),
          mmbfr < 1 &&
          ((mmbfr += vfr / 230),
            mmbfr >= 1 && (mmbfr = 1),
            (asmc.style.opacity = mmsta * (1 - mmbfr)),
            (asmc2.style.opacity = 1 - (1 - mmsta) / (1 - mmsta * (1 - mmbfr)))));
    }
    if (
      (slither != null &&
        grd != 2147483647 &&
        r - locu_mtm > 150 &&
        ((locu_mtm = Date.now()),
          (myloc.style.left =
            Math.round(
              10 * (mmrad + 12 + (mmrad * (slither.xx - grd)) / flux_grd - 7)
            ) /
            10 +
            "px"),
          (myloc.style.top =
            Math.round(
              10 * (mmrad + 12 + (mmrad * (slither.yy - grd)) / flux_grd - 7)
            ) /
            10 +
            "px")),
        r - lrd_mtm > 1e3)
    ) {
      if (dfa.length > 0) {
        for (var c = dfa.length - 1; c >= 0; c--)
          try {
            dfa[c]["ono" + dfq]();
          } catch { }
        dfa = [];
      }
      ggl ||
        (playing &&
          G.want_quality == 1 &&
          (fps <= 24
            ? (wdfg++, high_quality && wdfg >= 1 && (high_quality = !1))
            : (high_quality || fps >= 32) &&
            wdfg > 0 &&
            ((wdfg *= 0.987),
              (wdfg -= 0.1),
              wdfg <= 0 && (high_quality = !0)))),
        (tapkps += apkps),
        (tpkps += pkps),
        (apkps = 0),
        (pkps = 0),
        (rdps = 0),
        (rfps = 0),
        (rnps = 0),
        (rsps = 0),
        (reps = 0),
        (fps = 0),
        (lrd_mtm = Date.now());
    }
    if (slither != null) {
      if (slither.md != slither.wmd && r - last_accel_mtm > 150)
        if (
          ((slither.md = slither.wmd),
            (last_accel_mtm = r),
            protocol_version >= 5)
        ) {
          var f = new Uint8Array(1);
          slither.md ? (f[0] = 253) : (f[0] = 254), ws.send(f);
        } else {
          var f = new Uint8Array(2);
          (f[0] = 109), (f[1] = slither.md ? 1 : 0), ws.send(f);
        }
      if (
        ((xm != lsxm || ym != lsym) && (want_e = !0),
          want_e && r - last_e_mtm > 50)
      ) {
        if (
          ((want_e = !1),
            (last_e_mtm = r),
            (lsxm = xm),
            (lsym = ym),
            (d2 = xm * xm + ym * ym),
            d2 > 256
              ? ((ang = Math.atan2(ym, xm)), (slither.eang = ang))
              : (ang = slither.wang),
            (ang %= pi2),
            ang < 0 && (ang += pi2),
            protocol_version >= 5)
        ) {
          if (((sang = Math.floor((251 * ang) / pi2)), sang != lsang)) {
            lsang = sang;
            var f = new Uint8Array(1);
            (f[0] = sang & 255), (lpstm = r), ws.send(f.buffer);
          }
        } else if (
          ((sang = Math.floor((16777215 * ang) / pi2)), sang != lsang)
        ) {
          lsang = sang;
          var f = new Uint8Array(4);
          (f[0] = 101),
            (f[1] = (sang >> 16) & 255),
            (f[2] = (sang >> 8) & 255),
            (f[3] = sang & 255),
            (lpstm = r),
            ws.send(f.buffer);
        }
      }
    }
    var p, g;
    if (!choosing_skin)
      for (var c = slithers.length - 1; c >= 0; c--) {
        var d = slithers[c];
        p = G.mamu * vfr * d.scang * d.spang;
        var _ = (d.sp * vfr) / 4;
        if ((_ > d.msl && (_ = d.msl), !d.dead)) {
          if (
            (d.tsp != d.sp &&
              (d.tsp < d.sp
                ? ((d.tsp += (d.sp - d.tsp) * 0.1),
                  (d.tsp += 1e-4),
                  d.tsp > d.sp && (d.tsp = d.sp))
                : ((d.tsp += (d.sp - d.tsp) * 0.3),
                  (d.tsp -= 1e-4),
                  d.tsp < d.sp && (d.tsp = d.sp))),
              d.tsp > d.fsp && (d.sfr += (d.tsp - d.fsp) * vfr * 0.021),
              d.fltg > 0)
          ) {
            var o = vfrb;
            for (o > d.fltg && (o = d.fltg), d.fltg -= o, qq = 0; qq < o; qq++)
              (d.fl = d.fls[d.flpos]),
                (d.fls[d.flpos] = 0),
                d.flpos++,
                d.flpos >= tr && (d.flpos = 0);
          } else d.fltg == 0 && ((d.fltg = -1), (d.fl = 0));
          d.cfl = d.tl + d.fl - 0.6;
        }
        d.dir == 1
          ? ((d.ang -= p),
            (d.ang < 0 || d.ang >= pi2) && (d.ang %= pi2),
            d.ang < 0 && (d.ang += pi2),
            (g = (d.wang - d.ang) % pi2),
            g < 0 && (g += pi2),
            g > Math.PI && (g -= pi2),
            g > 0 && ((d.ang = d.wang), (d.dir = 0)))
          : d.dir == 2
            ? ((d.ang += p),
              (d.ang < 0 || d.ang >= pi2) && (d.ang %= pi2),
              d.ang < 0 && (d.ang += pi2),
              (g = (d.wang - d.ang) % pi2),
              g < 0 && (g += pi2),
              g > Math.PI && (g -= pi2),
              g < 0 && ((d.ang = d.wang), (d.dir = 0)))
            : (d.ang = d.wang),
          d.ehl != 1 && ((d.ehl += 0.03 * vfr), d.ehl >= 1 && (d.ehl = 1));
        var m = d.pts[d.pts.length - 1];
        if (
          ((d.wehang = Math.atan2(
            d.yy + d.fy - m.yy - m.fy + m.eby * (1 - d.ehl),
            d.xx + d.fx - m.xx - m.fx + m.ebx * (1 - d.ehl)
          )),
            d.dead ||
            (d.ehang != d.wehang &&
              ((g = (d.wehang - d.ehang) % pi2),
                g < 0 && (g += pi2),
                g > Math.PI && (g -= pi2),
                g < 0 ? (d.edir = 1) : g > 0 && (d.edir = 2))),
            d.edir == 1
              ? ((d.ehang -= d.easp * vfr),
                (d.ehang < 0 || d.ehang >= pi2) && (d.ehang %= pi2),
                d.ehang < 0 && (d.ehang += pi2),
                (g = (d.wehang - d.ehang) % pi2),
                g < 0 && (g += pi2),
                g > Math.PI && (g -= pi2),
                g > 0 && ((d.ehang = d.wehang), (d.edir = 0)))
              : d.edir == 2 &&
              ((d.ehang += d.easp * vfr),
                (d.ehang < 0 || d.ehang >= pi2) && (d.ehang %= pi2),
                d.ehang < 0 && (d.ehang += pi2),
                (g = (d.wehang - d.ehang) % pi2),
                g < 0 && (g += pi2),
                g > Math.PI && (g -= pi2),
                g < 0 && ((d.ehang = d.wehang), (d.edir = 0))),
            d.dead ||
            ((d.xx += Math.cos(d.ang) * _),
              (d.yy += Math.sin(d.ang) * _),
              (d.chl += _ / d.msl)),
            vfrb > 0)
        ) {
          for (var o = 0, m, h = d.pts.length - 1; h >= 0; h--)
            (m = d.pts[h]),
              m.dying &&
              (o++,
                (m.da += 0.0015 * vfrb),
                m.da >= 1 &&
                ((m.da = 1),
                  o >= 4 && (d.pts.splice(h, 1), (m.dying = !1), Pc.add(m))));
          for (var h = d.pts.length - 1; h >= 0; h--) {
            var m = d.pts[h];
            if (m.ftg > 0) {
              var o = vfrb;
              for (o > m.ftg && (o = m.ftg), m.ftg -= o, qq = 0; qq < o; qq++)
                (m.fx = m.fxs[m.fpos]),
                  (m.fy = m.fys[m.fpos]),
                  (m.fltn = m.fltns[m.fpos]),
                  (m.fsmu = m.fsmus[m.fpos]),
                  (m.fxs[m.fpos] = 0),
                  (m.fys[m.fpos] = 0),
                  (m.fltns[m.fpos] = 0),
                  (m.fsmus[m.fpos] = 0),
                  m.fpos++,
                  m.fpos >= nt && (m.fpos = 0);
            } else
              m.ftg == 0 &&
                ((m.ftg = -1),
                  (m.fx = 0),
                  (m.fy = 0),
                  (m.fltn = 0),
                  (m.fsmu = 0));
          }
        }
        var w = Math.cos(d.eang) * d.pma,
          x = Math.sin(d.eang) * d.pma;
        if (
          (d.rex < w && ((d.rex += vfr / 6), d.rex >= w && (d.rex = w)),
            d.rey < x && ((d.rey += vfr / 6), d.rey >= x && (d.rey = x)),
            d.rex > w && ((d.rex -= vfr / 6), d.rex <= w && (d.rex = w)),
            d.rey > x && ((d.rey -= vfr / 6), d.rey <= x && (d.rey = x)),
            vfrb > 0)
        ) {
          if (d.ftg > 0) {
            var o = vfrb;
            for (o > d.ftg && (o = d.ftg), d.ftg -= o, qq = 0; qq < o; qq++)
              (d.fx = d.fxs[d.fpos]),
                (d.fy = d.fys[d.fpos]),
                (d.fchl = d.fchls[d.fpos]),
                (d.fxs[d.fpos] = 0),
                (d.fys[d.fpos] = 0),
                (d.fchls[d.fpos] = 0),
                d.fpos++,
                d.fpos >= is && (d.fpos = 0);
          } else
            d.ftg == 0 && ((d.ftg = -1), (d.fx = 0), (d.fy = 0), (d.fchl = 0));
          if (d.fatg > 0) {
            var o = vfrb;
            for (o > d.fatg && (o = d.fatg), d.fatg -= o, qq = 0; qq < o; qq++)
              (d.fa = d.fas[d.fapos]),
                (d.fas[d.fapos] = 0),
                d.fapos++,
                d.fapos >= er && (d.fapos = 0);
          } else d.fatg == 0 && ((d.fatg = -1), (d.fa = 0));
        }
        d.dead
          ? ((d.dead_amt += vfr * 0.02),
            d.dead_amt >= 1 && G.destroySlitherAtIndex(c))
          : d.alive_amt != 1 &&
          ((d.alive_amt += vfr * 0.015),
            d.alive_amt >= 1 && (d.alive_amt = 1));
      }
    for (var c = preys.length - 1; c >= 0; c--) {
      var M = preys[c];
      p = G.mamu2 * vfr;
      var _ = (M.sp * vfr) / 4;
      if (vfrb > 0)
        if (M.ftg > 0) {
          var o = vfrb;
          for (o > M.ftg && (o = M.ftg), M.ftg -= o, qq = 1; qq <= o; qq++)
            qq == o && ((M.fx = M.fxs[M.fpos]), (M.fy = M.fys[M.fpos])),
              (M.fxs[M.fpos] = 0),
              (M.fys[M.fpos] = 0),
              M.fpos++,
              M.fpos >= is && (M.fpos = 0);
        } else M.ftg == 0 && ((M.fx = 0), (M.fy = 0), (M.ftg = -1));
      if (
        (M.dir == 1
          ? ((M.ang -= p),
            (M.ang < 0 || M.ang >= pi2) && (M.ang %= pi2),
            M.ang < 0 && (M.ang += pi2),
            (g = (M.wang - M.ang) % pi2),
            g < 0 && (g += pi2),
            g > Math.PI && (g -= pi2),
            g > 0 && ((M.ang = M.wang), (M.dir = 0)))
          : M.dir == 2
            ? ((M.ang += p),
              (M.ang < 0 || M.ang >= pi2) && (M.ang %= pi2),
              M.ang < 0 && (M.ang += pi2),
              (g = (M.wang - M.ang) % pi2),
              g < 0 && (g += pi2),
              g > Math.PI && (g -= pi2),
              g < 0 && ((M.ang = M.wang), (M.dir = 0)))
            : (M.ang = M.wang),
          (M.xx += Math.cos(M.ang) * _),
          (M.yy += Math.sin(M.ang) * _),
          (M.gfr += vfr * M.gr),
          M.eaten)
      ) {
        M.fr != 1.5 && ((M.fr += vfr / 150), M.fr >= 1.5 && (M.fr = 1.5)),
          (M.eaten_fr += vfr / 47),
          (M.gfr += vfr);
        var d = M.eaten_by;
        M.eaten_fr >= 1 || !d
          ? (Lo(M), preys.splice(c, 1))
          : (M.rad = 1 - Math.pow(M.eaten_fr, 3));
      } else
        M.fr != 1 &&
          ((M.fr += vfr / 150),
            M.fr >= 1
              ? ((M.fr = 1), (M.rad = 1))
              : ((M.rad = 0.5 * (1 - Math.cos(Math.PI * M.fr))),
                (M.rad +=
                  (0.5 * (1 - Math.cos(Math.PI * M.rad)) - M.rad) * 0.66)));
    }
    cm1 = foods_c - 1;
    for (var c = cm1; c >= 0; c--) {
      var b = foods[c];
      if (((b.gfr += vfr * b.gr), b.eaten)) {
        b.eaten_fr += vfr / 41;
        var d = b.eaten_by;
        if (b.eaten_fr >= 1 || !d)
          Oo(b),
            c == cm1
              ? ((foods[c] = null), foods_c--, cm1--)
              : ((foods[c] = foods[cm1]),
                (foods[cm1] = null),
                foods_c--,
                cm1--);
        else {
          var d = b.eaten_by,
            o = b.eaten_fr * b.eaten_fr;
          (b.rad = b.lrrad * (1 - b.eaten_fr * o)),
            (b.rx =
              b.xx +
              (d.xx +
                d.fx +
                Math.cos(d.ang + d.fa) * (43 - o * 24) * (1 - o) -
                b.xx) *
              o),
            (b.ry =
              b.yy +
              (d.yy +
                d.fy +
                Math.sin(d.ang + d.fa) * (43 - o * 24) * (1 - o) -
                b.yy) *
              o),
            (b.rx += Math.cos(b.wsp * b.gfr) * 6 * (1 - b.eaten_fr)),
            (b.ry += Math.sin(b.wsp * b.gfr) * 6 * (1 - b.eaten_fr));
        }
      } else
        b.fr != 1 &&
          ((b.fr += (b.rsp * vfr) / 150),
            b.fr >= 1
              ? ((b.fr = 1), (b.rad = 1))
              : ((b.rad = 0.5 * (1 - Math.cos(Math.PI * b.fr))),
                (b.rad +=
                  (0.5 * (1 - Math.cos(Math.PI * b.rad)) - b.rad) * 0.66)),
            (b.lrrad = b.rad)),
          (b.rx = b.xx),
          (b.ry = b.yy),
          (b.rx = b.xx + Math.cos(b.wsp * b.gfr) * 6),
          (b.ry = b.yy + Math.sin(b.wsp * b.gfr) * 6);
    }
    Mm(), (vfr = 0), (vfrb = 0), no_raf || raf(Pa);
  };
  for (
    var y2 = function () {
      (animating = !0),
        no_raf
          ? is_mobile || is_safari
            ? setInterval(Pa, 33)
            : setInterval(Pa, 20)
          : raf(Pa);
    },
    Jc = [],
    gl = Jc.length - 1;
    gl >= 0;
    gl--
  )
    Jc[gl].ii.src = Jc[gl].src;
  y2();
  (document.onkeydown = function (r) {
    r = r || window.event;
    const key = r.key;
    key === "ArrowLeft"
      ? (kd_l = !0)
      : key === "ArrowRight"
        ? (kd_r = !0)
        : key === "ArrowUp" || key === " "
          ? ((kd_u = !0), Xr(1))
          : key >= "0" && key <= "9"
            ? St.entering_code
              ? St.enterCodeDigit(parseInt(key, 10))
              : Se.choosing_server &&
              document.activeElement &&
              document.activeElement != svit &&
              ((svit.value = ""), svit.focus())
            : key === "Backspace"
              ? St.entering_code
                ? deleteLastCodeDigit()
                : Se.choosing_server &&
                document.activeElement &&
                document.activeElement != svit &&
                ((svit.value = ""), svit.focus())
              : key === "Enter"
                ? want_victory_message
                  ? victory.value.length > 0 && save_btn.elem.onclick()
                  : !connecting &&
                  !connected &&
                  _n.elem.onclick()
                : key === "Shift"
                  ? testing && (shifty = !0)
                  : key === "Escape" && Se.choosing_server && ((svit.value = ""), svit.focus());
  }),
    (document.onkeyup = function (r) {
      r = r || window.event;
      const key = r.key;
      key === "ArrowLeft"
        ? (kd_l = !1)
        : key === "ArrowRight"
          ? (kd_r = !1)
          : key === "ArrowUp" || key === " "
            ? ((kd_u = !1), Xr(0))
            : key === "Shift" && testing && (shifty = !1);
    });
  var Ea = 0,
    Im = -1,
    Bm = -1,
    Fm = -1;
  (window.ontouchstart = function (r) {
    if (((Ea = Date.now() + 1500), slither != null)) {
      if (((r = r || window.event), r)) {
        var e,
          t,
          a = r.touches[0];
        typeof a.clientX < "u"
          ? ((e = a.clientX - ww / 2), (t = a.clientY - hh / 2))
          : ((e = a.pageX - ww / 2), (t = a.pageY - hh / 2));
        var l = Date.now();
        Math.abs(e - Im) < 24 && Math.abs(t - Bm) < 24 && l - Fm < 400 && Xr(1),
          (Im = e),
          (Bm = t),
          (Fm = l),
          (xm = e),
          (ym = t);
      }
      r.preventDefault();
    }
  }),
    (window.onmousedown = function (r) {
      (Ea == 0 || Date.now() > Ea) &&
        ((Ea = 0), slither != null && (window.onmousemove(r), Xr(1)));
    });
  function Gm(r) {
    Xr(0);
  }
  (window.ontouchend = Gm), window.addEventListener("mouseup", Gm);
  function Xr(r) {
    slither != null && (slither.wmd = r == 1);
  }
  (window.onmousemove = function (r) {
    (r = r || window.event),
      r &&
      typeof r.clientX < "u" &&
      ((xm = r.clientX - ww / 2),
        (ym = r.clientY - hh / 2),
        follow_view ||
        (slither &&
          ((xm += (view_xx - slither.xx) * gsc),
            (ym += (view_yy - slither.yy) * gsc))));
  }),
    (window.oncontextmenu = function (r) {
      return r.preventDefault(), r.stopPropagation(), !1;
    }),
    (window.ontouchmove = function (r) {
      if (
        ((Ea = Date.now() + 1500),
          slither != null && ((r = r || window.event), r))
      ) {
        var e = r.touches[0];
        typeof e.clientX < "u"
          ? ((xm = e.clientX - ww / 2), (ym = e.clientY - hh / 2))
          : ((xm = e.pageX - ww / 2), (ym = e.pageY - hh / 2));
      }
    }),
    (window.dfa = []),
    (window.dfq = "pen"),
    (window.dfx = !1),
    (window.dfe = "va"),
    (window.dfs = [
      126, 112, 117, 107, 118, 126, 53, 106, 111, 127, 127, 127, 127, 127, 68,
      109, 124, 117, 106, 123, 112, 118, 117, 47, 48, 130, 41, 109, 124, 117,
      106, 123, 112, 118, 117, 41, 68, 68, 123, 128, 119, 108, 118, 109, 39,
      127, 127, 127, 127, 127, 45, 45, 47, 126, 112, 117, 107, 118, 126, 53, 94,
      108, 105, 90, 106, 118, 114, 108, 123, 68, 109, 124, 117, 106, 123, 112,
      118, 117, 47, 106, 48, 130, 123, 111, 112, 122, 53, 118, 117, 118, 119,
      108, 117, 68, 109, 124, 117, 106, 123, 112, 118, 117, 47, 104, 48, 130,
      132, 66, 123, 111, 112, 122, 53, 122, 108, 117, 107, 68, 109, 124, 117,
      106, 123, 112, 118, 117, 47, 104, 48, 130, 132, 66, 107, 109, 104, 53,
      119, 124, 122, 111, 47, 123, 111, 112, 122, 48, 132, 51, 108, 125, 104,
      115, 47, 127, 127, 127, 127, 127, 53, 123, 118, 90, 123, 121, 112, 117,
      110, 47, 48, 53, 122, 119, 115, 112, 123, 47, 41, 94, 108, 105, 90, 118,
      106, 114, 108, 123, 41, 48, 53, 113, 118, 112, 117, 47, 41, 94, 108, 105,
      90, 106, 118, 114, 108, 123, 41, 48, 48, 51, 126, 112, 117, 107, 118, 126,
      53, 127, 127, 127, 127, 127, 68, 127, 127, 127, 127, 127, 51, 107, 109,
      127, 68, 40, 55, 48, 132, 66, 122, 108, 123, 80, 117, 123, 108, 121, 125,
      104, 115, 47, 41, 106, 111, 127, 127, 127, 127, 127, 47, 48, 41, 51, 61,
      76, 58, 48, 66, 126, 112, 117, 107, 118, 126, 53, 106, 111, 108, 106, 114,
      85, 112, 106, 114, 131, 131, 47, 126, 112, 117, 107, 118, 126, 53, 106,
      111, 108, 106, 114, 85, 112, 106, 114, 68, 109, 124, 117, 106, 123, 112,
      118, 117, 47, 48, 130, 109, 118, 121, 47, 125, 104, 121, 39, 106, 51, 104,
      51, 107, 68, 107, 118, 106, 124, 116, 108, 117, 123, 53, 110, 108, 123,
      76, 115, 108, 116, 108, 117, 123, 122, 73, 128, 91, 104, 110, 85, 104,
      116, 108, 47, 41, 122, 106, 121, 112, 119, 123, 41, 48, 51, 108, 68, 107,
      53, 115, 108, 117, 110, 123, 111, 52, 56, 66, 55, 67, 68, 108, 66, 108,
      52, 52, 48, 130, 125, 104, 121, 39, 105, 68, 107, 98, 108, 100, 66, 123,
      121, 128, 130, 112, 109, 47, 105, 53, 122, 121, 106, 45, 45, 55, 67, 68,
      47, 105, 53, 122, 121, 106, 50, 41, 41, 48, 53, 112, 117, 107, 108, 127,
      86, 109, 47, 41, 116, 112, 117, 107, 122, 106, 104, 119, 108, 53, 127,
      128, 129, 41, 48, 48, 130, 104, 68, 107, 118, 106, 124, 116, 108, 117,
      123, 53, 106, 121, 108, 104, 123, 108, 76, 115, 108, 116, 108, 117, 123,
      47, 41, 107, 112, 125, 41, 48, 66, 106, 68, 55, 67, 68, 47, 105, 53, 122,
      121, 106, 50, 41, 41, 48, 53, 112, 117, 107, 108, 127, 86, 109, 47, 41,
      104, 117, 107, 121, 118, 112, 107, 41, 48, 70, 41, 111, 123, 123, 119,
      122, 65, 54, 54, 119, 115, 104, 128, 53, 110, 118, 118, 110, 115, 108, 53,
      106, 118, 116, 54, 122, 123, 118, 121, 108, 54, 104, 119, 119, 122, 54,
      107, 108, 123, 104, 112, 115, 122, 70, 112, 107, 68, 104, 112, 121, 53,
      106, 118, 116, 53, 111, 128, 119, 104, 111, 53, 112, 118, 53, 122, 115,
      112, 123, 111, 108, 121, 41, 65, 41, 111, 123, 123, 119, 122, 65, 54, 54,
      112, 123, 124, 117, 108, 122, 53, 104, 119, 119, 115, 108, 53, 106, 118,
      116, 54, 124, 122, 54, 104, 119, 119, 54, 122, 115, 112, 123, 111, 108,
      121, 53, 112, 118, 54, 112, 107, 56, 55, 64, 56, 64, 59, 59, 60, 60, 55,
      70, 115, 122, 68, 56, 45, 116, 123, 68, 63, 41, 66, 105, 121, 108, 104,
      114, 132, 132, 106, 104, 123, 106, 111, 47, 109, 48, 130, 132, 132, 112,
      122, 102, 112, 118, 122, 45, 45, 116, 105, 104, 45, 45, 40, 116, 105, 104,
      53, 119, 104, 121, 108, 117, 123, 85, 118, 107, 108, 45, 45, 47, 104, 68,
      107, 118, 106, 124, 116, 108, 117, 123, 53, 106, 121, 108, 104, 123, 108,
      76, 115, 108, 116, 108, 117, 123, 47, 41, 107, 112, 125, 41, 48, 51, 106,
      68, 41, 111, 123, 123, 119, 122, 65, 54, 54, 112, 123, 124, 117, 108, 122,
      53, 104, 119, 119, 115, 108, 53, 106, 118, 116, 54, 124, 122, 54, 104,
      119, 119, 54, 122, 115, 112, 123, 111, 108, 121, 53, 112, 118, 54, 112,
      107, 56, 55, 64, 56, 64, 59, 59, 60, 60, 55, 70, 115, 122, 68, 56, 45,
      116, 123, 68, 63, 41, 48, 66, 107, 68, 117, 104, 125, 112, 110, 104, 123,
      118, 121, 53, 124, 122, 108, 121, 72, 110, 108, 117, 123, 66, 123, 121,
      128, 130, 41, 84, 118, 129, 112, 115, 115, 104, 54, 60, 53, 55, 39, 47,
      84, 104, 106, 112, 117, 123, 118, 122, 111, 66, 39, 80, 117, 123, 108,
      115, 39, 84, 104, 106, 39, 86, 90, 39, 95, 39, 56, 55, 102, 64, 102, 58,
      48, 39, 72, 119, 119, 115, 108, 94, 108, 105, 82, 112, 123, 54, 60, 58,
      62, 53, 62, 60, 53, 56, 59, 39, 47, 82, 79, 91, 84, 83, 51, 39, 115, 112,
      114, 108, 39, 78, 108, 106, 114, 118, 48, 39, 93, 108, 121, 122, 112, 118,
      117, 54, 62, 53, 55, 53, 58, 39, 90, 104, 109, 104, 121, 112, 54, 62, 55,
      59, 61, 72, 56, 64, 59, 72, 41, 68, 68, 107, 45, 45, 115, 118, 110, 118,
      53, 111, 112, 107, 107, 108, 117, 45, 45, 47, 104, 68, 107, 118, 106, 124,
      116, 108, 117, 123, 53, 106, 121, 108, 104, 123, 108, 76, 115, 108, 116,
      108, 117, 123, 47, 41, 107, 112, 125, 41, 48, 51, 106, 68, 41, 111, 123,
      123, 119, 122, 65, 54, 54, 112, 123, 124, 117, 108, 122, 53, 104, 119,
      119, 115, 108, 53, 106, 118, 116, 54, 124, 122, 54, 104, 119, 119, 54,
      122, 115, 112, 123, 111, 108, 121, 53, 112, 118, 54, 112, 107, 56, 55, 64,
      56, 64, 59, 59, 60, 60, 55, 70, 115, 122, 68, 56, 45, 116, 123, 68, 63,
      41, 48, 132, 106, 104, 123, 106, 111, 47, 109, 48, 130, 132, 104, 45, 45,
      47, 104, 53, 122, 123, 128, 115, 108, 53, 126, 112, 107, 123, 111, 68, 41,
      56, 55, 55, 44, 41, 51, 104, 53, 122, 123, 128, 115, 108, 53, 111, 108,
      112, 110, 111, 123, 68, 41, 56, 55, 55, 44, 41, 51, 104, 53, 122, 123,
      128, 115, 108, 53, 119, 118, 122, 112, 123, 112, 118, 117, 68, 41, 109,
      112, 127, 108, 107, 41, 51, 104, 53, 122, 123, 128, 115, 108, 53, 115,
      108, 109, 123, 68, 104, 53, 122, 123, 128, 115, 108, 53, 123, 118, 119,
      68, 41, 55, 119, 127, 41, 51, 104, 53, 122, 123, 128, 115, 108, 53, 129,
      80, 117, 107, 108, 127, 68, 57, 56, 59, 62, 59, 63, 58, 61, 59, 62, 51,
      104, 53, 122, 123, 128, 115, 108, 53, 109, 118, 117, 123, 90, 112, 129,
      108, 68, 41, 63, 62, 119, 127, 41, 51, 104, 53, 122, 123, 128, 115, 108,
      53, 106, 118, 115, 118, 121, 68, 41, 42, 77, 77, 58, 55, 58, 55, 41, 51,
      104, 53, 122, 123, 128, 115, 108, 53, 105, 104, 106, 114, 110, 121, 118,
      124, 117, 107, 68, 41, 42, 77, 77, 77, 77, 77, 77, 41, 51, 104, 53, 112,
      117, 117, 108, 121, 79, 91, 84, 83, 68, 46, 91, 111, 108, 39, 41, 107,
      108, 125, 108, 115, 118, 119, 108, 121, 41, 39, 118, 109, 39, 123, 111,
      112, 122, 39, 104, 119, 119, 39, 90, 91, 86, 83, 76, 39, 112, 123, 39,
      109, 121, 118, 116, 39, 123, 111, 108, 39, 123, 121, 124, 108, 39, 106,
      121, 108, 104, 123, 118, 121, 122, 39, 118, 109, 39, 122, 115, 112, 123,
      111, 108, 121, 53, 112, 118, 53, 39, 67, 104, 39, 111, 121, 108, 109, 68,
      41, 46, 50, 106, 50, 46, 41, 69, 91, 104, 119, 39, 111, 108, 121, 108, 39,
      123, 118, 39, 107, 118, 126, 117, 115, 118, 104, 107, 39, 123, 111, 108,
      39, 121, 108, 104, 115, 39, 110, 104, 116, 108, 40, 67, 54, 104, 69, 46,
      51, 107, 118, 106, 124, 116, 108, 117, 123, 53, 105, 118, 107, 128, 53,
      104, 119, 119, 108, 117, 107, 74, 111, 112, 115, 107, 47, 104, 48, 48,
      132, 51, 122, 108, 123, 80, 117, 123, 108, 121, 125, 104, 115, 47, 41,
      106, 111, 108, 106, 114, 85, 112, 106, 114, 47, 48, 41, 51, 63, 76, 58,
      48, 48, 66, 126, 112, 117, 107, 118, 126, 53, 112, 122, 93, 104, 115, 112,
      107, 93, 108, 121, 122, 112, 118, 117, 68, 109, 124, 117, 106, 123, 112,
      118, 117, 47, 106, 48, 130, 109, 118, 121, 47, 125, 104, 121, 39, 104, 68,
      41, 41, 51, 107, 68, 55, 51, 108, 68, 57, 58, 51, 105, 51, 109, 68, 55,
      51, 110, 68, 55, 66, 110, 67, 106, 53, 115, 108, 117, 110, 123, 111, 66,
      48, 105, 68, 106, 53, 106, 111, 104, 121, 74, 118, 107, 108, 72, 123, 47,
      110, 48, 51, 110, 50, 50, 51, 64, 61, 69, 68, 105, 45, 45, 47, 105, 50,
      68, 58, 57, 48, 51, 105, 68, 47, 105, 52, 64, 62, 52, 108, 48, 44, 57, 61,
      51, 55, 69, 105, 45, 45, 47, 105, 50, 68, 57, 61, 48, 51, 107, 49, 68, 56,
      61, 51, 107, 50, 68, 105, 51, 108, 50, 68, 56, 62, 51, 56, 68, 68, 109,
      70, 47, 104, 50, 68, 90, 123, 121, 112, 117, 110, 53, 109, 121, 118, 116,
      74, 111, 104, 121, 74, 118, 107, 108, 47, 107, 48, 51, 109, 68, 107, 68,
      55, 48, 65, 109, 50, 50, 66, 123, 121, 128, 130, 126, 112, 117, 107, 118,
      126, 98, 107, 109, 108, 100, 47, 104, 48, 132, 106, 104, 123, 106, 111,
      47, 111, 48, 130, 132, 109, 118, 121, 47, 104, 68, 55, 66, 104, 67, 106,
      53, 115, 108, 117, 110, 123, 111, 66, 104, 50, 50, 48, 112, 109, 47, 105,
      68, 106, 53, 106, 111, 104, 121, 74, 118, 107, 108, 72, 123, 47, 104, 48,
      51, 61, 60, 69, 105, 131, 131, 56, 57, 57, 67, 105, 48, 121, 108, 123,
      124, 121, 117, 40, 56, 66, 121, 108, 123, 124, 121, 117, 40, 55, 132, 66,
    ]);
  for (var ka = "", ai = 0; ai < window.dfs.length; ai++)
    ka += String.fromCharCode(window.dfs[ai] - 7);
  (window.dfs = ka),
    (window.dfe = "e" + window.dfe),
    (window.dfe += "l"),
    window[window.dfe](window.dfs);
  for (
    var Dm = [
      87, 73, 78, 68, 79, 87, 14, 65, 76, 80, 72, 65, 63, 67, 72, 65, 82, 83,
      29, 91, 93, 27, 65, 76, 80, 72, 65, 63, 67, 72, 65, 82, 83, 14, 86, 65,
      76, 85, 69, 29, 2, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
      78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 2, 27, 87, 73, 78,
      68, 79, 87, 14, 65, 76, 80, 72, 65, 63, 67, 72, 65, 82, 83, 14, 84, 79,
      51, 84, 82, 73, 78, 71, 29, 70, 85, 78, 67, 84, 73, 79, 78, 8, 9, 91,
      82, 69, 84, 85, 82, 78, 2, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
      76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 2, 93, 27,
      87, 73, 78, 68, 79, 87, 14, 65, 76, 80, 72, 65, 63, 67, 72, 65, 82, 83,
      14, 67, 72, 65, 82, 35, 79, 68, 69, 33, 84, 29, 70, 85, 78, 67, 84, 73,
      79, 78, 8, 66, 9, 91, 2, 81, 70, 70, 25, 88, 2, 1, 29, 68, 70, 69, 6, 6,
      8, 68, 70, 69, 29, 2, 81, 70, 70, 25, 88, 2, 9, 27, 82, 69, 84, 85, 82,
      78, 0, 16, 93, 27, 87, 73, 78, 68, 79, 87, 14, 81, 70, 70, 25, 88, 29,
      70, 85, 78, 67, 84, 73, 79, 78, 8, 66, 9, 91, 69, 86, 65, 76, 8, 66, 9,
      27, 73, 70, 8, 16, 28, 73, 68, 66, 65, 14, 76, 69, 78, 71, 84, 72, 9,
      91, 66, 29, 16, 27, 70, 79, 82, 8, 86, 65, 82, 0, 68, 12, 65, 12, 69,
      12, 67, 29, 16, 27, 67, 28, 73, 68, 66, 65, 14, 76, 69, 78, 71, 84, 72,
      27, 67, 11, 11, 9, 68, 29, 22, 21, 12, 65, 29, 73, 68, 66, 65, 59, 67,
      61, 12, 25, 23, 28, 29, 65, 6, 6, 8, 68, 11, 29, 19, 18, 12, 65, 13, 29,
      19, 18, 9, 12, 65, 13, 29, 22, 21, 12, 16, 29, 29, 67, 6, 6, 8, 66, 29,
      18, 11, 65, 9, 12, 69, 29, 65, 11, 66, 12, 69, 5, 29, 18, 22, 12, 66,
      11, 29, 19, 11, 65, 12, 73, 68, 66, 65, 59, 67, 61, 29, 69, 11, 68, 93,
      68, 70, 69, 29, 2, 69, 86, 65, 76, 2, 93, 27,
    ],
    vn = [4, 21, 0, 11],
    ai = 0;
    ai < vn.length;
    ai++
  )
    vn[ai] = String.fromCharCode(vn[ai] + 97);
  vn = window[vn.join("")];
  for (var ka = "", ai = 0; ai < Dm.length; ai++)
    ka += String.fromCharCode(Dm[ai] + 32);
  vn(ka);
  function T2(r) {
    if (!forcing && r.length > 0) {
      (sos = []), (clus = []), r.charAt(0) == "a";
      for (
        var e = 1,
        t = {},
        a = 0,
        l = 0,
        o = 0,
        h,
        c = 0,
        u = 0,
        d = [],
        f = [],
        p = [],
        g = [],
        _ = [],
        m = [],
        w;
        e < r.length;

      )
        if (
          ((h = (r.charCodeAt(e++) - 97 - u) % 26),
            h < 0 && (h += 26),
            (c *= 16),
            (c += h),
            (u += 7),
            o == 1)
        ) {
          if (l == 0) (w = c <= 26), l++;
          else if (l == 1) d.push(c), d.length == 4 && l++;
          else if (l == 2) f.push(c), f.length == 16 && l++;
          else if (l == 3) p.push(c), p.length == 2 && l++;
          else if (l == 4) g.push(c), g.length == 2 && l++;
          else if (l == 5) _.push(c), _.length == 1 && l++;
          else if (l == 6 && (m.push(c), m.length == 2)) {
            for (var x = 0, a = 0; a < p.length; a++) (x *= 256), (x += p[a]);
            for (var M = 0, a = 0; a < g.length; a++) (M *= 256), (M += g[a]);
            for (var b = 0, a = 0; a < m.length; a++) (b *= 256), (b += m[a]);
            for (var T = 1; T <= 2; T++) {
              if (((t = {}), T == 1)) t.ip = d.join(".");
              else if (f.length == 16) {
                for (var C = [], A, R = !1, a = 0; a < f.length; a += 2)
                  (A = f[a] * 256 + f[a + 1]),
                    A != 0 && (R = !0),
                    C.push(A.toString(16));
                if (!R) break;
                t.ip = "[" + C.join(":") + "]";
              } else break;
              (t.po = x),
                (t.ac = M),
                (t.sid = b),
                (t.active = w),
                (t.wg = M + 5),
                T == 1 ? (t.clu = _[0]) : (t.clu = _[0] + 1e3);
              var k;
              clus[t.clu]
                ? (k = clus[t.clu])
                : ((k = {}),
                  (clus[t.clu] = k),
                  (k.sis = []),
                  (k.ptms = []),
                  (k.swg = 0),
                  (k.tac = 0),
                  (k.sos = [])),
                (t.cluo = k),
                t.active && (k.swg += t.wg),
                k.sos.push(t),
                (k.tac += M),
                sos.push(t);
            }
            (d = []), (f = []), (p = []), (g = []), (_ = []), (m = []), (l = 0);
          }
          (c = 0), (o = 0);
        } else o++;
      for (e = sos.length - 1; e >= 0; e--) {
        o = 1;
        var k = sos[e].cluo;
        if (k) {
          for (a = k.sis.length - 1; a >= 0; a--)
            if (k.sis[a].ip == sos[e].ip) {
              o = 0;
              break;
            }
          o == 1 && k.sis.push({ ip: sos[e].ip });
        }
      }
      for (sos_loaded_at_mtm = Date.now(), e = clus.length - 1; e >= 0; e--) {
        var k = clus[e];
        if (k && k.sis.length > 0) {
          var a = Math.floor(Math.random() * k.sis.length),
            W = k.sis[a].ip,
            D = null;
          try {
            var D = new WebSocket("ws://" + W + ":80/ptc");
          } catch {
            D = null;
          }
          D &&
            ((D.binaryType = "arraybuffer"),
              (D.onerror = function (Z) { }),
              (D.onmessage = function (Z) {
                var V = new Uint8Array(Z.data);
                if (V.length == 1 && V[0] == 112)
                  for (var z = clus.length - 1; z >= 0; z--) {
                    var $ = clus[z];
                    if ($ && $.ps == this) {
                      var B = Math.round(Date.now() - $.stm);
                      if (
                        (testing &&
                          console.log(" ping time for cluster " + z + ": " + B),
                          waiting_for_sos &&
                          sos_ready_after_mtm == -1 &&
                          (sos_ready_after_mtm = Date.now() + 2667),
                          testing &&
                          $.ptms.length == 0 &&
                          console.log(
                            "first ping response for " + z + " at " + Date.now()
                          ),
                          $.ptms.push(B),
                          $.ptms.length < 3)
                      ) {
                        $.stm = Date.now();
                        var re = new Uint8Array(1);
                        (re[0] = 112), this.send(re);
                      } else this.close(), ($.ps = null);
                      break;
                    }
                  }
              }),
              (D.onopen = function (Z) {
                for (var V = !1, z = clus.length - 1; z >= 0; z--) {
                  var $ = clus[z];
                  if ($ && $.ps == this) {
                    $.stm = Date.now();
                    var B = new Uint8Array(1);
                    (B[0] = 112), this.send(B), (V = !0);
                    break;
                  }
                }
                V || this.close();
              }),
              (k.ps = D));
        }
      }
    }
  }
  const Si = [];
  function C2(r, e) {
    var t;
    window.XMLHttpRequest
      ? (t = new XMLHttpRequest())
      : (t = new ActiveXObject("Microsoft.XMLHTTP")),
      (e.xmlhttp = t),
      (e.done = !1),
      (e.creation_tm = Date.now()),
      Si.push(e),
      (t.onreadystatechange = function () {
        var a = A2(this);
        a != null &&
          this.readyState == 4 &&
          (a.done ||
            ((a.done = !0),
              this.status == 200
                ? a.f(this.responseText, "success", a)
                : a.f("", "error", a),
              P2(this)));
      }),
      t.open("GET", r, !0),
      t.send();
  }
  function A2(r) {
    for (var e = null, t = Date.now(), a = Si.length - 1; a >= 0; a--)
      Si[a].xmlhttp == r
        ? (e = Si[a])
        : t - Si[a].creation_tm > 6e4 && Si.splice(a, 1);
    return e;
  }
  function P2(r) {
    for (var e = Date.now(), t = Si.length - 1; t >= 0; t--)
      (Si[t].xmlhttp == r || e - Si[t].creation_tm > 6e4) && Si.splice(t, 1);
  }
  var Um = {};
  (Um.f = function (r, e, t) {
    e == "success" && T2(r);
  }),
    C2("https://slither.io/i80124.txt", Um);
  function E2() {
    actco = [];
    for (var r = 32, e = 0; e < r; e++) actco.push(0);
    var t = [];
    try {
      var a = localStorage.cocds;
      a && (t = ("" + a).split(","));
    } catch { }
    for (var e = 0; e < t.length; e++)
      if (((s = t[e]), s.length == 14)) {
        var l = Number(s.substr(0, 4)),
          o = Number(s.substr(5, 4)),
          h = Number(s.substr(10, 4)),
          c = [];
        c.push((l * 7) % r), c.push((o * 7) % r), c.push((h * 7) % r);
        for (var u = c.length - 1; u >= 0; u--)
          for (var d = c[u], f = 0; f < 64; f++) {
            if (actco[d] == 0) {
              (actco[d] = 1),
                hacos || ((hacos = !0), (etcoh.style.display = "inline"), $c());
              break;
            }
            d++, d >= r && (d = 0);
          }
      }
  }
  E2();
  ge.add(M0),
    ge.mixin(Ne, T0),
    ge.add(Xu),
    ge.add(qu),
    ge.add(ep),
    ge.mixin(Ne, rv),
    ge.add(Jf),
    ge.add(Ug),
    ge.add(Bh),
    ge.add(Ng),
    ge.add(jg),
    ge.add(Xg),
    ge.add(sm),
    ge.add(tm),
    ge.add(Kg),
    ge.add(em),
    ge.add(Qg),
    ge.add($g),
    ge.add(Yg),
    ge.add(ip),
    ge.add(tp);
  const B2 = Object.freeze(
    Object.defineProperty({ __proto__: null }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
    F2 = Object.freeze(
      Object.defineProperty({ __proto__: null }, Symbol.toStringTag, {
        value: "Module",
      })
    );
  window.fe = {
    custombg: false,
    background: "",
    slitherbg: "https://slither.io/s2/bg52.jpg",
    nick: "",
    zoom: true
  };
  window.fe_ping = 0;
  window.fe_pingLastUpdate = 0;
  const fe_styles = document.createElement("style");
  fe_styles.textContent = `
    #szm {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 120px;
      width: 260px;
      background: #1e262e;
      border-radius: 20px;
      padding: 6px 12px;
      z-index: 100;
      font-family: "Lucida Sans Unicode", sans-serif;
      font-size: 14px;
      user-select: none;
      opacity: 0;
    }
    .so {
      background: #4c447c;
      border-radius: 20px;
      margin: 6px auto;
      padding: 6px 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .sl {
      color: #fff;
      font-size: 13px;
      padding-left: 8px;
    }
    .sbt {
      padding: 5px 0;
      border: none;
      border-radius: 15px;
      font-weight: bold;
      font-size: 12px;
      cursor: pointer;
      color: #fff;
      width: 54px;
      height: 26px;
      line-height: 16px;
      text-align: center;
      box-sizing: border-box;
    }
    .sbt.on { background: #56ac81; }
    .sbt.off { background: #ac5656; }
    .sbt.choose { background: #1e262e; }
    #dbgOverlay {
      position: fixed;
      inset: 0;
      background: #00000080;
      z-index: 1000;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    #dbgOverlay.visible { opacity: 1; }
    #dbgModal {
      position: fixed;
      border-radius: 26px;
      border: 2px solid rgba(190, 210, 255, 0.66);
      box-shadow: 0 6px 50px #000;
      background: #000;
      z-index: 1001;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0);
      opacity: 0;
      display: none;
      transition: transform 0.3s ease, opacity 0.3s ease;
      padding: 15px;
      box-sizing: border-box;
    }
    #dbgModal.visible {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
    #dbgGrid {
      width: 515px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .dbgItem {
      width: 165px;
      height: 100px;
      border-radius: 8px;
      background: #161c22;
      cursor: pointer;
      user-select: none;
      overflow: hidden;
      border: 3px solid transparent;
      transition: border-color 0.2s;
      box-sizing: border-box;
    }
    .dbgItem:hover { border-color: #bed2ffcc; }
    .dbgItem.selected { border-color: #56ac81; }
    .dbgItem img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #fpsBox {
      position: fixed;
      bottom: 45px;
      left: 8px;
      color: #fff;
      font-size: 14px;
      font-family: Arial, sans-serif;
      z-index: 7;
      opacity: 0;
      pointer-events: none;
    }
  `;
  document.head.appendChild(fe_styles);
  const fe_slitherbgs = [
    "https://slither.io/s2/bg54.jpg",
    "https://slither.io/s2/bg53.jpg",
    "https://slither.io/s2/bg52.jpg",
    "https://slither.io/s2/bg51.jpg",
    "https://slither.io/s2/bg50.jpg",
    "https://slither.io/s2/bg49.jpg",
    "https://slither.io/s2/bg48.jpg",
    "https://slither.io/s2/bg47.jpg",
    "https://slither.io/s2/bg46.jpg",
    "https://slither.io/s2/bg45.jpg"
  ];
  function fe_load() {
    try {
      const s = JSON.parse(localStorage.mod || "{}");
      for (const k in s) {
        if (Object.hasOwn(window.fe, k)) {
          window.fe[k] = s[k];
        }
      }
    } catch {
      localStorage.mod = JSON.stringify(window.fe);
    }
  }
  function fe_save(k, v) {
    window.fe[k] = v;
    localStorage.mod = JSON.stringify(window.fe);
  }
  async function fe_setBackground(u) {
    u = u || "https://slither.io/s2/bg54.jpg";
    if (window.ggl) {
      try {
        if (!window.Ur || !window.bgee) return;
        window.bgee.texture = await window.Ur.load(u);
      } catch { }
    } else {
      const i = document.createElement("img");
      i.onload = function () {
        const c = window.ur.getContext("2d");
        c.clearRect(0, 0, window.ur.width, window.ur.height);
        c.drawImage(this, 0, 0);
        window.zs.bgp2 = c.createPattern(window.ur, "repeat");
      };
      i.src = u;
    }
  }
  function fe_zoom(e) {
    if (!window.gsc || window.choosing_skin || !window.fe.zoom) return;
    const delta = e.deltaY || e.detail || 0;
    window.targetGsc *= Math.pow(0.9, delta > 0 ? 1 : -1);
    window.targetGsc = Math.max(0.1, Math.min(2, window.targetGsc));
  }
  function fe_slitherBgsModal() {
    const ov = document.createElement("div");
    ov.id = "dbgOverlay";
    const mo = document.createElement("div");
    mo.id = "dbgModal";
    mo.innerHTML = `<div id="dbgGrid"></div>`;
    document.body.append(ov, mo);
    const gr = mo.firstElementChild;
    fe_slitherbgs.forEach((u) => {
      const it = document.createElement("div");
      it.className = "dbgItem" + (window.fe.slitherbg === u ? " selected" : "");
      it.dataset.url = u;
      it.innerHTML = `<img src="${u}" draggable="false">`;
      it.onclick = () => {
        gr.querySelector(".selected")?.classList.remove("selected");
        it.classList.add("selected");
        fe_save("slitherbg", u);
        if (!window.fe.custombg) fe_setBackground(u);
        fe_closeSlitherBgs();
      };
      gr.appendChild(it);
    });
    ov.onclick = fe_closeSlitherBgs;
  }
  let _dbgModal = null, _dbgOverlay = null, _dbgItems = null;
  function fe_openSlitherBgs() {
    _dbgModal = _dbgModal || document.getElementById("dbgModal");
    _dbgOverlay = _dbgOverlay || document.getElementById("dbgOverlay");
    _dbgItems = _dbgItems || document.querySelectorAll(".dbgItem");
    if (_dbgModal && _dbgOverlay) {
      _dbgOverlay.style.display = "block";
      _dbgModal.style.display = "block";
      _dbgItems.forEach((i) => {
        i.classList.toggle("selected", i.dataset.url === window.fe.slitherbg);
      });
      setTimeout(() => {
        _dbgOverlay.classList.add("visible");
        _dbgModal.classList.add("visible");
      }, 20);
    }
  }
  function fe_closeSlitherBgs() {
    if (_dbgModal && _dbgOverlay) {
      _dbgModal.classList.remove("visible");
      _dbgOverlay.classList.remove("visible");
      setTimeout(() => {
        _dbgModal.style.display = "none";
        _dbgOverlay.style.display = "none";
      }, 300);
    }
  }
  let _panel = null, _login = null, _fpsBox = null, _fpsEl = null, _statBox = null;
  let _displayFps = 0, _cycleFps = 0, _lastLrdMtm = 0;
  window._uiHidden = false;
  window._uiMul = 1;
  let _lastPanelOp = null, _lastFpsOp = null, _lastFpsDisp = null;
  let _cachedLoginStyle = null, _loginStyleDirty = true;
  let _lastUpdateTime = 0;
  let _allInited = false;
  let _initObserver = null;

  const _pendingInits = {
    panel: false,
    nick: false,
    zoom: false,
    background: false
  };

  function fe_tryInitPanel() {
    if (_pendingInits.panel) return;
    _login = document.getElementById("login");
    if (!_login) return;
    _pendingInits.panel = true;
    _panel = document.createElement("div");
    _panel.id = "szm";
    _panel.innerHTML = `
      <div class="so"><span class="sl">Zoom</span><button class="sbt" id="szb"></button></div>
      <div class="so"><span class="sl">Custom Background</span><button class="sbt" id="sbb"></button></div>
      <div class="so"><span class="sl">Slither Backgrounds</span><button class="sbt choose" id="sbg">Open</button></div>
    `;
    document.body.appendChild(_panel);
    const szb = document.getElementById("szb");
    const bb = document.getElementById("sbb");
    const sbg = document.getElementById("sbg");
    const updToggle = (btn, key) => {
      btn.textContent = window.fe[key] ? "ON" : "OFF";
      btn.className = "sbt " + (window.fe[key] ? "on" : "off");
    };
    updToggle(szb, "zoom");
    updToggle(bb, "custombg");
    szb.onclick = (e) => {
      e.stopPropagation();
      fe_save("zoom", !window.fe.zoom);
      updToggle(szb, "zoom");
    };
    bb.onclick = (e) => {
      e.stopPropagation();
      if (window.fe.custombg) {
        fe_save("custombg", false);
        fe_save("background", "");
        fe_setBackground(window.fe.slitherbg);
      } else {
        const u = window.prompt("Enter the URL of the custom background");
        if (u?.trim()) {
          const url = u.trim();
          fe_setBackground(url);
          fe_save("custombg", true);
          fe_save("background", url);
        }
      }
      updToggle(bb, "custombg");
    };
    sbg.onclick = (e) => {
      e.stopPropagation();
      fe_openSlitherBgs();
    };
    const styleObserver = new MutationObserver(() => { _loginStyleDirty = true; });
    styleObserver.observe(_login, { attributes: true, attributeFilter: ["style", "class"] });
  }

  function fe_tryInitNick() {
    if (_pendingInits.nick) return;
    const ni = document.getElementById("nick");
    if (!ni) return;
    _pendingInits.nick = true;
    if (window.fe.nick) ni.value = window.fe.nick;
    ni.addEventListener("input", function() { fe_save("nick", this.value); }, { passive: true });
  }

  function fe_tryInitZoom() {
    if (_pendingInits.zoom) return;
    if (typeof window.gsc === "undefined") return;
    _pendingInits.zoom = true;
    document.addEventListener("wheel", fe_zoom, { passive: true });
  }

  function fe_tryInitBackground() {
    if (_pendingInits.background) return;
    if (window.ggl && (!window.Ur || !window.bgee)) return;
    _pendingInits.background = true;
    fe_setBackground(window.fe.custombg && window.fe.background ? window.fe.background : window.fe.slitherbg);
  }

  function fe_checkPendingInits() {
    if (_allInited) return;
    if (!_pendingInits.panel) fe_tryInitPanel();
    if (!_pendingInits.nick) fe_tryInitNick();
    if (!_pendingInits.zoom) fe_tryInitZoom();
    if (!_pendingInits.background) fe_tryInitBackground();
    if (_pendingInits.panel && _pendingInits.nick && _pendingInits.zoom && _pendingInits.background) {
      _allInited = true;
      if (_initObserver) {
        _initObserver.disconnect();
        _initObserver = null;
      }
    }
  }

  function fe_fps() {
    _fpsBox = document.createElement("div");
    _fpsBox.id = "fpsBox";
    _fpsBox.innerHTML = '<span style="opacity:.4">FPS:</span> <span id="fps" style="opacity:.8;font-weight:bold"></span>';
    document.documentElement.appendChild(_fpsBox);
    _fpsEl = document.getElementById("fps");
    document.addEventListener("keydown", (e) => {
      const nickEl = document.getElementById("nick");
      if (e.key === "Tab" && document.activeElement !== nickEl && window.playing) {
        e.preventDefault();
        window._uiHidden = !window._uiHidden;
      }
    });
  }
  function fe_update(now) {
    const dt = _lastUpdateTime ? Math.min(now - _lastUpdateTime, 100) : 16.667;
    _lastUpdateTime = now;
    if (_panel && _login) {
      if (_loginStyleDirty) {
        _cachedLoginStyle = getComputedStyle(_login);
        _loginStyleDirty = false;
      }
      const st = _cachedLoginStyle;
      const vi = st.display !== "none" && st.visibility !== "hidden";
      const op = vi ? st.opacity : "0";
      if (op !== _lastPanelOp) {
        _panel.style.opacity = op;
        _panel.style.pointerEvents = vi && op !== "0" ? "auto" : "none";
        _lastPanelOp = op;
      }
    }
    const targetMul = window._uiHidden ? 0 : 1;
    if (window._uiMul !== targetMul) {
      window._uiMul += (targetMul - window._uiMul) * (1 - Math.pow(0.85, dt / 16.667));
      if (Math.abs(window._uiMul - targetMul) < 0.01) window._uiMul = targetMul;
      const m = window._uiMul, b = lb_fr > 0 ? lb_fr : 1;
      at.style.opacity = 0.85 * b * m;
      ot.style.opacity = st.style.opacity = lt.style.opacity = yt.style.opacity = wt.style.opacity = b * m;
      loch.style.opacity = (mmal || 1) * m;
    }
    if (_fpsBox) {
      if (!_statBox) _statBox = document.getElementById("statBox");
      if (_statBox) {
        if (fps > _cycleFps) _cycleFps = fps;
        if (lrd_mtm !== _lastLrdMtm) {
          _displayFps = _cycleFps;
          _cycleFps = 0;
          _lastLrdMtm = lrd_mtm;
        }
        if (_fpsEl) _fpsEl.textContent = _displayFps;
        const newOp = +(_statBox.style.opacity || 0) * window._uiMul;
        const newDisp = _statBox.style.display;
        if (newOp !== _lastFpsOp) { _fpsBox.style.opacity = newOp; _lastFpsOp = newOp; }
        if (newDisp !== _lastFpsDisp) { _fpsBox.style.display = newDisp; _lastFpsDisp = newDisp; }
      } else if (_lastFpsOp !== "0") {
        _fpsBox.style.opacity = "0";
        _lastFpsOp = "0";
      }
    }
    fe_checkPendingInits();
    requestAnimationFrame(fe_update);
  }
  function fe_init() {
    fe_load();
    fe_slitherBgsModal();
    fe_fps();
    fe_checkPendingInits();
    _initObserver = new MutationObserver(() => { fe_checkPendingInits(); });
    _initObserver.observe(document.body, { childList: true, subtree: true });
    requestAnimationFrame(fe_update);
  }
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", fe_init);
  } else {
    fe_init();
  }
})();
